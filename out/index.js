"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || /* @__PURE__ */ __name(function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    }, "homedir");
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    __name(win32SplitPath, "win32SplitPath");
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    __name(posixSplitPath, "posixSplitPath");
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path2 = require("path");
    var parse2 = path2.parse || require_path_parse();
    var getNodeModulesDirs = /* @__PURE__ */ __name(function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse2(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse2(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path2.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    }, "getNodeModulesDirs");
    module2.exports = /* @__PURE__ */ __name(function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(request, start, function() {
          return getNodeModulesDirs(start, modules);
        }, opts);
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    }, "nodeModulesPaths");
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = /* @__PURE__ */ __name(function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = /* @__PURE__ */ __name(function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      }, "binder");
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = /* @__PURE__ */ __name(function Empty2() {
        }, "Empty");
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    }, "bind");
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var has = require_src();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    __name(specifierIncluded, "specifierIncluded");
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    __name(matchesRange, "matchesRange");
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    __name(versionIncluded, "versionIncluded");
    var data = require_core();
    module2.exports = /* @__PURE__ */ __name(function isCore(x, nodeVersion) {
      return has(data, x) && versionIncluded(nodeVersion, data[x]);
    }, "isCore");
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports2, module2) {
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path2 = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = /* @__PURE__ */ __name(function() {
      return [
        path2.join(homedir, ".node_modules"),
        path2.join(homedir, ".node_libraries")
      ];
    }, "defaultPaths");
    var defaultIsFile = /* @__PURE__ */ __name(function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    }, "isFile");
    var defaultIsDir = /* @__PURE__ */ __name(function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    }, "isDirectory");
    var defaultRealpath = /* @__PURE__ */ __name(function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    }, "realpath");
    var maybeRealpath = /* @__PURE__ */ __name(function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    }, "maybeRealpath");
    var defaultReadPackage = /* @__PURE__ */ __name(function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    }, "defaultReadPackage");
    var getPackageCandidates = /* @__PURE__ */ __name(function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path2.join(dirs[i], x);
      }
      return dirs;
    }, "getPackageCandidates");
    module2.exports = /* @__PURE__ */ __name(function resolve2(x, options2, callback) {
      var cb = callback;
      var opts = options2;
      if (typeof options2 === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path2.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path2.resolve(basedir);
      maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {
        if (err2)
          cb(err2);
        else
          init(realStart);
      });
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path2.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n3, pkg) {
            if (err2)
              cb(err2);
            else if (n3) {
              return maybeRealpath(realpath, n3, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      __name(init, "init");
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      __name(onfile, "onfile");
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path2.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path2.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load([""].concat(extensions.slice()), path2.resolve(dir, r), pkg);
            }
            isFile(file, onex);
          }
          __name(onpkg, "onpkg");
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
          __name(onex, "onex");
        }
        __name(load, "load");
      }
      __name(loadAsFile, "loadAsFile");
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path2.dirname(dir), cb2);
          var pkgfile = path2.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path2.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      __name(loadpkg, "loadpkg");
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path2.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path2.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path2.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path2.join(x2, "index"), pkg2, cb2);
                  var dir = path2.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n3, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n3)
                      return cb2(null, n3, pkg3);
                    loadAsFile(path2.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path2.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      __name(loadAsDirectory, "loadAsDirectory");
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path2.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        __name(isdir, "isdir");
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        __name(onfile2, "onfile");
        function ondir(err2, n3, pkg) {
          if (err2)
            return cb2(err2);
          if (n3)
            return cb2(null, n3, pkg);
          processDirs(cb2, dirs.slice(1));
        }
        __name(ondir, "ondir");
      }
      __name(processDirs, "processDirs");
      function loadNodeModules(x2, start, cb2) {
        var thunk = /* @__PURE__ */ __name(function() {
          return getPackageCandidates(x2, start, opts);
        }, "thunk");
        processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());
      }
      __name(loadNodeModules, "loadNodeModules");
    }, "resolve");
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "node:test": ">= 18",
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: ">= 13.4 && < 13.5",
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports2, module2) {
    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
    function specifierIncluded(specifier) {
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        } else if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    __name(specifierIncluded, "specifierIncluded");
    function matchesRange(range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    __name(matchesRange, "matchesRange");
    function versionIncluded(specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(specifierValue);
    }
    __name(versionIncluded, "versionIncluded");
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports2, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = /* @__PURE__ */ __name(function isCore(x) {
      return isCoreModule(x);
    }, "isCore");
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path2 = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = /* @__PURE__ */ __name(function() {
      return [
        path2.join(homedir, ".node_modules"),
        path2.join(homedir, ".node_libraries")
      ];
    }, "defaultPaths");
    var defaultIsFile = /* @__PURE__ */ __name(function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    }, "isFile");
    var defaultIsDir = /* @__PURE__ */ __name(function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    }, "isDirectory");
    var defaultRealpathSync = /* @__PURE__ */ __name(function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    }, "realpathSync");
    var maybeRealpathSync = /* @__PURE__ */ __name(function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    }, "maybeRealpathSync");
    var defaultReadPackageSync = /* @__PURE__ */ __name(function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    }, "defaultReadPackageSync");
    var getPackageCandidates = /* @__PURE__ */ __name(function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path2.join(dirs[i], x);
      }
      return dirs;
    }, "getPackageCandidates");
    module2.exports = /* @__PURE__ */ __name(function resolveSync(x, options2) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options2);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path2.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path2.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path2.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n3 = loadNodeModulesSync(x, absoluteStart);
        if (n3)
          return maybeRealpathSync(realpathSync, n3, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path2.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path2.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path2.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      __name(loadAsFileSync, "loadAsFileSync");
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path2.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path2.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return { pkg, dir };
      }
      __name(loadpkg, "loadpkg");
      function loadAsDirectorySync(x2) {
        var pkgfile = path2.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path2.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n4 = loadAsDirectorySync(path2.resolve(x2, pkg.main));
              if (n4)
                return n4;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path2.join(x2, "/index"));
      }
      __name(loadAsDirectorySync, "loadAsDirectorySync");
      function loadNodeModulesSync(x2, start) {
        var thunk = /* @__PURE__ */ __name(function() {
          return getPackageCandidates(x2, start, opts);
        }, "thunk");
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path2.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n4 = loadAsDirectorySync(dir);
            if (n4)
              return n4;
          }
        }
      }
      __name(loadNodeModulesSync, "loadNodeModulesSync");
    }, "resolveSync");
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports2, module2) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// node_modules/core-js/library/modules/_global.js
var require_global = __commonJS({
  "node_modules/core-js/library/modules/_global.js"(exports2, module2) {
    var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
    if (typeof __g == "number")
      __g = global2;
  }
});

// node_modules/core-js/library/modules/_has.js
var require_has = __commonJS({
  "node_modules/core-js/library/modules/_has.js"(exports2, module2) {
    var hasOwnProperty = {}.hasOwnProperty;
    module2.exports = function(it, key) {
      return hasOwnProperty.call(it, key);
    };
  }
});

// node_modules/core-js/library/modules/_fails.js
var require_fails = __commonJS({
  "node_modules/core-js/library/modules/_fails.js"(exports2, module2) {
    module2.exports = function(exec) {
      try {
        return !!exec();
      } catch (e) {
        return true;
      }
    };
  }
});

// node_modules/core-js/library/modules/_descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js/library/modules/_descriptors.js"(exports2, module2) {
    module2.exports = !require_fails()(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/library/modules/_core.js
var require_core4 = __commonJS({
  "node_modules/core-js/library/modules/_core.js"(exports2, module2) {
    var core = module2.exports = { version: "2.6.12" };
    if (typeof __e == "number")
      __e = core;
  }
});

// node_modules/core-js/library/modules/_a-function.js
var require_a_function = __commonJS({
  "node_modules/core-js/library/modules/_a-function.js"(exports2, module2) {
    module2.exports = function(it) {
      if (typeof it != "function")
        throw TypeError(it + " is not a function!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_ctx.js
var require_ctx = __commonJS({
  "node_modules/core-js/library/modules/_ctx.js"(exports2, module2) {
    var aFunction = require_a_function();
    module2.exports = function(fn, that, length) {
      aFunction(fn);
      if (that === void 0)
        return fn;
      switch (length) {
        case 1:
          return function(a) {
            return fn.call(that, a);
          };
        case 2:
          return function(a, b) {
            return fn.call(that, a, b);
          };
        case 3:
          return function(a, b, c) {
            return fn.call(that, a, b, c);
          };
      }
      return function() {
        return fn.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js/library/modules/_is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js/library/modules/_is-object.js"(exports2, module2) {
    module2.exports = function(it) {
      return typeof it === "object" ? it !== null : typeof it === "function";
    };
  }
});

// node_modules/core-js/library/modules/_an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js/library/modules/_an-object.js"(exports2, module2) {
    var isObject = require_is_object();
    module2.exports = function(it) {
      if (!isObject(it))
        throw TypeError(it + " is not an object!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_dom-create.js
var require_dom_create = __commonJS({
  "node_modules/core-js/library/modules/_dom-create.js"(exports2, module2) {
    var isObject = require_is_object();
    var document2 = require_global().document;
    var is2 = isObject(document2) && isObject(document2.createElement);
    module2.exports = function(it) {
      return is2 ? document2.createElement(it) : {};
    };
  }
});

// node_modules/core-js/library/modules/_ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js/library/modules/_ie8-dom-define.js"(exports2, module2) {
    module2.exports = !require_descriptors() && !require_fails()(function() {
      return Object.defineProperty(require_dom_create()("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
  }
});

// node_modules/core-js/library/modules/_to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js/library/modules/_to-primitive.js"(exports2, module2) {
    var isObject = require_is_object();
    module2.exports = function(it, S) {
      if (!isObject(it))
        return it;
      var fn, val;
      if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
        return val;
      if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
        return val;
      if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
        return val;
      throw TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js/library/modules/_object-dp.js
var require_object_dp = __commonJS({
  "node_modules/core-js/library/modules/_object-dp.js"(exports2) {
    var anObject = require_an_object();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var toPrimitive = require_to_primitive();
    var dP = Object.defineProperty;
    exports2.f = require_descriptors() ? Object.defineProperty : /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return dP(O, P, Attributes);
        } catch (e) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw TypeError("Accessors not supported!");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    }, "defineProperty");
  }
});

// node_modules/core-js/library/modules/_property-desc.js
var require_property_desc = __commonJS({
  "node_modules/core-js/library/modules/_property-desc.js"(exports2, module2) {
    module2.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js/library/modules/_hide.js
var require_hide = __commonJS({
  "node_modules/core-js/library/modules/_hide.js"(exports2, module2) {
    var dP = require_object_dp();
    var createDesc = require_property_desc();
    module2.exports = require_descriptors() ? function(object, key, value) {
      return dP.f(object, key, createDesc(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// node_modules/core-js/library/modules/_export.js
var require_export = __commonJS({
  "node_modules/core-js/library/modules/_export.js"(exports2, module2) {
    var global2 = require_global();
    var core = require_core4();
    var ctx = require_ctx();
    var hide = require_hide();
    var has = require_has();
    var PROTOTYPE = "prototype";
    var $export = /* @__PURE__ */ __name(function(type3, name, source) {
      var IS_FORCED = type3 & $export.F;
      var IS_GLOBAL = type3 & $export.G;
      var IS_STATIC = type3 & $export.S;
      var IS_PROTO = type3 & $export.P;
      var IS_BIND = type3 & $export.B;
      var IS_WRAP = type3 & $export.W;
      var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
      var expProto = exports3[PROTOTYPE];
      var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE];
      var key, own, out;
      if (IS_GLOBAL)
        source = name;
      for (key in source) {
        own = !IS_FORCED && target && target[key] !== void 0;
        if (own && has(exports3, key))
          continue;
        out = own ? target[key] : source[key];
        exports3[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function(C) {
          var F = /* @__PURE__ */ __name(function(a, b, c) {
            if (this instanceof C) {
              switch (arguments.length) {
                case 0:
                  return new C();
                case 1:
                  return new C(a);
                case 2:
                  return new C(a, b);
              }
              return new C(a, b, c);
            }
            return C.apply(this, arguments);
          }, "F");
          F[PROTOTYPE] = C[PROTOTYPE];
          return F;
        }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
        if (IS_PROTO) {
          (exports3.virtual || (exports3.virtual = {}))[key] = out;
          if (type3 & $export.R && expProto && !expProto[key])
            hide(expProto, key, out);
        }
      }
    }, "$export");
    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    module2.exports = $export;
  }
});

// node_modules/core-js/library/modules/_redefine.js
var require_redefine = __commonJS({
  "node_modules/core-js/library/modules/_redefine.js"(exports2, module2) {
    module2.exports = require_hide();
  }
});

// node_modules/core-js/library/modules/_uid.js
var require_uid = __commonJS({
  "node_modules/core-js/library/modules/_uid.js"(exports2, module2) {
    var id = 0;
    var px = Math.random();
    module2.exports = function(key) {
      return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
    };
  }
});

// node_modules/core-js/library/modules/_meta.js
var require_meta = __commonJS({
  "node_modules/core-js/library/modules/_meta.js"(exports2, module2) {
    var META = require_uid()("meta");
    var isObject = require_is_object();
    var has = require_has();
    var setDesc = require_object_dp().f;
    var id = 0;
    var isExtensible = Object.isExtensible || function() {
      return true;
    };
    var FREEZE = !require_fails()(function() {
      return isExtensible(Object.preventExtensions({}));
    });
    var setMeta = /* @__PURE__ */ __name(function(it) {
      setDesc(it, META, { value: {
        i: "O" + ++id,
        w: {}
      } });
    }, "setMeta");
    var fastKey = /* @__PURE__ */ __name(function(it, create) {
      if (!isObject(it))
        return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
      if (!has(it, META)) {
        if (!isExtensible(it))
          return "F";
        if (!create)
          return "E";
        setMeta(it);
      }
      return it[META].i;
    }, "fastKey");
    var getWeak = /* @__PURE__ */ __name(function(it, create) {
      if (!has(it, META)) {
        if (!isExtensible(it))
          return true;
        if (!create)
          return false;
        setMeta(it);
      }
      return it[META].w;
    }, "getWeak");
    var onFreeze = /* @__PURE__ */ __name(function(it) {
      if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
        setMeta(it);
      return it;
    }, "onFreeze");
    var meta = module2.exports = {
      KEY: META,
      NEED: false,
      fastKey,
      getWeak,
      onFreeze
    };
  }
});

// node_modules/core-js/library/modules/_library.js
var require_library = __commonJS({
  "node_modules/core-js/library/modules/_library.js"(exports2, module2) {
    module2.exports = true;
  }
});

// node_modules/core-js/library/modules/_shared.js
var require_shared = __commonJS({
  "node_modules/core-js/library/modules/_shared.js"(exports2, module2) {
    var core = require_core4();
    var global2 = require_global();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || (global2[SHARED] = {});
    (module2.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: core.version,
      mode: require_library() ? "pure" : "global",
      copyright: "\xA9 2020 Denis Pushkarev (zloirock.ru)"
    });
  }
});

// node_modules/core-js/library/modules/_wks.js
var require_wks = __commonJS({
  "node_modules/core-js/library/modules/_wks.js"(exports2, module2) {
    var store = require_shared()("wks");
    var uid = require_uid();
    var Symbol2 = require_global().Symbol;
    var USE_SYMBOL = typeof Symbol2 == "function";
    var $exports = module2.exports = function(name) {
      return store[name] || (store[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid)("Symbol." + name));
    };
    $exports.store = store;
  }
});

// node_modules/core-js/library/modules/_set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js/library/modules/_set-to-string-tag.js"(exports2, module2) {
    var def = require_object_dp().f;
    var has = require_has();
    var TAG2 = require_wks()("toStringTag");
    module2.exports = function(it, tag, stat) {
      if (it && !has(it = stat ? it : it.prototype, TAG2))
        def(it, TAG2, { configurable: true, value: tag });
    };
  }
});

// node_modules/core-js/library/modules/_wks-ext.js
var require_wks_ext = __commonJS({
  "node_modules/core-js/library/modules/_wks-ext.js"(exports2) {
    exports2.f = require_wks();
  }
});

// node_modules/core-js/library/modules/_wks-define.js
var require_wks_define = __commonJS({
  "node_modules/core-js/library/modules/_wks-define.js"(exports2, module2) {
    var global2 = require_global();
    var core = require_core4();
    var LIBRARY = require_library();
    var wksExt = require_wks_ext();
    var defineProperty = require_object_dp().f;
    module2.exports = function(name) {
      var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global2.Symbol || {});
      if (name.charAt(0) != "_" && !(name in $Symbol))
        defineProperty($Symbol, name, { value: wksExt.f(name) });
    };
  }
});

// node_modules/core-js/library/modules/_cof.js
var require_cof = __commonJS({
  "node_modules/core-js/library/modules/_cof.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = function(it) {
      return toString.call(it).slice(8, -1);
    };
  }
});

// node_modules/core-js/library/modules/_iobject.js
var require_iobject = __commonJS({
  "node_modules/core-js/library/modules/_iobject.js"(exports2, module2) {
    var cof = require_cof();
    module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };
  }
});

// node_modules/core-js/library/modules/_defined.js
var require_defined = __commonJS({
  "node_modules/core-js/library/modules/_defined.js"(exports2, module2) {
    module2.exports = function(it) {
      if (it == void 0)
        throw TypeError("Can't call method on  " + it);
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_to-iobject.js
var require_to_iobject = __commonJS({
  "node_modules/core-js/library/modules/_to-iobject.js"(exports2, module2) {
    var IObject = require_iobject();
    var defined = require_defined();
    module2.exports = function(it) {
      return IObject(defined(it));
    };
  }
});

// node_modules/core-js/library/modules/_to-integer.js
var require_to_integer = __commonJS({
  "node_modules/core-js/library/modules/_to-integer.js"(exports2, module2) {
    var ceil = Math.ceil;
    var floor = Math.floor;
    module2.exports = function(it) {
      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
    };
  }
});

// node_modules/core-js/library/modules/_to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js/library/modules/_to-length.js"(exports2, module2) {
    var toInteger = require_to_integer();
    var min = Math.min;
    module2.exports = function(it) {
      return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js/library/modules/_to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js/library/modules/_to-absolute-index.js"(exports2, module2) {
    var toInteger = require_to_integer();
    var max = Math.max;
    var min = Math.min;
    module2.exports = function(index, length) {
      index = toInteger(index);
      return index < 0 ? max(index + length, 0) : min(index, length);
    };
  }
});

// node_modules/core-js/library/modules/_array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js/library/modules/_array-includes.js"(exports2, module2) {
    var toIObject = require_to_iobject();
    var toLength = require_to_length();
    var toAbsoluteIndex = require_to_absolute_index();
    module2.exports = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index) {
            value = O[index++];
            if (value != value)
              return true;
          }
        else
          for (; length > index; index++)
            if (IS_INCLUDES || index in O) {
              if (O[index] === el)
                return IS_INCLUDES || index || 0;
            }
        return !IS_INCLUDES && -1;
      };
    };
  }
});

// node_modules/core-js/library/modules/_shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js/library/modules/_shared-key.js"(exports2, module2) {
    var shared = require_shared()("keys");
    var uid = require_uid();
    module2.exports = function(key) {
      return shared[key] || (shared[key] = uid(key));
    };
  }
});

// node_modules/core-js/library/modules/_object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js/library/modules/_object-keys-internal.js"(exports2, module2) {
    var has = require_has();
    var toIObject = require_to_iobject();
    var arrayIndexOf = require_array_includes()(false);
    var IE_PROTO = require_shared_key()("IE_PROTO");
    module2.exports = function(object, names) {
      var O = toIObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        if (key != IE_PROTO)
          has(O, key) && result.push(key);
      while (names.length > i)
        if (has(O, key = names[i++])) {
          ~arrayIndexOf(result, key) || result.push(key);
        }
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js/library/modules/_enum-bug-keys.js"(exports2, module2) {
    module2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }
});

// node_modules/core-js/library/modules/_object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js/library/modules/_object-keys.js"(exports2, module2) {
    var $keys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module2.exports = Object.keys || /* @__PURE__ */ __name(function keys(O) {
      return $keys(O, enumBugKeys);
    }, "keys");
  }
});

// node_modules/core-js/library/modules/_object-gops.js
var require_object_gops = __commonJS({
  "node_modules/core-js/library/modules/_object-gops.js"(exports2) {
    exports2.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js/library/modules/_object-pie.js
var require_object_pie = __commonJS({
  "node_modules/core-js/library/modules/_object-pie.js"(exports2) {
    exports2.f = {}.propertyIsEnumerable;
  }
});

// node_modules/core-js/library/modules/_enum-keys.js
var require_enum_keys = __commonJS({
  "node_modules/core-js/library/modules/_enum-keys.js"(exports2, module2) {
    var getKeys = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    module2.exports = function(it) {
      var result = getKeys(it);
      var getSymbols = gOPS.f;
      if (getSymbols) {
        var symbols = getSymbols(it);
        var isEnum = pIE.f;
        var i = 0;
        var key;
        while (symbols.length > i)
          if (isEnum.call(it, key = symbols[i++]))
            result.push(key);
      }
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_is-array.js
var require_is_array = __commonJS({
  "node_modules/core-js/library/modules/_is-array.js"(exports2, module2) {
    var cof = require_cof();
    module2.exports = Array.isArray || /* @__PURE__ */ __name(function isArray(arg) {
      return cof(arg) == "Array";
    }, "isArray");
  }
});

// node_modules/core-js/library/modules/_to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js/library/modules/_to-object.js"(exports2, module2) {
    var defined = require_defined();
    module2.exports = function(it) {
      return Object(defined(it));
    };
  }
});

// node_modules/core-js/library/modules/_object-dps.js
var require_object_dps = __commonJS({
  "node_modules/core-js/library/modules/_object-dps.js"(exports2, module2) {
    var dP = require_object_dp();
    var anObject = require_an_object();
    var getKeys = require_object_keys();
    module2.exports = require_descriptors() ? Object.defineProperties : /* @__PURE__ */ __name(function defineProperties(O, Properties) {
      anObject(O);
      var keys = getKeys(Properties);
      var length = keys.length;
      var i = 0;
      var P;
      while (length > i)
        dP.f(O, P = keys[i++], Properties[P]);
      return O;
    }, "defineProperties");
  }
});

// node_modules/core-js/library/modules/_html.js
var require_html = __commonJS({
  "node_modules/core-js/library/modules/_html.js"(exports2, module2) {
    var document2 = require_global().document;
    module2.exports = document2 && document2.documentElement;
  }
});

// node_modules/core-js/library/modules/_object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js/library/modules/_object-create.js"(exports2, module2) {
    var anObject = require_an_object();
    var dPs = require_object_dps();
    var enumBugKeys = require_enum_bug_keys();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var Empty = /* @__PURE__ */ __name(function() {
    }, "Empty");
    var PROTOTYPE = "prototype";
    var createDict = /* @__PURE__ */ __name(function() {
      var iframe = require_dom_create()("iframe");
      var i = enumBugKeys.length;
      var lt = "<";
      var gt = ">";
      var iframeDocument;
      iframe.style.display = "none";
      require_html().appendChild(iframe);
      iframe.src = "javascript:";
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt);
      iframeDocument.close();
      createDict = iframeDocument.F;
      while (i--)
        delete createDict[PROTOTYPE][enumBugKeys[i]];
      return createDict();
    }, "createDict");
    module2.exports = Object.create || /* @__PURE__ */ __name(function create(O, Properties) {
      var result;
      if (O !== null) {
        Empty[PROTOTYPE] = anObject(O);
        result = new Empty();
        Empty[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = createDict();
      return Properties === void 0 ? result : dPs(result, Properties);
    }, "create");
  }
});

// node_modules/core-js/library/modules/_object-gopn.js
var require_object_gopn = __commonJS({
  "node_modules/core-js/library/modules/_object-gopn.js"(exports2) {
    var $keys = require_object_keys_internal();
    var hiddenKeys = require_enum_bug_keys().concat("length", "prototype");
    exports2.f = Object.getOwnPropertyNames || /* @__PURE__ */ __name(function getOwnPropertyNames(O) {
      return $keys(O, hiddenKeys);
    }, "getOwnPropertyNames");
  }
});

// node_modules/core-js/library/modules/_object-gopn-ext.js
var require_object_gopn_ext = __commonJS({
  "node_modules/core-js/library/modules/_object-gopn-ext.js"(exports2, module2) {
    var toIObject = require_to_iobject();
    var gOPN = require_object_gopn().f;
    var toString = {}.toString;
    var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var getWindowNames = /* @__PURE__ */ __name(function(it) {
      try {
        return gOPN(it);
      } catch (e) {
        return windowNames.slice();
      }
    }, "getWindowNames");
    module2.exports.f = /* @__PURE__ */ __name(function getOwnPropertyNames(it) {
      return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
    }, "getOwnPropertyNames");
  }
});

// node_modules/core-js/library/modules/_object-gopd.js
var require_object_gopd = __commonJS({
  "node_modules/core-js/library/modules/_object-gopd.js"(exports2) {
    var pIE = require_object_pie();
    var createDesc = require_property_desc();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive();
    var has = require_has();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var gOPD = Object.getOwnPropertyDescriptor;
    exports2.f = require_descriptors() ? gOPD : /* @__PURE__ */ __name(function getOwnPropertyDescriptor(O, P) {
      O = toIObject(O);
      P = toPrimitive(P, true);
      if (IE8_DOM_DEFINE)
        try {
          return gOPD(O, P);
        } catch (e) {
        }
      if (has(O, P))
        return createDesc(!pIE.f.call(O, P), O[P]);
    }, "getOwnPropertyDescriptor");
  }
});

// node_modules/core-js/library/modules/es6.symbol.js
var require_es6_symbol = __commonJS({
  "node_modules/core-js/library/modules/es6.symbol.js"() {
    "use strict";
    var global2 = require_global();
    var has = require_has();
    var DESCRIPTORS = require_descriptors();
    var $export = require_export();
    var redefine = require_redefine();
    var META = require_meta().KEY;
    var $fails = require_fails();
    var shared = require_shared();
    var setToStringTag = require_set_to_string_tag();
    var uid = require_uid();
    var wks = require_wks();
    var wksExt = require_wks_ext();
    var wksDefine = require_wks_define();
    var enumKeys = require_enum_keys();
    var isArray = require_is_array();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var toObject = require_to_object();
    var toIObject = require_to_iobject();
    var toPrimitive = require_to_primitive();
    var createDesc = require_property_desc();
    var _create = require_object_create();
    var gOPNExt = require_object_gopn_ext();
    var $GOPD = require_object_gopd();
    var $GOPS = require_object_gops();
    var $DP = require_object_dp();
    var $keys = require_object_keys();
    var gOPD = $GOPD.f;
    var dP = $DP.f;
    var gOPN = gOPNExt.f;
    var $Symbol = global2.Symbol;
    var $JSON = global2.JSON;
    var _stringify = $JSON && $JSON.stringify;
    var PROTOTYPE = "prototype";
    var HIDDEN = wks("_hidden");
    var TO_PRIMITIVE = wks("toPrimitive");
    var isEnum = {}.propertyIsEnumerable;
    var SymbolRegistry = shared("symbol-registry");
    var AllSymbols = shared("symbols");
    var OPSymbols = shared("op-symbols");
    var ObjectProto = Object[PROTOTYPE];
    var USE_NATIVE = typeof $Symbol == "function" && !!$GOPS.f;
    var QObject = global2.QObject;
    var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
    var setSymbolDesc = DESCRIPTORS && $fails(function() {
      return _create(dP({}, "a", {
        get: function() {
          return dP(this, "a", { value: 7 }).a;
        }
      })).a != 7;
    }) ? function(it, key, D) {
      var protoDesc = gOPD(ObjectProto, key);
      if (protoDesc)
        delete ObjectProto[key];
      dP(it, key, D);
      if (protoDesc && it !== ObjectProto)
        dP(ObjectProto, key, protoDesc);
    } : dP;
    var wrap = /* @__PURE__ */ __name(function(tag) {
      var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
      sym._k = tag;
      return sym;
    }, "wrap");
    var isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      return it instanceof $Symbol;
    };
    var $defineProperty = /* @__PURE__ */ __name(function defineProperty(it, key, D) {
      if (it === ObjectProto)
        $defineProperty(OPSymbols, key, D);
      anObject(it);
      key = toPrimitive(key, true);
      anObject(D);
      if (has(AllSymbols, key)) {
        if (!D.enumerable) {
          if (!has(it, HIDDEN))
            dP(it, HIDDEN, createDesc(1, {}));
          it[HIDDEN][key] = true;
        } else {
          if (has(it, HIDDEN) && it[HIDDEN][key])
            it[HIDDEN][key] = false;
          D = _create(D, { enumerable: createDesc(0, false) });
        }
        return setSymbolDesc(it, key, D);
      }
      return dP(it, key, D);
    }, "defineProperty");
    var $defineProperties = /* @__PURE__ */ __name(function defineProperties(it, P) {
      anObject(it);
      var keys = enumKeys(P = toIObject(P));
      var i = 0;
      var l = keys.length;
      var key;
      while (l > i)
        $defineProperty(it, key = keys[i++], P[key]);
      return it;
    }, "defineProperties");
    var $create = /* @__PURE__ */ __name(function create(it, P) {
      return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
    }, "create");
    var $propertyIsEnumerable = /* @__PURE__ */ __name(function propertyIsEnumerable(key) {
      var E = isEnum.call(this, key = toPrimitive(key, true));
      if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
        return false;
      return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
    }, "propertyIsEnumerable");
    var $getOwnPropertyDescriptor = /* @__PURE__ */ __name(function getOwnPropertyDescriptor(it, key) {
      it = toIObject(it);
      key = toPrimitive(key, true);
      if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
        return;
      var D = gOPD(it, key);
      if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
        D.enumerable = true;
      return D;
    }, "getOwnPropertyDescriptor");
    var $getOwnPropertyNames = /* @__PURE__ */ __name(function getOwnPropertyNames(it) {
      var names = gOPN(toIObject(it));
      var result = [];
      var i = 0;
      var key;
      while (names.length > i) {
        if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)
          result.push(key);
      }
      return result;
    }, "getOwnPropertyNames");
    var $getOwnPropertySymbols = /* @__PURE__ */ __name(function getOwnPropertySymbols(it) {
      var IS_OP = it === ObjectProto;
      var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
      var result = [];
      var i = 0;
      var key;
      while (names.length > i) {
        if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))
          result.push(AllSymbols[key]);
      }
      return result;
    }, "getOwnPropertySymbols");
    if (!USE_NATIVE) {
      $Symbol = /* @__PURE__ */ __name(function Symbol2() {
        if (this instanceof $Symbol)
          throw TypeError("Symbol is not a constructor!");
        var tag = uid(arguments.length > 0 ? arguments[0] : void 0);
        var $set = /* @__PURE__ */ __name(function(value) {
          if (this === ObjectProto)
            $set.call(OPSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag))
            this[HIDDEN][tag] = false;
          setSymbolDesc(this, tag, createDesc(1, value));
        }, "$set");
        if (DESCRIPTORS && setter)
          setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
        return wrap(tag);
      }, "Symbol");
      redefine($Symbol[PROTOTYPE], "toString", /* @__PURE__ */ __name(function toString() {
        return this._k;
      }, "toString"));
      $GOPD.f = $getOwnPropertyDescriptor;
      $DP.f = $defineProperty;
      require_object_gopn().f = gOPNExt.f = $getOwnPropertyNames;
      require_object_pie().f = $propertyIsEnumerable;
      $GOPS.f = $getOwnPropertySymbols;
      if (DESCRIPTORS && !require_library()) {
        redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
      }
      wksExt.f = function(name) {
        return wrap(wks(name));
      };
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
    for (es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; )
      wks(es6Symbols[j++]);
    var es6Symbols;
    var j;
    for (wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; )
      wksDefine(wellKnownSymbols[k++]);
    var wellKnownSymbols;
    var k;
    $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
      "for": function(key) {
        return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
      },
      keyFor: /* @__PURE__ */ __name(function keyFor(sym) {
        if (!isSymbol(sym))
          throw TypeError(sym + " is not a symbol!");
        for (var key in SymbolRegistry)
          if (SymbolRegistry[key] === sym)
            return key;
      }, "keyFor"),
      useSetter: function() {
        setter = true;
      },
      useSimple: function() {
        setter = false;
      }
    });
    $export($export.S + $export.F * !USE_NATIVE, "Object", {
      create: $create,
      defineProperty: $defineProperty,
      defineProperties: $defineProperties,
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
      getOwnPropertyNames: $getOwnPropertyNames,
      getOwnPropertySymbols: $getOwnPropertySymbols
    });
    var FAILS_ON_PRIMITIVES = $fails(function() {
      $GOPS.f(1);
    });
    $export($export.S + $export.F * FAILS_ON_PRIMITIVES, "Object", {
      getOwnPropertySymbols: /* @__PURE__ */ __name(function getOwnPropertySymbols(it) {
        return $GOPS.f(toObject(it));
      }, "getOwnPropertySymbols")
    });
    $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
      var S = $Symbol();
      return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
    })), "JSON", {
      stringify: /* @__PURE__ */ __name(function stringify(it) {
        var args = [it];
        var i = 1;
        var replacer, $replacer;
        while (arguments.length > i)
          args.push(arguments[i++]);
        $replacer = replacer = args[1];
        if (!isObject(replacer) && it === void 0 || isSymbol(it))
          return;
        if (!isArray(replacer))
          replacer = /* @__PURE__ */ __name(function(key, value) {
            if (typeof $replacer == "function")
              value = $replacer.call(this, key, value);
            if (!isSymbol(value))
              return value;
          }, "replacer");
        args[1] = replacer;
        return _stringify.apply($JSON, args);
      }, "stringify")
    });
    $Symbol[PROTOTYPE][TO_PRIMITIVE] || require_hide()($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
    setToStringTag($Symbol, "Symbol");
    setToStringTag(Math, "Math", true);
    setToStringTag(global2.JSON, "JSON", true);
  }
});

// node_modules/core-js/library/fn/object/get-own-property-symbols.js
var require_get_own_property_symbols = __commonJS({
  "node_modules/core-js/library/fn/object/get-own-property-symbols.js"(exports2, module2) {
    require_es6_symbol();
    module2.exports = require_core4().Object.getOwnPropertySymbols;
  }
});

// node_modules/babel-runtime/core-js/object/get-own-property-symbols.js
var require_get_own_property_symbols2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/get-own-property-symbols.js"(exports2, module2) {
    module2.exports = { "default": require_get_own_property_symbols(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/_add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js/library/modules/_add-to-unscopables.js"(exports2, module2) {
    module2.exports = function() {
    };
  }
});

// node_modules/core-js/library/modules/_iter-step.js
var require_iter_step = __commonJS({
  "node_modules/core-js/library/modules/_iter-step.js"(exports2, module2) {
    module2.exports = function(done, value) {
      return { value, done: !!done };
    };
  }
});

// node_modules/core-js/library/modules/_iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js/library/modules/_iterators.js"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/core-js/library/modules/_iter-create.js
var require_iter_create = __commonJS({
  "node_modules/core-js/library/modules/_iter-create.js"(exports2, module2) {
    "use strict";
    var create = require_object_create();
    var descriptor = require_property_desc();
    var setToStringTag = require_set_to_string_tag();
    var IteratorPrototype = {};
    require_hide()(IteratorPrototype, require_wks()("iterator"), function() {
      return this;
    });
    module2.exports = function(Constructor, NAME, next) {
      Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
      setToStringTag(Constructor, NAME + " Iterator");
    };
  }
});

// node_modules/core-js/library/modules/_object-gpo.js
var require_object_gpo = __commonJS({
  "node_modules/core-js/library/modules/_object-gpo.js"(exports2, module2) {
    var has = require_has();
    var toObject = require_to_object();
    var IE_PROTO = require_shared_key()("IE_PROTO");
    var ObjectProto = Object.prototype;
    module2.exports = Object.getPrototypeOf || function(O) {
      O = toObject(O);
      if (has(O, IE_PROTO))
        return O[IE_PROTO];
      if (typeof O.constructor == "function" && O instanceof O.constructor) {
        return O.constructor.prototype;
      }
      return O instanceof Object ? ObjectProto : null;
    };
  }
});

// node_modules/core-js/library/modules/_iter-define.js
var require_iter_define = __commonJS({
  "node_modules/core-js/library/modules/_iter-define.js"(exports2, module2) {
    "use strict";
    var LIBRARY = require_library();
    var $export = require_export();
    var redefine = require_redefine();
    var hide = require_hide();
    var Iterators = require_iterators();
    var $iterCreate = require_iter_create();
    var setToStringTag = require_set_to_string_tag();
    var getPrototypeOf = require_object_gpo();
    var ITERATOR = require_wks()("iterator");
    var BUGGY = !([].keys && "next" in [].keys());
    var FF_ITERATOR = "@@iterator";
    var KEYS = "keys";
    var VALUES = "values";
    var returnThis = /* @__PURE__ */ __name(function() {
      return this;
    }, "returnThis");
    module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
      $iterCreate(Constructor, NAME, next);
      var getMethod = /* @__PURE__ */ __name(function(kind) {
        if (!BUGGY && kind in proto)
          return proto[kind];
        switch (kind) {
          case KEYS:
            return /* @__PURE__ */ __name(function keys() {
              return new Constructor(this, kind);
            }, "keys");
          case VALUES:
            return /* @__PURE__ */ __name(function values() {
              return new Constructor(this, kind);
            }, "values");
        }
        return /* @__PURE__ */ __name(function entries() {
          return new Constructor(this, kind);
        }, "entries");
      }, "getMethod");
      var TAG2 = NAME + " Iterator";
      var DEF_VALUES = DEFAULT == VALUES;
      var VALUES_BUG = false;
      var proto = Base.prototype;
      var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
      var $default = $native || getMethod(DEFAULT);
      var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
      var $anyNative = NAME == "Array" ? proto.entries || $native : $native;
      var methods, key, IteratorPrototype;
      if ($anyNative) {
        IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
        if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
          setToStringTag(IteratorPrototype, TAG2, true);
          if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
            hide(IteratorPrototype, ITERATOR, returnThis);
        }
      }
      if (DEF_VALUES && $native && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = /* @__PURE__ */ __name(function values() {
          return $native.call(this);
        }, "values");
      }
      if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
        hide(proto, ITERATOR, $default);
      }
      Iterators[NAME] = $default;
      Iterators[TAG2] = returnThis;
      if (DEFAULT) {
        methods = {
          values: DEF_VALUES ? $default : getMethod(VALUES),
          keys: IS_SET ? $default : getMethod(KEYS),
          entries: $entries
        };
        if (FORCED)
          for (key in methods) {
            if (!(key in proto))
              redefine(proto, key, methods[key]);
          }
        else
          $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
      }
      return methods;
    };
  }
});

// node_modules/core-js/library/modules/es6.array.iterator.js
var require_es6_array_iterator = __commonJS({
  "node_modules/core-js/library/modules/es6.array.iterator.js"(exports2, module2) {
    "use strict";
    var addToUnscopables = require_add_to_unscopables();
    var step = require_iter_step();
    var Iterators = require_iterators();
    var toIObject = require_to_iobject();
    module2.exports = require_iter_define()(Array, "Array", function(iterated, kind) {
      this._t = toIObject(iterated);
      this._i = 0;
      this._k = kind;
    }, function() {
      var O = this._t;
      var kind = this._k;
      var index = this._i++;
      if (!O || index >= O.length) {
        this._t = void 0;
        return step(1);
      }
      if (kind == "keys")
        return step(0, index);
      if (kind == "values")
        return step(0, O[index]);
      return step(0, [index, O[index]]);
    }, "values");
    Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
  }
});

// node_modules/core-js/library/modules/web.dom.iterable.js
var require_web_dom_iterable = __commonJS({
  "node_modules/core-js/library/modules/web.dom.iterable.js"() {
    require_es6_array_iterator();
    var global2 = require_global();
    var hide = require_hide();
    var Iterators = require_iterators();
    var TO_STRING_TAG = require_wks()("toStringTag");
    var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
    for (i = 0; i < DOMIterables.length; i++) {
      NAME = DOMIterables[i];
      Collection = global2[NAME];
      proto = Collection && Collection.prototype;
      if (proto && !proto[TO_STRING_TAG])
        hide(proto, TO_STRING_TAG, NAME);
      Iterators[NAME] = Iterators.Array;
    }
    var NAME;
    var Collection;
    var proto;
    var i;
  }
});

// node_modules/core-js/library/modules/_string-at.js
var require_string_at = __commonJS({
  "node_modules/core-js/library/modules/_string-at.js"(exports2, module2) {
    var toInteger = require_to_integer();
    var defined = require_defined();
    module2.exports = function(TO_STRING) {
      return function(that, pos) {
        var s = String(defined(that));
        var i = toInteger(pos);
        var l = s.length;
        var a, b;
        if (i < 0 || i >= l)
          return TO_STRING ? "" : void 0;
        a = s.charCodeAt(i);
        return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
      };
    };
  }
});

// node_modules/core-js/library/modules/es6.string.iterator.js
var require_es6_string_iterator = __commonJS({
  "node_modules/core-js/library/modules/es6.string.iterator.js"() {
    "use strict";
    var $at = require_string_at()(true);
    require_iter_define()(String, "String", function(iterated) {
      this._t = String(iterated);
      this._i = 0;
    }, function() {
      var O = this._t;
      var index = this._i;
      var point;
      if (index >= O.length)
        return { value: void 0, done: true };
      point = $at(O, index);
      this._i += point.length;
      return { value: point, done: false };
    });
  }
});

// node_modules/core-js/library/modules/_classof.js
var require_classof = __commonJS({
  "node_modules/core-js/library/modules/_classof.js"(exports2, module2) {
    var cof = require_cof();
    var TAG2 = require_wks()("toStringTag");
    var ARG = cof(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = /* @__PURE__ */ __name(function(it, key) {
      try {
        return it[key];
      } catch (e) {
      }
    }, "tryGet");
    module2.exports = function(it) {
      var O, T, B;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG2)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
    };
  }
});

// node_modules/core-js/library/modules/core.get-iterator-method.js
var require_core_get_iterator_method = __commonJS({
  "node_modules/core-js/library/modules/core.get-iterator-method.js"(exports2, module2) {
    var classof = require_classof();
    var ITERATOR = require_wks()("iterator");
    var Iterators = require_iterators();
    module2.exports = require_core4().getIteratorMethod = function(it) {
      if (it != void 0)
        return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
    };
  }
});

// node_modules/core-js/library/modules/core.get-iterator.js
var require_core_get_iterator = __commonJS({
  "node_modules/core-js/library/modules/core.get-iterator.js"(exports2, module2) {
    var anObject = require_an_object();
    var get = require_core_get_iterator_method();
    module2.exports = require_core4().getIterator = function(it) {
      var iterFn = get(it);
      if (typeof iterFn != "function")
        throw TypeError(it + " is not iterable!");
      return anObject(iterFn.call(it));
    };
  }
});

// node_modules/core-js/library/fn/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js/library/fn/get-iterator.js"(exports2, module2) {
    require_web_dom_iterable();
    require_es6_string_iterator();
    module2.exports = require_core_get_iterator();
  }
});

// node_modules/babel-runtime/core-js/get-iterator.js
var require_get_iterator2 = __commonJS({
  "node_modules/babel-runtime/core-js/get-iterator.js"(exports2, module2) {
    module2.exports = { "default": require_get_iterator(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/_object-sap.js
var require_object_sap = __commonJS({
  "node_modules/core-js/library/modules/_object-sap.js"(exports2, module2) {
    var $export = require_export();
    var core = require_core4();
    var fails = require_fails();
    module2.exports = function(KEY, exec) {
      var fn = (core.Object || {})[KEY] || Object[KEY];
      var exp = {};
      exp[KEY] = exec(fn);
      $export($export.S + $export.F * fails(function() {
        fn(1);
      }), "Object", exp);
    };
  }
});

// node_modules/core-js/library/modules/es6.object.keys.js
var require_es6_object_keys = __commonJS({
  "node_modules/core-js/library/modules/es6.object.keys.js"() {
    var toObject = require_to_object();
    var $keys = require_object_keys();
    require_object_sap()("keys", function() {
      return /* @__PURE__ */ __name(function keys(it) {
        return $keys(toObject(it));
      }, "keys");
    });
  }
});

// node_modules/core-js/library/fn/object/keys.js
var require_keys = __commonJS({
  "node_modules/core-js/library/fn/object/keys.js"(exports2, module2) {
    require_es6_object_keys();
    module2.exports = require_core4().Object.keys;
  }
});

// node_modules/babel-runtime/core-js/object/keys.js
var require_keys2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/keys.js"(exports2, module2) {
    module2.exports = { "default": require_keys(), __esModule: true };
  }
});

// node_modules/core-js/library/fn/json/stringify.js
var require_stringify = __commonJS({
  "node_modules/core-js/library/fn/json/stringify.js"(exports2, module2) {
    var core = require_core4();
    var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
    module2.exports = /* @__PURE__ */ __name(function stringify(it) {
      return $JSON.stringify.apply($JSON, arguments);
    }, "stringify");
  }
});

// node_modules/babel-runtime/core-js/json/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/babel-runtime/core-js/json/stringify.js"(exports2, module2) {
    module2.exports = { "default": require_stringify(), __esModule: true };
  }
});

// node_modules/core-js/library/fn/symbol/for.js
var require_for = __commonJS({
  "node_modules/core-js/library/fn/symbol/for.js"(exports2, module2) {
    require_es6_symbol();
    module2.exports = require_core4().Symbol["for"];
  }
});

// node_modules/babel-runtime/core-js/symbol/for.js
var require_for2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol/for.js"(exports2, module2) {
    module2.exports = { "default": require_for(), __esModule: true };
  }
});

// node_modules/babel-types/lib/constants.js
var require_constants = __commonJS({
  "node_modules/babel-types/lib/constants.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.NOT_LOCAL_BINDING = exports2.BLOCK_SCOPED_SYMBOL = exports2.INHERIT_KEYS = exports2.UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = exports2.NUMBER_UNARY_OPERATORS = exports2.BOOLEAN_UNARY_OPERATORS = exports2.BINARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = exports2.EQUALITY_BINARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.UPDATE_OPERATORS = exports2.LOGICAL_OPERATORS = exports2.COMMENT_KEYS = exports2.FOR_INIT_KEYS = exports2.FLATTENABLE_KEYS = exports2.STATEMENT_OR_BLOCK_KEYS = void 0;
    var _for = require_for2();
    var _for2 = _interopRequireDefault(_for);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var STATEMENT_OR_BLOCK_KEYS = exports2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    var FLATTENABLE_KEYS = exports2.FLATTENABLE_KEYS = ["body", "expressions"];
    var FOR_INIT_KEYS = exports2.FOR_INIT_KEYS = ["left", "init"];
    var COMMENT_KEYS = exports2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    var LOGICAL_OPERATORS = exports2.LOGICAL_OPERATORS = ["||", "&&"];
    var UPDATE_OPERATORS = exports2.UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    var EQUALITY_BINARY_OPERATORS = exports2.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    var COMPARISON_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
    var BOOLEAN_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
    var NUMBER_BINARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    var BINARY_OPERATORS = exports2.BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);
    var BOOLEAN_UNARY_OPERATORS = exports2.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    var NUMBER_UNARY_OPERATORS = exports2.NUMBER_UNARY_OPERATORS = ["+", "-", "++", "--", "~"];
    var STRING_UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = ["typeof"];
    var UNARY_OPERATORS = exports2.UNARY_OPERATORS = ["void"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
    var INHERIT_KEYS = exports2.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    var BLOCK_SCOPED_SYMBOL = exports2.BLOCK_SCOPED_SYMBOL = (0, _for2.default)("var used to be block scoped");
    var NOT_LOCAL_BINDING = exports2.NOT_LOCAL_BINDING = (0, _for2.default)("should not be considered a local binding");
  }
});

// node_modules/core-js/library/modules/es6.object.create.js
var require_es6_object_create = __commonJS({
  "node_modules/core-js/library/modules/es6.object.create.js"() {
    var $export = require_export();
    $export($export.S, "Object", { create: require_object_create() });
  }
});

// node_modules/core-js/library/fn/object/create.js
var require_create = __commonJS({
  "node_modules/core-js/library/fn/object/create.js"(exports2, module2) {
    require_es6_object_create();
    var $Object = require_core4().Object;
    module2.exports = /* @__PURE__ */ __name(function create(P, D) {
      return $Object.create(P, D);
    }, "create");
  }
});

// node_modules/babel-runtime/core-js/object/create.js
var require_create2 = __commonJS({
  "node_modules/babel-runtime/core-js/object/create.js"(exports2, module2) {
    module2.exports = { "default": require_create(), __esModule: true };
  }
});

// node_modules/babel-types/lib/retrievers.js
var require_retrievers = __commonJS({
  "node_modules/babel-types/lib/retrievers.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _create = require_create2();
    var _create2 = _interopRequireDefault(_create);
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function getBindingIdentifiers(node, duplicates, outerOnly) {
      var search = [].concat(node);
      var ids = (0, _create2.default)(null);
      while (search.length) {
        var id = search.shift();
        if (!id)
          continue;
        var keys = t5.getBindingIdentifiers.keys[id.type];
        if (t5.isIdentifier(id)) {
          if (duplicates) {
            var _ids = ids[id.name] = ids[id.name] || [];
            _ids.push(id);
          } else {
            ids[id.name] = id;
          }
          continue;
        }
        if (t5.isExportDeclaration(id)) {
          if (t5.isDeclaration(id.declaration)) {
            search.push(id.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (t5.isFunctionDeclaration(id)) {
            search.push(id.id);
            continue;
          }
          if (t5.isFunctionExpression(id)) {
            continue;
          }
        }
        if (keys) {
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (id[key]) {
              search = search.concat(id[key]);
            }
          }
        }
      }
      return ids;
    }
    __name(getBindingIdentifiers, "getBindingIdentifiers");
    getBindingIdentifiers.keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      RestProperty: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
    function getOuterBindingIdentifiers(node, duplicates) {
      return getBindingIdentifiers(node, duplicates, true);
    }
    __name(getOuterBindingIdentifiers, "getOuterBindingIdentifiers");
  }
});

// node_modules/core-js/library/fn/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/core-js/library/fn/symbol/iterator.js"(exports2, module2) {
    require_es6_string_iterator();
    require_web_dom_iterable();
    module2.exports = require_wks_ext().f("iterator");
  }
});

// node_modules/babel-runtime/core-js/symbol/iterator.js
var require_iterator2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol/iterator.js"(exports2, module2) {
    module2.exports = { "default": require_iterator(), __esModule: true };
  }
});

// node_modules/core-js/library/modules/es6.object.to-string.js
var require_es6_object_to_string = __commonJS({
  "node_modules/core-js/library/modules/es6.object.to-string.js"() {
  }
});

// node_modules/core-js/library/modules/es7.symbol.async-iterator.js
var require_es7_symbol_async_iterator = __commonJS({
  "node_modules/core-js/library/modules/es7.symbol.async-iterator.js"() {
    require_wks_define()("asyncIterator");
  }
});

// node_modules/core-js/library/modules/es7.symbol.observable.js
var require_es7_symbol_observable = __commonJS({
  "node_modules/core-js/library/modules/es7.symbol.observable.js"() {
    require_wks_define()("observable");
  }
});

// node_modules/core-js/library/fn/symbol/index.js
var require_symbol = __commonJS({
  "node_modules/core-js/library/fn/symbol/index.js"(exports2, module2) {
    require_es6_symbol();
    require_es6_object_to_string();
    require_es7_symbol_async_iterator();
    require_es7_symbol_observable();
    module2.exports = require_core4().Symbol;
  }
});

// node_modules/babel-runtime/core-js/symbol.js
var require_symbol2 = __commonJS({
  "node_modules/babel-runtime/core-js/symbol.js"(exports2, module2) {
    module2.exports = { "default": require_symbol(), __esModule: true };
  }
});

// node_modules/babel-runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/babel-runtime/helpers/typeof.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _iterator = require_iterator2();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _symbol = require_symbol2();
    var _symbol2 = _interopRequireDefault(_symbol);
    var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    exports2.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof(obj);
    } : function(obj) {
      return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
    };
  }
});

// node_modules/esutils/lib/ast.js
var require_ast = __commonJS({
  "node_modules/esutils/lib/ast.js"(exports2, module2) {
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      __name(isExpression, "isExpression");
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      __name(isIterationStatement, "isIterationStatement");
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      __name(isStatement, "isStatement");
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      __name(isSourceElement, "isSourceElement");
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      __name(trailingStatement, "trailingStatement");
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === "IfStatement") {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      __name(isProblematicIfStatement, "isProblematicIfStatement");
      module2.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});

// node_modules/esutils/lib/code.js
var require_code = __commonJS({
  "node_modules/esutils/lib/code.js"(exports2, module2) {
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      __name(isDecimalDigit, "isDecimalDigit");
      function isHexDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57 || 97 <= ch2 && ch2 <= 102 || 65 <= ch2 && ch2 <= 70;
      }
      __name(isHexDigit, "isHexDigit");
      function isOctalDigit(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      __name(isOctalDigit, "isOctalDigit");
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      __name(isWhiteSpace, "isWhiteSpace");
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      __name(isLineTerminator, "isLineTerminator");
      function fromCodePoint2(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      __name(fromCodePoint2, "fromCodePoint");
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint2(ch2));
      }
      __name(isIdentifierStartES5, "isIdentifierStartES5");
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint2(ch2));
      }
      __name(isIdentifierPartES5, "isIdentifierPartES5");
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint2(ch2));
      }
      __name(isIdentifierStartES6, "isIdentifierStartES6");
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint2(ch2));
      }
      __name(isIdentifierPartES6, "isIdentifierPartES6");
      module2.exports = {
        isDecimalDigit,
        isHexDigit,
        isOctalDigit,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});

// node_modules/esutils/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/esutils/lib/keyword.js"(exports2, module2) {
    (function() {
      "use strict";
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      __name(isStrictModeReservedWordES6, "isStrictModeReservedWordES6");
      function isKeywordES5(id, strict) {
        if (!strict && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      __name(isKeywordES5, "isKeywordES5");
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      __name(isKeywordES6, "isKeywordES6");
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      __name(isReservedWordES5, "isReservedWordES5");
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      __name(isReservedWordES6, "isReservedWordES6");
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      __name(isRestrictedWord, "isRestrictedWord");
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      __name(isIdentifierNameES5, "isIdentifierNameES5");
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      __name(decodeUtf16, "decodeUtf16");
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      __name(isIdentifierNameES6, "isIdentifierNameES6");
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      __name(isIdentifierES5, "isIdentifierES5");
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      __name(isIdentifierES6, "isIdentifierES6");
      module2.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});

// node_modules/esutils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/esutils/lib/utils.js"(exports2) {
    (function() {
      "use strict";
      exports2.ast = require_ast();
      exports2.code = require_code();
      exports2.keyword = require_keyword();
    })();
  }
});

// node_modules/babel-types/lib/validators.js
var require_validators = __commonJS({
  "node_modules/babel-types/lib/validators.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _keys = require_keys2();
    var _keys2 = _interopRequireDefault(_keys);
    var _typeof2 = require_typeof();
    var _typeof3 = _interopRequireDefault(_typeof2);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.isBinding = isBinding;
    exports2.isReferenced = isReferenced;
    exports2.isValidIdentifier = isValidIdentifier;
    exports2.isLet = isLet;
    exports2.isBlockScoped = isBlockScoped;
    exports2.isVar = isVar;
    exports2.isSpecifierDefault = isSpecifierDefault;
    exports2.isScope = isScope;
    exports2.isImmutable = isImmutable;
    exports2.isNodesEquivalent = isNodesEquivalent;
    var _retrievers = require_retrievers();
    var _esutils = require_utils();
    var _esutils2 = _interopRequireDefault(_esutils);
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    var _constants = require_constants();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function isBinding(node, parent) {
      var keys = _retrievers.getBindingIdentifiers.keys[parent.type];
      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0)
              return true;
          } else {
            if (val === node)
              return true;
          }
        }
      }
      return false;
    }
    __name(isBinding, "isBinding");
    function isReferenced(node, parent) {
      switch (parent.type) {
        case "BindExpression":
          return parent.object === node || parent.callee === node;
        case "MemberExpression":
        case "JSXMemberExpression":
          if (parent.property === node && parent.computed) {
            return true;
          } else if (parent.object === node) {
            return true;
          } else {
            return false;
          }
        case "MetaProperty":
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return parent.computed;
          }
        case "VariableDeclarator":
          return parent.id !== node;
        case "ArrowFunctionExpression":
        case "FunctionDeclaration":
        case "FunctionExpression":
          for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
            var _ref;
            if (_isArray) {
              if (_i >= _iterator.length)
                break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done)
                break;
              _ref = _i.value;
            }
            var param = _ref;
            if (param === node)
              return false;
          }
          return parent.id !== node;
        case "ExportSpecifier":
          if (parent.source) {
            return false;
          } else {
            return parent.local === node;
          }
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "JSXAttribute":
          return parent.name !== node;
        case "ClassProperty":
          if (parent.key === node) {
            return parent.computed;
          } else {
            return parent.value === node;
          }
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.id !== node;
        case "ClassMethod":
        case "ObjectMethod":
          return parent.key === node && parent.computed;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return parent.param !== node;
        case "RestElement":
          return false;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
      }
      return true;
    }
    __name(isReferenced, "isReferenced");
    function isValidIdentifier(name) {
      if (typeof name !== "string" || _esutils2.default.keyword.isReservedWordES6(name, true)) {
        return false;
      } else if (name === "await") {
        return false;
      } else {
        return _esutils2.default.keyword.isIdentifierNameES6(name);
      }
    }
    __name(isValidIdentifier, "isValidIdentifier");
    function isLet(node) {
      return t5.isVariableDeclaration(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
    }
    __name(isLet, "isLet");
    function isBlockScoped(node) {
      return t5.isFunctionDeclaration(node) || t5.isClassDeclaration(node) || t5.isLet(node);
    }
    __name(isBlockScoped, "isBlockScoped");
    function isVar(node) {
      return t5.isVariableDeclaration(node, { kind: "var" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
    }
    __name(isVar, "isVar");
    function isSpecifierDefault(specifier) {
      return t5.isImportDefaultSpecifier(specifier) || t5.isIdentifier(specifier.imported || specifier.exported, { name: "default" });
    }
    __name(isSpecifierDefault, "isSpecifierDefault");
    function isScope(node, parent) {
      if (t5.isBlockStatement(node) && t5.isFunction(parent, { body: node })) {
        return false;
      }
      return t5.isScopable(node);
    }
    __name(isScope, "isScope");
    function isImmutable(node) {
      if (t5.isType(node.type, "Immutable"))
        return true;
      if (t5.isIdentifier(node)) {
        if (node.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
    __name(isImmutable, "isImmutable");
    function isNodesEquivalent(a, b) {
      if ((typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      var fields = (0, _keys2.default)(t5.NODE_FIELDS[a.type] || a.type);
      for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var field = _ref2;
        if ((0, _typeof3.default)(a[field]) !== (0, _typeof3.default)(b[field])) {
          return false;
        }
        if (Array.isArray(a[field])) {
          if (!Array.isArray(b[field])) {
            return false;
          }
          if (a[field].length !== b[field].length) {
            return false;
          }
          for (var i = 0; i < a[field].length; i++) {
            if (!isNodesEquivalent(a[field][i], b[field][i])) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(a[field], b[field])) {
          return false;
        }
      }
      return true;
    }
    __name(isNodesEquivalent, "isNodesEquivalent");
  }
});

// node_modules/core-js/library/modules/es6.number.max-safe-integer.js
var require_es6_number_max_safe_integer = __commonJS({
  "node_modules/core-js/library/modules/es6.number.max-safe-integer.js"() {
    var $export = require_export();
    $export($export.S, "Number", { MAX_SAFE_INTEGER: 9007199254740991 });
  }
});

// node_modules/core-js/library/fn/number/max-safe-integer.js
var require_max_safe_integer = __commonJS({
  "node_modules/core-js/library/fn/number/max-safe-integer.js"(exports2, module2) {
    require_es6_number_max_safe_integer();
    module2.exports = 9007199254740991;
  }
});

// node_modules/babel-runtime/core-js/number/max-safe-integer.js
var require_max_safe_integer2 = __commonJS({
  "node_modules/babel-runtime/core-js/number/max-safe-integer.js"(exports2, module2) {
    module2.exports = { "default": require_max_safe_integer(), __esModule: true };
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    __name(getRawTag, "getRawTag");
    module2.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    __name(objectToString, "objectToString");
    module2.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    __name(baseGetTag, "baseGetTag");
    module2.exports = baseGetTag;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    module2.exports = overArg;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    module2.exports = isObjectLike;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    module2.exports = isPlainObject;
  }
});

// node_modules/lodash/_baseIsRegExp.js
var require_baseIsRegExp = __commonJS({
  "node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    __name(baseIsRegExp, "baseIsRegExp");
    module2.exports = baseIsRegExp;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    __name(baseUnary, "baseUnary");
    module2.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// node_modules/lodash/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/lodash/isRegExp.js"(exports2, module2) {
    var baseIsRegExp = require_baseIsRegExp();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    module2.exports = isRegExp;
  }
});

// node_modules/babel-types/lib/converters.js
var require_converters = __commonJS({
  "node_modules/babel-types/lib/converters.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _maxSafeInteger = require_max_safe_integer2();
    var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);
    var _stringify = require_stringify2();
    var _stringify2 = _interopRequireDefault(_stringify);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.toComputedKey = toComputedKey;
    exports2.toSequenceExpression = toSequenceExpression;
    exports2.toKeyAlias = toKeyAlias;
    exports2.toIdentifier = toIdentifier;
    exports2.toBindingIdentifierName = toBindingIdentifierName;
    exports2.toStatement = toStatement;
    exports2.toExpression = toExpression;
    exports2.toBlock = toBlock;
    exports2.valueToNode = valueToNode;
    var _isPlainObject = require_isPlainObject();
    var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
    var _isRegExp = require_isRegExp();
    var _isRegExp2 = _interopRequireDefault(_isRegExp);
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function toComputedKey(node) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node.key || node.property;
      if (!node.computed) {
        if (t5.isIdentifier(key))
          key = t5.stringLiteral(key.name);
      }
      return key;
    }
    __name(toComputedKey, "toComputedKey");
    function gatherSequenceExpressions(nodes, scope, declars) {
      var exprs = [];
      var ensureLastUndefined = true;
      for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var node = _ref;
        ensureLastUndefined = false;
        if (t5.isExpression(node)) {
          exprs.push(node);
        } else if (t5.isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (t5.isVariableDeclaration(node)) {
          if (node.kind !== "var")
            return;
          for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var declar = _ref2;
            var bindings = t5.getBindingIdentifiers(declar);
            for (var key in bindings) {
              declars.push({
                kind: node.kind,
                id: bindings[key]
              });
            }
            if (declar.init) {
              exprs.push(t5.assignmentExpression("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if (t5.isIfStatement(node)) {
          var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
          var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate)
            return;
          exprs.push(t5.conditionalExpression(node.test, consequent, alternate));
        } else if (t5.isBlockStatement(node)) {
          var body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body)
            return;
          exprs.push(body);
        } else if (t5.isEmptyStatement(node)) {
          ensureLastUndefined = true;
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push(scope.buildUndefinedNode());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return t5.sequenceExpression(exprs);
      }
    }
    __name(gatherSequenceExpressions, "gatherSequenceExpressions");
    function toSequenceExpression(nodes, scope) {
      if (!nodes || !nodes.length)
        return;
      var declars = [];
      var result = gatherSequenceExpressions(nodes, scope, declars);
      if (!result)
        return;
      for (var _iterator3 = declars, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var declar = _ref3;
        scope.push(declar);
      }
      return result;
    }
    __name(toSequenceExpression, "toSequenceExpression");
    function toKeyAlias(node) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : node.key;
      var alias3 = void 0;
      if (node.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if (t5.isIdentifier(key)) {
        alias3 = key.name;
      } else if (t5.isStringLiteral(key)) {
        alias3 = (0, _stringify2.default)(key.value);
      } else {
        alias3 = (0, _stringify2.default)(t5.removePropertiesDeep(t5.cloneDeep(key)));
      }
      if (node.computed) {
        alias3 = "[" + alias3 + "]";
      }
      if (node.static) {
        alias3 = "static:" + alias3;
      }
      return alias3;
    }
    __name(toKeyAlias, "toKeyAlias");
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= _maxSafeInteger2.default) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
    function toIdentifier(name) {
      name = name + "";
      name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!t5.isValidIdentifier(name)) {
        name = "_" + name;
      }
      return name || "_";
    }
    __name(toIdentifier, "toIdentifier");
    function toBindingIdentifierName(name) {
      name = toIdentifier(name);
      if (name === "eval" || name === "arguments")
        name = "_" + name;
      return name;
    }
    __name(toBindingIdentifierName, "toBindingIdentifierName");
    function toStatement(node, ignore) {
      if (t5.isStatement(node)) {
        return node;
      }
      var mustHaveId = false;
      var newType = void 0;
      if (t5.isClass(node)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if (t5.isFunction(node)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if (t5.isAssignmentExpression(node)) {
        return t5.expressionStatement(node);
      }
      if (mustHaveId && !node.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error("cannot turn " + node.type + " to a statement");
        }
      }
      node.type = newType;
      return node;
    }
    __name(toStatement, "toStatement");
    function toExpression(node) {
      if (t5.isExpressionStatement(node)) {
        node = node.expression;
      }
      if (t5.isExpression(node)) {
        return node;
      }
      if (t5.isClass(node)) {
        node.type = "ClassExpression";
      } else if (t5.isFunction(node)) {
        node.type = "FunctionExpression";
      }
      if (!t5.isExpression(node)) {
        throw new Error("cannot turn " + node.type + " to an expression");
      }
      return node;
    }
    __name(toExpression, "toExpression");
    function toBlock(node, parent) {
      if (t5.isBlockStatement(node)) {
        return node;
      }
      if (t5.isEmptyStatement(node)) {
        node = [];
      }
      if (!Array.isArray(node)) {
        if (!t5.isStatement(node)) {
          if (t5.isFunction(parent)) {
            node = t5.returnStatement(node);
          } else {
            node = t5.expressionStatement(node);
          }
        }
        node = [node];
      }
      return t5.blockStatement(node);
    }
    __name(toBlock, "toBlock");
    function valueToNode(value) {
      if (value === void 0) {
        return t5.identifier("undefined");
      }
      if (value === true || value === false) {
        return t5.booleanLiteral(value);
      }
      if (value === null) {
        return t5.nullLiteral();
      }
      if (typeof value === "string") {
        return t5.stringLiteral(value);
      }
      if (typeof value === "number") {
        return t5.numericLiteral(value);
      }
      if ((0, _isRegExp2.default)(value)) {
        var pattern = value.source;
        var flags = value.toString().match(/\/([a-z]+|)$/)[1];
        return t5.regExpLiteral(pattern, flags);
      }
      if (Array.isArray(value)) {
        return t5.arrayExpression(value.map(t5.valueToNode));
      }
      if ((0, _isPlainObject2.default)(value)) {
        var props = [];
        for (var key in value) {
          var nodeKey = void 0;
          if (t5.isValidIdentifier(key)) {
            nodeKey = t5.identifier(key);
          } else {
            nodeKey = t5.stringLiteral(key);
          }
          props.push(t5.objectProperty(nodeKey, t5.valueToNode(value[key])));
        }
        return t5.objectExpression(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
    __name(valueToNode, "valueToNode");
  }
});

// node_modules/babel-types/lib/flow.js
var require_flow = __commonJS({
  "node_modules/babel-types/lib/flow.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.createUnionTypeAnnotation = createUnionTypeAnnotation;
    exports2.removeTypeDuplicates = removeTypeDuplicates;
    exports2.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function createUnionTypeAnnotation(types) {
      var flattened = removeTypeDuplicates(types);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return t5.unionTypeAnnotation(flattened);
      }
    }
    __name(createUnionTypeAnnotation, "createUnionTypeAnnotation");
    function removeTypeDuplicates(nodes) {
      var generics = {};
      var bases = {};
      var typeGroups = [];
      var types = [];
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node)
          continue;
        if (types.indexOf(node) >= 0) {
          continue;
        }
        if (t5.isAnyTypeAnnotation(node)) {
          return [node];
        }
        if (t5.isFlowBaseAnnotation(node)) {
          bases[node.type] = node;
          continue;
        }
        if (t5.isUnionTypeAnnotation(node)) {
          if (typeGroups.indexOf(node.types) < 0) {
            nodes = nodes.concat(node.types);
            typeGroups.push(node.types);
          }
          continue;
        }
        if (t5.isGenericTypeAnnotation(node)) {
          var name = node.id.name;
          if (generics[name]) {
            var existing = generics[name];
            if (existing.typeParameters) {
              if (node.typeParameters) {
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
              }
            } else {
              existing = node.typeParameters;
            }
          } else {
            generics[name] = node;
          }
          continue;
        }
        types.push(node);
      }
      for (var type3 in bases) {
        types.push(bases[type3]);
      }
      for (var _name in generics) {
        types.push(generics[_name]);
      }
      return types;
    }
    __name(removeTypeDuplicates, "removeTypeDuplicates");
    function createTypeAnnotationBasedOnTypeof(type3) {
      if (type3 === "string") {
        return t5.stringTypeAnnotation();
      } else if (type3 === "number") {
        return t5.numberTypeAnnotation();
      } else if (type3 === "undefined") {
        return t5.voidTypeAnnotation();
      } else if (type3 === "boolean") {
        return t5.booleanTypeAnnotation();
      } else if (type3 === "function") {
        return t5.genericTypeAnnotation(t5.identifier("Function"));
      } else if (type3 === "object") {
        return t5.genericTypeAnnotation(t5.identifier("Object"));
      } else if (type3 === "symbol") {
        return t5.genericTypeAnnotation(t5.identifier("Symbol"));
      } else {
        throw new Error("Invalid typeof value");
      }
    }
    __name(createTypeAnnotationBasedOnTypeof, "createTypeAnnotationBasedOnTypeof");
  }
});

// node_modules/to-fast-properties/index.js
var require_to_fast_properties = __commonJS({
  "node_modules/to-fast-properties/index.js"(exports, module) {
    "use strict";
    module.exports = /* @__PURE__ */ __name(function toFastproperties(o) {
      function Sub() {
      }
      __name(Sub, "Sub");
      Sub.prototype = o;
      var receiver = new Sub();
      function ic() {
        return typeof receiver.foo;
      }
      __name(ic, "ic");
      ic();
      ic();
      return o;
      eval("o" + o);
    }, "toFastproperties");
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    __name(listCacheClear, "listCacheClear");
    module2.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    module2.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    module2.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    module2.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    module2.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    module2.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    module2.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    __name(stackClear, "stackClear");
    module2.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    __name(stackDelete, "stackDelete");
    module2.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    __name(stackGet, "stackGet");
    module2.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    __name(stackHas, "stackHas");
    module2.exports = stackHas;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type3 = typeof value;
      return value != null && (type3 == "object" || type3 == "function");
    }
    __name(isObject, "isObject");
    module2.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    __name(isFunction, "isFunction");
    module2.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    module2.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    module2.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    module2.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    module2.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    module2.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    __name(hashClear, "hashClear");
    module2.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    __name(hashDelete, "hashDelete");
    module2.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    module2.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    __name(hashHas, "hashHas");
    module2.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    module2.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash, "Hash");
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    module2.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type3 = typeof value;
      return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    module2.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    module2.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    __name(mapCacheDelete, "mapCacheDelete");
    module2.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    module2.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    module2.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    module2.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    __name(stackSet, "stackSet");
    module2.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    __name(Stack, "Stack");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    module2.exports = arrayEach;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    __name(baseAssignValue, "baseAssignValue");
    module2.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    __name(assignValue, "assignValue");
    module2.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    __name(copyObject, "copyObject");
    module2.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    module2.exports = baseTimes;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    __name(baseIsArguments, "baseIsArguments");
    module2.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    __name(stubFalse, "stubFalse");
    module2.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type3 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    module2.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    module2.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    __name(baseIsTypedArray, "baseIsTypedArray");
    module2.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    module2.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    module2.exports = isPrototype;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    module2.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    __name(isArrayLike, "isArrayLike");
    module2.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys3 = __commonJS({
  "node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    module2.exports = keys;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys3();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    __name(baseAssign, "baseAssign");
    module2.exports = baseAssign;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    __name(nativeKeysIn, "nativeKeysIn");
    module2.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeysIn, "baseKeysIn");
    module2.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    __name(keysIn, "keysIn");
    module2.exports = keysIn;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    __name(baseAssignIn, "baseAssignIn");
    module2.exports = baseAssignIn;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    __name(cloneBuffer, "cloneBuffer");
    module2.exports = cloneBuffer;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    __name(copyArray, "copyArray");
    module2.exports = copyArray;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    __name(arrayFilter, "arrayFilter");
    module2.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    __name(stubArray, "stubArray");
    module2.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    __name(copySymbols, "copySymbols");
    module2.exports = copySymbols;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    module2.exports = arrayPush;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    __name(copySymbolsIn, "copySymbolsIn");
    module2.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    __name(baseGetAllKeys, "baseGetAllKeys");
    module2.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys3();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    __name(getAllKeys, "getAllKeys");
    module2.exports = getAllKeys;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    __name(getAllKeysIn, "getAllKeysIn");
    module2.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set = getNative(root, "Set");
    module2.exports = Set;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap = getNative(root, "WeakMap");
    module2.exports = WeakMap;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set = require_Set();
    var WeakMap = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    module2.exports = getTag;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    __name(initCloneArray, "initCloneArray");
    module2.exports = initCloneArray;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    __name(cloneArrayBuffer, "cloneArrayBuffer");
    module2.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    __name(cloneDataView, "cloneDataView");
    module2.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    __name(cloneRegExp, "cloneRegExp");
    module2.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    __name(cloneSymbol, "cloneSymbol");
    module2.exports = cloneSymbol;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    __name(cloneTypedArray, "cloneTypedArray");
    module2.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    __name(initCloneByTag, "initCloneByTag");
    module2.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      __name(object, "object");
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    __name(initCloneObject, "initCloneObject");
    module2.exports = initCloneObject;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    __name(baseIsMap, "baseIsMap");
    module2.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    __name(baseIsSet, "baseIsSet");
    module2.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys3();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    __name(baseClone, "baseClone");
    module2.exports = baseClone;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    __name(clone, "clone");
    module2.exports = clone;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    __name(setCacheAdd, "setCacheAdd");
    module2.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    __name(setCacheHas, "setCacheHas");
    module2.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    __name(SetCache, "SetCache");
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    module2.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    module2.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(strictIndexOf, "strictIndexOf");
    module2.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    __name(baseIndexOf, "baseIndexOf");
    module2.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    __name(arrayIncludes, "arrayIncludes");
    module2.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    __name(arrayIncludesWith, "arrayIncludesWith");
    module2.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    __name(cacheHas, "cacheHas");
    module2.exports = cacheHas;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports2, module2) {
    function noop() {
    }
    __name(noop, "noop");
    module2.exports = noop;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    module2.exports = setToArray;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports2, module2) {
    var Set = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set(values);
    };
    module2.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    __name(baseUniq, "baseUniq");
    module2.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports2, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    __name(uniq, "uniq");
    module2.exports = uniq;
  }
});

// node_modules/babel-types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/babel-types/lib/definitions/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.DEPRECATED_KEYS = exports2.BUILDER_KEYS = exports2.NODE_FIELDS = exports2.ALIAS_KEYS = exports2.VISITOR_KEYS = void 0;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _stringify = require_stringify2();
    var _stringify2 = _interopRequireDefault(_stringify);
    var _typeof2 = require_typeof();
    var _typeof3 = _interopRequireDefault(_typeof2);
    exports2.assertEach = assertEach;
    exports2.assertOneOf = assertOneOf;
    exports2.assertNodeType = assertNodeType;
    exports2.assertNodeOrValueType = assertNodeOrValueType;
    exports2.assertValueType = assertValueType;
    exports2.chain = chain;
    exports2.default = defineType;
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var VISITOR_KEYS = exports2.VISITOR_KEYS = {};
    var ALIAS_KEYS = exports2.ALIAS_KEYS = {};
    var NODE_FIELDS = exports2.NODE_FIELDS = {};
    var BUILDER_KEYS = exports2.BUILDER_KEYS = {};
    var DEPRECATED_KEYS = exports2.DEPRECATED_KEYS = {};
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else if (val === void 0) {
        return "undefined";
      } else {
        return typeof val === "undefined" ? "undefined" : (0, _typeof3.default)(val);
      }
    }
    __name(getType, "getType");
    function assertEach(callback) {
      function validator(node, key, val) {
        if (!Array.isArray(val))
          return;
        for (var i = 0; i < val.length; i++) {
          callback(node, key + "[" + i + "]", val[i]);
        }
      }
      __name(validator, "validator");
      validator.each = callback;
      return validator;
    }
    __name(assertEach, "assertEach");
    function assertOneOf() {
      for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {
        vals[_key] = arguments[_key];
      }
      function validate(node, key, val) {
        if (vals.indexOf(val) < 0) {
          throw new TypeError("Property " + key + " expected value to be one of " + (0, _stringify2.default)(vals) + " but got " + (0, _stringify2.default)(val));
        }
      }
      __name(validate, "validate");
      validate.oneOf = vals;
      return validate;
    }
    __name(assertOneOf, "assertOneOf");
    function assertNodeType() {
      for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        types[_key2] = arguments[_key2];
      }
      function validate(node, key, val) {
        var valid = false;
        for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var type3 = _ref;
          if (t5.is(type3, val)) {
            valid = true;
            break;
          }
        }
        if (!valid) {
          throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
        }
      }
      __name(validate, "validate");
      validate.oneOfNodeTypes = types;
      return validate;
    }
    __name(assertNodeType, "assertNodeType");
    function assertNodeOrValueType() {
      for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        types[_key3] = arguments[_key3];
      }
      function validate(node, key, val) {
        var valid = false;
        for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var type3 = _ref2;
          if (getType(val) === type3 || t5.is(type3, val)) {
            valid = true;
            break;
          }
        }
        if (!valid) {
          throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + (0, _stringify2.default)(types) + " " + ("but instead got " + (0, _stringify2.default)(val && val.type)));
        }
      }
      __name(validate, "validate");
      validate.oneOfNodeOrValueTypes = types;
      return validate;
    }
    __name(assertNodeOrValueType, "assertNodeOrValueType");
    function assertValueType(type3) {
      function validate(node, key, val) {
        var valid = getType(val) === type3;
        if (!valid) {
          throw new TypeError("Property " + key + " expected type of " + type3 + " but got " + getType(val));
        }
      }
      __name(validate, "validate");
      validate.type = type3;
      return validate;
    }
    __name(assertValueType, "assertValueType");
    function chain() {
      for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        fns[_key4] = arguments[_key4];
      }
      function validate() {
        for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var fn = _ref3;
          fn.apply(void 0, arguments);
        }
      }
      __name(validate, "validate");
      validate.chainOf = fns;
      return validate;
    }
    __name(chain, "chain");
    function defineType(type3) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var inherits = opts.inherits && store[opts.inherits] || {};
      opts.fields = opts.fields || inherits.fields || {};
      opts.visitor = opts.visitor || inherits.visitor || [];
      opts.aliases = opts.aliases || inherits.aliases || [];
      opts.builder = opts.builder || inherits.builder || opts.visitor || [];
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type3;
      }
      for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4); ; ) {
        var _ref4;
        if (_isArray4) {
          if (_i4 >= _iterator4.length)
            break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done)
            break;
          _ref4 = _i4.value;
        }
        var _key5 = _ref4;
        opts.fields[_key5] = opts.fields[_key5] || {};
      }
      for (var key in opts.fields) {
        var field = opts.fields[key];
        if (opts.builder.indexOf(key) === -1) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate) {
          field.validate = assertValueType(getType(field.default));
        }
      }
      VISITOR_KEYS[type3] = opts.visitor;
      BUILDER_KEYS[type3] = opts.builder;
      NODE_FIELDS[type3] = opts.fields;
      ALIAS_KEYS[type3] = opts.aliases;
      store[type3] = opts;
    }
    __name(defineType, "defineType");
    var store = {};
  }
});

// node_modules/babel-types/lib/definitions/core.js
var require_core5 = __commonJS({
  "node_modules/babel-types/lib/definitions/core.js"() {
    "use strict";
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    var _constants = require_constants();
    var _index2 = require_definitions();
    var _index3 = _interopRequireDefault(_index2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    (0, _index3.default)("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    (0, _index3.default)("AssignmentExpression", {
      fields: {
        operator: {
          validate: (0, _index2.assertValueType)("string")
        },
        left: {
          validate: (0, _index2.assertNodeType)("LVal")
        },
        right: {
          validate: (0, _index2.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    (0, _index3.default)("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: _index2.assertOneOf.apply(void 0, _constants.BINARY_OPERATORS)
        },
        left: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _index2.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    (0, _index3.default)("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _index2.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    (0, _index3.default)("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _index2.assertValueType)("string")
        }
      }
    });
    (0, _index3.default)("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    (0, _index3.default)("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _index2.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    (0, _index3.default)("CallExpression", {
      visitor: ["callee", "arguments"],
      fields: {
        callee: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement")))
        }
      },
      aliases: ["Expression"]
    });
    (0, _index3.default)("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _index2.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable"]
    });
    (0, _index3.default)("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _index2.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    (0, _index3.default)("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _index2.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    (0, _index3.default)("DebuggerStatement", {
      aliases: ["Statement"]
    });
    (0, _index3.default)("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _index2.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    (0, _index3.default)("EmptyStatement", {
      aliases: ["Statement"]
    });
    (0, _index3.default)("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _index2.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    (0, _index3.default)("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _index2.assertNodeType)("Program")
        }
      }
    });
    (0, _index3.default)("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: (0, _index2.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _index2.assertNodeType)("Statement")
        }
      }
    });
    (0, _index3.default)("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _index2.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _index2.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _index2.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _index2.assertNodeType)("Statement")
        }
      }
    });
    (0, _index3.default)("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: {
        id: {
          validate: (0, _index2.assertNodeType)("Identifier")
        },
        params: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal")))
        },
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement")
        },
        generator: {
          default: false,
          validate: (0, _index2.assertValueType)("boolean")
        },
        async: {
          default: false,
          validate: (0, _index2.assertValueType)("boolean")
        }
      },
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"]
    });
    (0, _index3.default)("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: {
        id: {
          validate: (0, _index2.assertNodeType)("Identifier"),
          optional: true
        },
        params: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("LVal")))
        },
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement")
        },
        generator: {
          default: false,
          validate: (0, _index2.assertValueType)("boolean")
        },
        async: {
          default: false,
          validate: (0, _index2.assertValueType)("boolean")
        }
      }
    });
    (0, _index3.default)("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation"],
      aliases: ["Expression", "LVal"],
      fields: {
        name: {
          validate: /* @__PURE__ */ __name(function validate(node, key, val) {
            if (!t5.isValidIdentifier(val)) {
            }
          }, "validate")
        },
        decorators: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index3.default)("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _index2.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _index2.assertNodeType)("Statement")
        }
      }
    });
    (0, _index3.default)("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _index2.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _index2.assertNodeType)("Statement")
        }
      }
    });
    (0, _index3.default)("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _index2.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _index3.default)("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _index2.assertValueType)("number")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _index3.default)("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _index3.default)("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _index2.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    (0, _index3.default)("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Literal"],
      fields: {
        pattern: {
          validate: (0, _index2.assertValueType)("string")
        },
        flags: {
          validate: (0, _index2.assertValueType)("string"),
          default: ""
        }
      }
    });
    (0, _index3.default)("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: _index2.assertOneOf.apply(void 0, _constants.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _index2.assertNodeType)("Expression")
        }
      }
    });
    (0, _index3.default)("MemberExpression", {
      builder: ["object", "property", "computed"],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: {
        object: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        property: {
          validate: /* @__PURE__ */ __name(function validate(node, key, val) {
            var expectedType = node.computed ? "Expression" : "Identifier";
            (0, _index2.assertNodeType)(expectedType)(node, key, val);
          }, "validate")
        },
        computed: {
          default: false
        }
      }
    });
    (0, _index3.default)("NewExpression", {
      visitor: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: {
        callee: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        arguments: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression", "SpreadElement")))
        }
      }
    });
    (0, _index3.default)("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives"],
      fields: {
        directives: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Directive"))),
          default: []
        },
        body: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
        }
      },
      aliases: ["Scopable", "BlockParent", "Block", "FunctionParent"]
    });
    (0, _index3.default)("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadProperty")))
        }
      }
    });
    (0, _index3.default)("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed"],
      fields: {
        kind: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("method", "get", "set")),
          default: "method"
        },
        computed: {
          validate: (0, _index2.assertValueType)("boolean"),
          default: false
        },
        key: {
          validate: /* @__PURE__ */ __name(function validate(node, key, val) {
            var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
            _index2.assertNodeType.apply(void 0, expectedTypes)(node, key, val);
          }, "validate")
        },
        decorators: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
        },
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement")
        },
        generator: {
          default: false,
          validate: (0, _index2.assertValueType)("boolean")
        },
        async: {
          default: false,
          validate: (0, _index2.assertValueType)("boolean")
        }
      },
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    (0, _index3.default)("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", "decorators"],
      fields: {
        computed: {
          validate: (0, _index2.assertValueType)("boolean"),
          default: false
        },
        key: {
          validate: /* @__PURE__ */ __name(function validate(node, key, val) {
            var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
            _index2.assertNodeType.apply(void 0, expectedTypes)(node, key, val);
          }, "validate")
        },
        value: {
          validate: (0, _index2.assertNodeType)("Expression", "Pattern", "RestElement")
        },
        shorthand: {
          validate: (0, _index2.assertValueType)("boolean"),
          default: false
        },
        decorators: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator"))),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"]
    });
    (0, _index3.default)("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      aliases: ["LVal"],
      fields: {
        argument: {
          validate: (0, _index2.assertNodeType)("LVal")
        },
        decorators: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index3.default)("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _index2.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    (0, _index3.default)("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Expression")))
        }
      },
      aliases: ["Expression"]
    });
    (0, _index3.default)("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _index2.assertNodeType)("Expression"),
          optional: true
        },
        consequent: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("Statement")))
        }
      }
    });
    (0, _index3.default)("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        cases: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("SwitchCase")))
        }
      }
    });
    (0, _index3.default)("ThisExpression", {
      aliases: ["Expression"]
    });
    (0, _index3.default)("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _index2.assertNodeType)("Expression")
        }
      }
    });
    (0, _index3.default)("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement")
        },
        handler: {
          optional: true,
          handler: (0, _index2.assertNodeType)("BlockStatement")
        },
        finalizer: {
          optional: true,
          validate: (0, _index2.assertNodeType)("BlockStatement")
        }
      }
    });
    (0, _index3.default)("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        operator: {
          validate: _index2.assertOneOf.apply(void 0, _constants.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    (0, _index3.default)("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        operator: {
          validate: _index2.assertOneOf.apply(void 0, _constants.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    (0, _index3.default)("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        kind: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("string"), (0, _index2.assertOneOf)("var", "let", "const"))
        },
        declarations: {
          validate: (0, _index2.chain)((0, _index2.assertValueType)("array"), (0, _index2.assertEach)((0, _index2.assertNodeType)("VariableDeclarator")))
        }
      }
    });
    (0, _index3.default)("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: (0, _index2.assertNodeType)("LVal")
        },
        init: {
          optional: true,
          validate: (0, _index2.assertNodeType)("Expression")
        }
      }
    });
    (0, _index3.default)("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _index2.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement", "Statement")
        }
      }
    });
    (0, _index3.default)("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          object: (0, _index2.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _index2.assertNodeType)("BlockStatement", "Statement")
        }
      }
    });
  }
});

// node_modules/babel-types/lib/definitions/es2015.js
var require_es2015 = __commonJS({
  "node_modules/babel-types/lib/definitions/es2015.js"() {
    "use strict";
    var _index = require_definitions();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    (0, _index2.default)("AssignmentPattern", {
      visitor: ["left", "right"],
      aliases: ["Pattern", "LVal"],
      fields: {
        left: {
          validate: (0, _index.assertNodeType)("Identifier")
        },
        right: {
          validate: (0, _index.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index2.default)("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      aliases: ["Pattern", "LVal"],
      fields: {
        elements: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Identifier", "Pattern", "RestElement")))
        },
        decorators: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index2.default)("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: {
        params: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal")))
        },
        body: {
          validate: (0, _index.assertNodeType)("BlockStatement", "Expression")
        },
        async: {
          validate: (0, _index.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _index2.default)("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ClassMethod", "ClassProperty")))
        }
      }
    });
    (0, _index2.default)("ClassDeclaration", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
      aliases: ["Scopable", "Class", "Statement", "Declaration", "Pureish"],
      fields: {
        id: {
          validate: (0, _index.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _index.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _index.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index2.default)("ClassExpression", {
      inherits: "ClassDeclaration",
      aliases: ["Scopable", "Class", "Expression", "Pureish"],
      fields: {
        id: {
          optional: true,
          validate: (0, _index.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _index.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _index.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index2.default)("ExportAllDeclaration", {
      visitor: ["source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        source: {
          validate: (0, _index.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _index2.default)("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _index.assertNodeType)("FunctionDeclaration", "ClassDeclaration", "Expression")
        }
      }
    });
    (0, _index2.default)("ExportNamedDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
      fields: {
        declaration: {
          validate: (0, _index.assertNodeType)("Declaration"),
          optional: true
        },
        specifiers: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ExportSpecifier")))
        },
        source: {
          validate: (0, _index.assertNodeType)("StringLiteral"),
          optional: true
        }
      }
    });
    (0, _index2.default)("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _index.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _index.assertNodeType)("Identifier")
        }
      }
    });
    (0, _index2.default)("ForOfStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
          validate: (0, _index.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _index.assertNodeType)("Statement")
        }
      }
    });
    (0, _index2.default)("ImportDeclaration", {
      visitor: ["specifiers", "source"],
      aliases: ["Statement", "Declaration", "ModuleDeclaration"],
      fields: {
        specifiers: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
        },
        source: {
          validate: (0, _index.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _index2.default)("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _index.assertNodeType)("Identifier")
        }
      }
    });
    (0, _index2.default)("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _index.assertNodeType)("Identifier")
        }
      }
    });
    (0, _index2.default)("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _index.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _index.assertNodeType)("Identifier")
        },
        importKind: {
          validate: (0, _index.assertOneOf)(null, "type", "typeof")
        }
      }
    });
    (0, _index2.default)("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, _index.assertValueType)("string")
        },
        property: {
          validate: (0, _index.assertValueType)("string")
        }
      }
    });
    (0, _index2.default)("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static"],
      visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
      fields: {
        kind: {
          validate: (0, _index.chain)((0, _index.assertValueType)("string"), (0, _index.assertOneOf)("get", "set", "method", "constructor")),
          default: "method"
        },
        computed: {
          default: false,
          validate: (0, _index.assertValueType)("boolean")
        },
        static: {
          default: false,
          validate: (0, _index.assertValueType)("boolean")
        },
        key: {
          validate: /* @__PURE__ */ __name(function validate(node, key, val) {
            var expectedTypes = node.computed ? ["Expression"] : ["Identifier", "StringLiteral", "NumericLiteral"];
            _index.assertNodeType.apply(void 0, expectedTypes)(node, key, val);
          }, "validate")
        },
        params: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("LVal")))
        },
        body: {
          validate: (0, _index.assertNodeType)("BlockStatement")
        },
        generator: {
          default: false,
          validate: (0, _index.assertValueType)("boolean")
        },
        async: {
          default: false,
          validate: (0, _index.assertValueType)("boolean")
        }
      }
    });
    (0, _index2.default)("ObjectPattern", {
      visitor: ["properties", "typeAnnotation"],
      aliases: ["Pattern", "LVal"],
      fields: {
        properties: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("RestProperty", "Property")))
        },
        decorators: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Decorator")))
        }
      }
    });
    (0, _index2.default)("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      fields: {
        argument: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
    (0, _index2.default)("Super", {
      aliases: ["Expression"]
    });
    (0, _index2.default)("TaggedTemplateExpression", {
      visitor: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _index.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _index.assertNodeType)("TemplateLiteral")
        }
      }
    });
    (0, _index2.default)("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {},
        tail: {
          validate: (0, _index.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _index2.default)("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("TemplateElement")))
        },
        expressions: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("Expression")))
        }
      }
    });
    (0, _index2.default)("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, _index.assertValueType)("boolean"),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
  }
});

// node_modules/babel-types/lib/definitions/flow.js
var require_flow2 = __commonJS({
  "node_modules/babel-types/lib/definitions/flow.js"() {
    "use strict";
    var _index = require_definitions();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    (0, _index2.default)("AnyTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
    (0, _index2.default)("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("BooleanTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
    (0, _index2.default)("BooleanLiteralTypeAnnotation", {
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("NullLiteralTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
    (0, _index2.default)("ClassImplements", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed"],
      aliases: ["Property"],
      fields: {
        computed: {
          validate: (0, _index.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _index2.default)("DeclareClass", {
      visitor: ["id", "typeParameters", "extends", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareFunction", {
      visitor: ["id"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareInterface", {
      visitor: ["id", "typeParameters", "extends", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareModule", {
      visitor: ["id", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareVariable", {
      visitor: ["id"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("ExistentialTypeParam", {
      aliases: ["Flow"]
    });
    (0, _index2.default)("FunctionTypeAnnotation", {
      visitor: ["typeParameters", "params", "rest", "returnType"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("InterfaceDeclaration", {
      visitor: ["id", "typeParameters", "extends", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("MixedTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"]
    });
    (0, _index2.default)("EmptyTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"]
    });
    (0, _index2.default)("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("NumericLiteralTypeAnnotation", {
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("NumberTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
    (0, _index2.default)("StringLiteralTypeAnnotation", {
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("StringTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
    (0, _index2.default)("ThisTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
    (0, _index2.default)("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("OpaqueType", {
      visitor: ["id", "typeParameters", "impltype", "supertype"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {}
    });
    (0, _index2.default)("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["Flow", "ExpressionWrapper", "Expression"],
      fields: {}
    });
    (0, _index2.default)("TypeParameter", {
      visitor: ["bound"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("TypeParameterDeclaration", {
      visitor: ["params"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("TypeParameterInstantiation", {
      visitor: ["params"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {}
    });
    (0, _index2.default)("ObjectTypeIndexer", {
      visitor: ["id", "key", "value"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {}
    });
    (0, _index2.default)("ObjectTypeProperty", {
      visitor: ["key", "value"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {}
    });
    (0, _index2.default)("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["Flow", "UserWhitespacable"],
      fields: {}
    });
    (0, _index2.default)("QualifiedTypeIdentifier", {
      visitor: ["id", "qualification"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["Flow"],
      fields: {}
    });
    (0, _index2.default)("VoidTypeAnnotation", {
      aliases: ["Flow", "FlowBaseAnnotation"],
      fields: {}
    });
  }
});

// node_modules/babel-types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/babel-types/lib/definitions/jsx.js"() {
    "use strict";
    var _index = require_definitions();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    (0, _index2.default)("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _index.assertNodeType)("JSXElement", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    (0, _index2.default)("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
        }
      }
    });
    (0, _index2.default)("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["JSX", "Immutable", "Expression"],
      fields: {
        openingElement: {
          validate: (0, _index.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _index.assertNodeType)("JSXClosingElement")
        },
        children: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement")))
        }
      }
    });
    (0, _index2.default)("JSXEmptyExpression", {
      aliases: ["JSX", "Expression"]
    });
    (0, _index2.default)("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["JSX", "Immutable"],
      fields: {
        expression: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
    (0, _index2.default)("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["JSX", "Immutable"],
      fields: {
        expression: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
    (0, _index2.default)("JSXIdentifier", {
      builder: ["name"],
      aliases: ["JSX", "Expression"],
      fields: {
        name: {
          validate: (0, _index.assertValueType)("string")
        }
      }
    });
    (0, _index2.default)("JSXMemberExpression", {
      visitor: ["object", "property"],
      aliases: ["JSX", "Expression"],
      fields: {
        object: {
          validate: (0, _index.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _index.assertNodeType)("JSXIdentifier")
        }
      }
    });
    (0, _index2.default)("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      aliases: ["JSX"],
      fields: {
        namespace: {
          validate: (0, _index.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _index.assertNodeType)("JSXIdentifier")
        }
      }
    });
    (0, _index2.default)("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "attributes"],
      aliases: ["JSX", "Immutable"],
      fields: {
        name: {
          validate: (0, _index.assertNodeType)("JSXIdentifier", "JSXMemberExpression")
        },
        selfClosing: {
          default: false,
          validate: (0, _index.assertValueType)("boolean")
        },
        attributes: {
          validate: (0, _index.chain)((0, _index.assertValueType)("array"), (0, _index.assertEach)((0, _index.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
        }
      }
    });
    (0, _index2.default)("JSXSpreadAttribute", {
      visitor: ["argument"],
      aliases: ["JSX"],
      fields: {
        argument: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
    (0, _index2.default)("JSXText", {
      aliases: ["JSX", "Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _index.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/babel-types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/babel-types/lib/definitions/misc.js"() {
    "use strict";
    var _index = require_definitions();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    (0, _index2.default)("Noop", {
      visitor: []
    });
    (0, _index2.default)("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
  }
});

// node_modules/babel-types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/babel-types/lib/definitions/experimental.js"() {
    "use strict";
    var _index = require_definitions();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    (0, _index2.default)("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
    (0, _index2.default)("ForAwaitStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: (0, _index.assertNodeType)("VariableDeclaration", "LVal")
        },
        right: {
          validate: (0, _index.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _index.assertNodeType)("Statement")
        }
      }
    });
    (0, _index2.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: {}
    });
    (0, _index2.default)("Import", {
      aliases: ["Expression"]
    });
    (0, _index2.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
    (0, _index2.default)("DoExpression", {
      visitor: ["body"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _index.assertNodeType)("BlockStatement")
        }
      }
    });
    (0, _index2.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _index.assertNodeType)("Identifier")
        }
      }
    });
    (0, _index2.default)("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _index.assertNodeType)("Identifier")
        }
      }
    });
    (0, _index2.default)("RestProperty", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      fields: {
        argument: {
          validate: (0, _index.assertNodeType)("LVal")
        }
      }
    });
    (0, _index2.default)("SpreadProperty", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      fields: {
        argument: {
          validate: (0, _index.assertNodeType)("Expression")
        }
      }
    });
  }
});

// node_modules/babel-types/lib/definitions/init.js
var require_init = __commonJS({
  "node_modules/babel-types/lib/definitions/init.js"() {
    "use strict";
    require_definitions();
    require_core5();
    require_es2015();
    require_flow2();
    require_jsx();
    require_misc();
    require_experimental();
  }
});

// node_modules/babel-types/lib/react.js
var require_react = __commonJS({
  "node_modules/babel-types/lib/react.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.isReactComponent = void 0;
    exports2.isCompatTag = isCompatTag;
    exports2.buildChildren = buildChildren;
    var _index = require_lib();
    var t5 = _interopRequireWildcard(_index);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    var isReactComponent = exports2.isReactComponent = t5.buildMatchMemberExpression("React.Component");
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]|\-/.test(tagName);
    }
    __name(isCompatTag, "isCompatTag");
    function cleanJSXElementLiteralChild(child, args) {
      var lines = child.value.split(/\r\n|\n|\r/);
      var lastNonEmptyLine = 0;
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].match(/[^ \t]/)) {
          lastNonEmptyLine = i;
        }
      }
      var str = "";
      for (var _i = 0; _i < lines.length; _i++) {
        var line2 = lines[_i];
        var isFirstLine = _i === 0;
        var isLastLine = _i === lines.length - 1;
        var isLastNonEmptyLine = _i === lastNonEmptyLine;
        var trimmedLine = line2.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^[ ]+/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/[ ]+$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str += trimmedLine;
        }
      }
      if (str)
        args.push(t5.stringLiteral(str));
    }
    __name(cleanJSXElementLiteralChild, "cleanJSXElementLiteralChild");
    function buildChildren(node) {
      var elems = [];
      for (var i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        if (t5.isJSXText(child)) {
          cleanJSXElementLiteralChild(child, elems);
          continue;
        }
        if (t5.isJSXExpressionContainer(child))
          child = child.expression;
        if (t5.isJSXEmptyExpression(child))
          continue;
        elems.push(child);
      }
      return elems;
    }
    __name(buildChildren, "buildChildren");
  }
});

// node_modules/babel-types/lib/index.js
var require_lib = __commonJS({
  "node_modules/babel-types/lib/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.createTypeAnnotationBasedOnTypeof = exports2.removeTypeDuplicates = exports2.createUnionTypeAnnotation = exports2.valueToNode = exports2.toBlock = exports2.toExpression = exports2.toStatement = exports2.toBindingIdentifierName = exports2.toIdentifier = exports2.toKeyAlias = exports2.toSequenceExpression = exports2.toComputedKey = exports2.isNodesEquivalent = exports2.isImmutable = exports2.isScope = exports2.isSpecifierDefault = exports2.isVar = exports2.isBlockScoped = exports2.isLet = exports2.isValidIdentifier = exports2.isReferenced = exports2.isBinding = exports2.getOuterBindingIdentifiers = exports2.getBindingIdentifiers = exports2.TYPES = exports2.react = exports2.DEPRECATED_KEYS = exports2.BUILDER_KEYS = exports2.NODE_FIELDS = exports2.ALIAS_KEYS = exports2.VISITOR_KEYS = exports2.NOT_LOCAL_BINDING = exports2.BLOCK_SCOPED_SYMBOL = exports2.INHERIT_KEYS = exports2.UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = exports2.NUMBER_UNARY_OPERATORS = exports2.BOOLEAN_UNARY_OPERATORS = exports2.BINARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = exports2.EQUALITY_BINARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.UPDATE_OPERATORS = exports2.LOGICAL_OPERATORS = exports2.COMMENT_KEYS = exports2.FOR_INIT_KEYS = exports2.FLATTENABLE_KEYS = exports2.STATEMENT_OR_BLOCK_KEYS = void 0;
    var _getOwnPropertySymbols = require_get_own_property_symbols2();
    var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _keys = require_keys2();
    var _keys2 = _interopRequireDefault(_keys);
    var _stringify = require_stringify2();
    var _stringify2 = _interopRequireDefault(_stringify);
    var _constants = require_constants();
    Object.defineProperty(exports2, "STATEMENT_OR_BLOCK_KEYS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.STATEMENT_OR_BLOCK_KEYS;
      }, "get")
    });
    Object.defineProperty(exports2, "FLATTENABLE_KEYS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.FLATTENABLE_KEYS;
      }, "get")
    });
    Object.defineProperty(exports2, "FOR_INIT_KEYS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.FOR_INIT_KEYS;
      }, "get")
    });
    Object.defineProperty(exports2, "COMMENT_KEYS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.COMMENT_KEYS;
      }, "get")
    });
    Object.defineProperty(exports2, "LOGICAL_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.LOGICAL_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "UPDATE_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.UPDATE_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "BOOLEAN_NUMBER_BINARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "EQUALITY_BINARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.EQUALITY_BINARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "COMPARISON_BINARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.COMPARISON_BINARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "BOOLEAN_BINARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.BOOLEAN_BINARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "NUMBER_BINARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.NUMBER_BINARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "BINARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.BINARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "BOOLEAN_UNARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.BOOLEAN_UNARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "NUMBER_UNARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.NUMBER_UNARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "STRING_UNARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.STRING_UNARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "UNARY_OPERATORS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.UNARY_OPERATORS;
      }, "get")
    });
    Object.defineProperty(exports2, "INHERIT_KEYS", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.INHERIT_KEYS;
      }, "get")
    });
    Object.defineProperty(exports2, "BLOCK_SCOPED_SYMBOL", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.BLOCK_SCOPED_SYMBOL;
      }, "get")
    });
    Object.defineProperty(exports2, "NOT_LOCAL_BINDING", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _constants.NOT_LOCAL_BINDING;
      }, "get")
    });
    exports2.is = is2;
    exports2.isType = isType;
    exports2.validate = validate;
    exports2.shallowEqual = shallowEqual;
    exports2.appendToMemberExpression = appendToMemberExpression;
    exports2.prependToMemberExpression = prependToMemberExpression;
    exports2.ensureBlock = ensureBlock;
    exports2.clone = clone;
    exports2.cloneWithoutLoc = cloneWithoutLoc;
    exports2.cloneDeep = cloneDeep;
    exports2.buildMatchMemberExpression = buildMatchMemberExpression;
    exports2.removeComments = removeComments;
    exports2.inheritsComments = inheritsComments;
    exports2.inheritTrailingComments = inheritTrailingComments;
    exports2.inheritLeadingComments = inheritLeadingComments;
    exports2.inheritInnerComments = inheritInnerComments;
    exports2.inherits = inherits;
    exports2.assertNode = assertNode;
    exports2.isNode = isNode;
    exports2.traverseFast = traverseFast;
    exports2.removeProperties = removeProperties;
    exports2.removePropertiesDeep = removePropertiesDeep;
    var _retrievers = require_retrievers();
    Object.defineProperty(exports2, "getBindingIdentifiers", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _retrievers.getBindingIdentifiers;
      }, "get")
    });
    Object.defineProperty(exports2, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _retrievers.getOuterBindingIdentifiers;
      }, "get")
    });
    var _validators = require_validators();
    Object.defineProperty(exports2, "isBinding", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isBinding;
      }, "get")
    });
    Object.defineProperty(exports2, "isReferenced", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isReferenced;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidIdentifier", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isValidIdentifier;
      }, "get")
    });
    Object.defineProperty(exports2, "isLet", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isLet;
      }, "get")
    });
    Object.defineProperty(exports2, "isBlockScoped", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isBlockScoped;
      }, "get")
    });
    Object.defineProperty(exports2, "isVar", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isVar;
      }, "get")
    });
    Object.defineProperty(exports2, "isSpecifierDefault", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isSpecifierDefault;
      }, "get")
    });
    Object.defineProperty(exports2, "isScope", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isScope;
      }, "get")
    });
    Object.defineProperty(exports2, "isImmutable", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isImmutable;
      }, "get")
    });
    Object.defineProperty(exports2, "isNodesEquivalent", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _validators.isNodesEquivalent;
      }, "get")
    });
    var _converters = require_converters();
    Object.defineProperty(exports2, "toComputedKey", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toComputedKey;
      }, "get")
    });
    Object.defineProperty(exports2, "toSequenceExpression", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toSequenceExpression;
      }, "get")
    });
    Object.defineProperty(exports2, "toKeyAlias", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toKeyAlias;
      }, "get")
    });
    Object.defineProperty(exports2, "toIdentifier", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toIdentifier;
      }, "get")
    });
    Object.defineProperty(exports2, "toBindingIdentifierName", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toBindingIdentifierName;
      }, "get")
    });
    Object.defineProperty(exports2, "toStatement", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toStatement;
      }, "get")
    });
    Object.defineProperty(exports2, "toExpression", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toExpression;
      }, "get")
    });
    Object.defineProperty(exports2, "toBlock", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.toBlock;
      }, "get")
    });
    Object.defineProperty(exports2, "valueToNode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _converters.valueToNode;
      }, "get")
    });
    var _flow = require_flow();
    Object.defineProperty(exports2, "createUnionTypeAnnotation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _flow.createUnionTypeAnnotation;
      }, "get")
    });
    Object.defineProperty(exports2, "removeTypeDuplicates", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _flow.removeTypeDuplicates;
      }, "get")
    });
    Object.defineProperty(exports2, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _flow.createTypeAnnotationBasedOnTypeof;
      }, "get")
    });
    var _toFastProperties = require_to_fast_properties();
    var _toFastProperties2 = _interopRequireDefault(_toFastProperties);
    var _clone = require_clone();
    var _clone2 = _interopRequireDefault(_clone);
    var _uniq = require_uniq();
    var _uniq2 = _interopRequireDefault(_uniq);
    require_init();
    var _definitions = require_definitions();
    var _react2 = require_react();
    var _react = _interopRequireWildcard(_react2);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var t5 = exports2;
    function registerType(type4) {
      var is3 = t5["is" + type4];
      if (!is3) {
        is3 = t5["is" + type4] = function(node, opts) {
          return t5.is(type4, node, opts);
        };
      }
      t5["assert" + type4] = function(node, opts) {
        opts = opts || {};
        if (!is3(node, opts)) {
          throw new Error("Expected type " + (0, _stringify2.default)(type4) + " with option " + (0, _stringify2.default)(opts));
        }
      };
    }
    __name(registerType, "registerType");
    exports2.VISITOR_KEYS = _definitions.VISITOR_KEYS;
    exports2.ALIAS_KEYS = _definitions.ALIAS_KEYS;
    exports2.NODE_FIELDS = _definitions.NODE_FIELDS;
    exports2.BUILDER_KEYS = _definitions.BUILDER_KEYS;
    exports2.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS;
    exports2.react = _react;
    for (type3 in t5.VISITOR_KEYS) {
      registerType(type3);
    }
    var type3;
    t5.FLIPPED_ALIAS_KEYS = {};
    (0, _keys2.default)(t5.ALIAS_KEYS).forEach(function(type4) {
      t5.ALIAS_KEYS[type4].forEach(function(alias3) {
        var types = t5.FLIPPED_ALIAS_KEYS[alias3] = t5.FLIPPED_ALIAS_KEYS[alias3] || [];
        types.push(type4);
      });
    });
    (0, _keys2.default)(t5.FLIPPED_ALIAS_KEYS).forEach(function(type4) {
      t5[type4.toUpperCase() + "_TYPES"] = t5.FLIPPED_ALIAS_KEYS[type4];
      registerType(type4);
    });
    var TYPES = exports2.TYPES = (0, _keys2.default)(t5.VISITOR_KEYS).concat((0, _keys2.default)(t5.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t5.DEPRECATED_KEYS));
    function is2(type4, node, opts) {
      if (!node)
        return false;
      var matches = isType(node.type, type4);
      if (!matches)
        return false;
      if (typeof opts === "undefined") {
        return true;
      } else {
        return t5.shallowEqual(node, opts);
      }
    }
    __name(is2, "is");
    function isType(nodeType, targetType) {
      if (nodeType === targetType)
        return true;
      if (t5.ALIAS_KEYS[targetType])
        return false;
      var aliases = t5.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType)
          return true;
        for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var alias3 = _ref;
          if (nodeType === alias3)
            return true;
        }
      }
      return false;
    }
    __name(isType, "isType");
    (0, _keys2.default)(t5.BUILDER_KEYS).forEach(function(type4) {
      var keys = t5.BUILDER_KEYS[type4];
      function builder() {
        if (arguments.length > keys.length) {
          throw new Error("t." + type4 + ": Too many arguments passed. Received " + arguments.length + " but can receive " + ("no more than " + keys.length));
        }
        var node = {};
        node.type = type4;
        var i = 0;
        for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var _key = _ref2;
          var field = t5.NODE_FIELDS[type4][_key];
          var arg = arguments[i++];
          if (arg === void 0)
            arg = (0, _clone2.default)(field.default);
          node[_key] = arg;
        }
        for (var key in node) {
          validate(node, key, node[key]);
        }
        return node;
      }
      __name(builder, "builder");
      t5[type4] = builder;
      t5[type4[0].toLowerCase() + type4.slice(1)] = builder;
    });
    var _loop = /* @__PURE__ */ __name(function _loop2(_type2) {
      var newType = t5.DEPRECATED_KEYS[_type2];
      function proxy(fn) {
        return function() {
          console.trace("The node type " + _type2 + " has been renamed to " + newType);
          return fn.apply(this, arguments);
        };
      }
      __name(proxy, "proxy");
      t5[_type2] = t5[_type2[0].toLowerCase() + _type2.slice(1)] = proxy(t5[newType]);
      t5["is" + _type2] = proxy(t5["is" + newType]);
      t5["assert" + _type2] = proxy(t5["assert" + newType]);
    }, "_loop");
    for (_type in t5.DEPRECATED_KEYS) {
      _loop(_type);
    }
    var _type;
    function validate(node, key, val) {
      if (!node)
        return;
      var fields = t5.NODE_FIELDS[node.type];
      if (!fields)
        return;
      var field = fields[key];
      if (!field || !field.validate)
        return;
      if (field.optional && val == null)
        return;
      field.validate(node, key, val);
    }
    __name(validate, "validate");
    function shallowEqual(actual, expected) {
      var keys = (0, _keys2.default)(expected);
      for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
        var _ref3;
        if (_isArray3) {
          if (_i3 >= _iterator3.length)
            break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done)
            break;
          _ref3 = _i3.value;
        }
        var key = _ref3;
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
    __name(shallowEqual, "shallowEqual");
    function appendToMemberExpression(member, append, computed) {
      member.object = t5.memberExpression(member.object, member.property, member.computed);
      member.property = append;
      member.computed = !!computed;
      return member;
    }
    __name(appendToMemberExpression, "appendToMemberExpression");
    function prependToMemberExpression(member, prepend) {
      member.object = t5.memberExpression(prepend, member.object);
      return member;
    }
    __name(prependToMemberExpression, "prependToMemberExpression");
    function ensureBlock(node) {
      var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "body";
      return node[key] = t5.toBlock(node[key], node);
    }
    __name(ensureBlock, "ensureBlock");
    function clone(node) {
      if (!node)
        return node;
      var newNode = {};
      for (var key in node) {
        if (key[0] === "_")
          continue;
        newNode[key] = node[key];
      }
      return newNode;
    }
    __name(clone, "clone");
    function cloneWithoutLoc(node) {
      var newNode = clone(node);
      delete newNode.loc;
      return newNode;
    }
    __name(cloneWithoutLoc, "cloneWithoutLoc");
    function cloneDeep(node) {
      if (!node)
        return node;
      var newNode = {};
      for (var key in node) {
        if (key[0] === "_")
          continue;
        var val = node[key];
        if (val) {
          if (val.type) {
            val = t5.cloneDeep(val);
          } else if (Array.isArray(val)) {
            val = val.map(t5.cloneDeep);
          }
        }
        newNode[key] = val;
      }
      return newNode;
    }
    __name(cloneDeep, "cloneDeep");
    function buildMatchMemberExpression(match, allowPartial) {
      var parts = match.split(".");
      return function(member) {
        if (!t5.isMemberExpression(member))
          return false;
        var search = [member];
        var i = 0;
        while (search.length) {
          var node = search.shift();
          if (allowPartial && i === parts.length) {
            return true;
          }
          if (t5.isIdentifier(node)) {
            if (parts[i] !== node.name)
              return false;
          } else if (t5.isStringLiteral(node)) {
            if (parts[i] !== node.value)
              return false;
          } else if (t5.isMemberExpression(node)) {
            if (node.computed && !t5.isStringLiteral(node.property)) {
              return false;
            } else {
              search.push(node.object);
              search.push(node.property);
              continue;
            }
          } else {
            return false;
          }
          if (++i > parts.length) {
            return false;
          }
        }
        return true;
      };
    }
    __name(buildMatchMemberExpression, "buildMatchMemberExpression");
    function removeComments(node) {
      for (var _iterator4 = t5.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4); ; ) {
        var _ref4;
        if (_isArray4) {
          if (_i4 >= _iterator4.length)
            break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done)
            break;
          _ref4 = _i4.value;
        }
        var key = _ref4;
        delete node[key];
      }
      return node;
    }
    __name(removeComments, "removeComments");
    function inheritsComments(child, parent) {
      inheritTrailingComments(child, parent);
      inheritLeadingComments(child, parent);
      inheritInnerComments(child, parent);
      return child;
    }
    __name(inheritsComments, "inheritsComments");
    function inheritTrailingComments(child, parent) {
      _inheritComments("trailingComments", child, parent);
    }
    __name(inheritTrailingComments, "inheritTrailingComments");
    function inheritLeadingComments(child, parent) {
      _inheritComments("leadingComments", child, parent);
    }
    __name(inheritLeadingComments, "inheritLeadingComments");
    function inheritInnerComments(child, parent) {
      _inheritComments("innerComments", child, parent);
    }
    __name(inheritInnerComments, "inheritInnerComments");
    function _inheritComments(key, child, parent) {
      if (child && parent) {
        child[key] = (0, _uniq2.default)([].concat(child[key], parent[key]).filter(Boolean));
      }
    }
    __name(_inheritComments, "_inheritComments");
    function inherits(child, parent) {
      if (!child || !parent)
        return child;
      for (var _iterator5 = t5.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5); ; ) {
        var _ref5;
        if (_isArray5) {
          if (_i5 >= _iterator5.length)
            break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done)
            break;
          _ref5 = _i5.value;
        }
        var _key2 = _ref5;
        if (child[_key2] == null) {
          child[_key2] = parent[_key2];
        }
      }
      for (var key in parent) {
        if (key[0] === "_")
          child[key] = parent[key];
      }
      for (var _iterator6 = t5.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6); ; ) {
        var _ref6;
        if (_isArray6) {
          if (_i6 >= _iterator6.length)
            break;
          _ref6 = _iterator6[_i6++];
        } else {
          _i6 = _iterator6.next();
          if (_i6.done)
            break;
          _ref6 = _i6.value;
        }
        var _key3 = _ref6;
        child[_key3] = parent[_key3];
      }
      t5.inheritsComments(child, parent);
      return child;
    }
    __name(inherits, "inherits");
    function assertNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Not a valid node " + (node && node.type));
      }
    }
    __name(assertNode, "assertNode");
    function isNode(node) {
      return !!(node && _definitions.VISITOR_KEYS[node.type]);
    }
    __name(isNode, "isNode");
    (0, _toFastProperties2.default)(t5);
    (0, _toFastProperties2.default)(t5.VISITOR_KEYS);
    function traverseFast(node, enter, opts) {
      if (!node)
        return;
      var keys = t5.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      opts = opts || {};
      enter(node, opts);
      for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7); ; ) {
        var _ref7;
        if (_isArray7) {
          if (_i7 >= _iterator7.length)
            break;
          _ref7 = _iterator7[_i7++];
        } else {
          _i7 = _iterator7.next();
          if (_i7.done)
            break;
          _ref7 = _i7.value;
        }
        var key = _ref7;
        var subNode = node[key];
        if (Array.isArray(subNode)) {
          for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8); ; ) {
            var _ref8;
            if (_isArray8) {
              if (_i8 >= _iterator8.length)
                break;
              _ref8 = _iterator8[_i8++];
            } else {
              _i8 = _iterator8.next();
              if (_i8.done)
                break;
              _ref8 = _i8.value;
            }
            var _node = _ref8;
            traverseFast(_node, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
    __name(traverseFast, "traverseFast");
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = t5.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
    function removeProperties(node, opts) {
      opts = opts || {};
      var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9); ; ) {
        var _ref9;
        if (_isArray9) {
          if (_i9 >= _iterator9.length)
            break;
          _ref9 = _iterator9[_i9++];
        } else {
          _i9 = _iterator9.next();
          if (_i9.done)
            break;
          _ref9 = _i9.value;
        }
        var _key4 = _ref9;
        if (node[_key4] != null)
          node[_key4] = void 0;
      }
      for (var key in node) {
        if (key[0] === "_" && node[key] != null)
          node[key] = void 0;
      }
      var syms = (0, _getOwnPropertySymbols2.default)(node);
      for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10); ; ) {
        var _ref10;
        if (_isArray10) {
          if (_i10 >= _iterator10.length)
            break;
          _ref10 = _iterator10[_i10++];
        } else {
          _i10 = _iterator10.next();
          if (_i10.done)
            break;
          _ref10 = _i10.value;
        }
        var sym = _ref10;
        node[sym] = null;
      }
    }
    __name(removeProperties, "removeProperties");
    function removePropertiesDeep(tree, opts) {
      traverseFast(tree, removeProperties, opts);
      return tree;
    }
    __name(removePropertiesDeep, "removePropertiesDeep");
  }
});

// node_modules/melody-types/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/melody-types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var t5 = require_lib();
    var classCallCheck = /* @__PURE__ */ __name(function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }, "classCallCheck");
    var inherits = /* @__PURE__ */ __name(function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }, "inherits");
    var possibleConstructorReturn = /* @__PURE__ */ __name(function(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }, "possibleConstructorReturn");
    var TYPE_MAP = /* @__PURE__ */ Object.create(null);
    var ALIAS_TO_TYPE = /* @__PURE__ */ Object.create(null);
    var PATH_CACHE_KEY = Symbol();
    var IS_ALIAS_OF = /* @__PURE__ */ Object.create(null);
    var Node17 = function() {
      function Node18() {
        classCallCheck(this, Node18);
        this.loc = {
          source: null,
          start: { line: 0, column: 0 },
          end: { line: 0, column: 0 }
        };
        this[PATH_CACHE_KEY] = [];
      }
      __name(Node18, "Node");
      Node18.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
        var _this = this;
        return Object.getOwnPropertyNames(this).reduce(function(acc, name) {
          if (name === "loc" || name === "parent") {
            return acc;
          }
          var value = _this[name];
          if (Array.isArray(value)) {
            acc[name] = value.map(function(val) {
              return val.toJSON();
            });
          } else {
            acc[name] = value && value.toJSON ? value.toJSON() : value;
          }
          return acc;
        }, {
          type: this.type
        });
      }, "toJSON");
      Node18.registerType = /* @__PURE__ */ __name(function registerType(type4) {
        if (Node18["is" + type4]) {
          return;
        }
        Node18["is" + type4] = function(node) {
          return is2(node, type4);
        };
      }, "registerType");
      return Node18;
    }();
    Node17.registerType("Scope");
    function is2(node, type4) {
      if (!node)
        return false;
      return node.type === type4 || IS_ALIAS_OF[type4] && IS_ALIAS_OF[type4][node.type] || t5.is(type4, node);
    }
    __name(is2, "is");
    function visitor3(type4) {
      for (var _len = arguments.length, fields = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        fields[_key - 1] = arguments[_key];
      }
      type4.prototype.visitorKeys = fields;
    }
    __name(visitor3, "visitor");
    function alias3(type4) {
      for (var _len2 = arguments.length, aliases = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        aliases[_key2 - 1] = arguments[_key2];
      }
      type4.prototype.aliases = aliases;
      for (var i = 0, len = aliases.length; i < len; i++) {
        var _alias = aliases[i];
        if (!ALIAS_TO_TYPE[_alias]) {
          ALIAS_TO_TYPE[_alias] = [];
        }
        ALIAS_TO_TYPE[_alias].push(type4.prototype.type);
        if (!IS_ALIAS_OF[_alias]) {
          IS_ALIAS_OF[_alias] = {};
        }
        IS_ALIAS_OF[_alias][type4.prototype.type] = true;
        Node17.registerType(_alias);
      }
    }
    __name(alias3, "alias");
    function type3(Type, type4) {
      Type.prototype.type = type4;
      TYPE_MAP[type4] = Type;
      Node17.registerType(type4);
    }
    __name(type3, "type");
    var Fragment = function(_Node) {
      inherits(Fragment2, _Node);
      function Fragment2(expression) {
        classCallCheck(this, Fragment2);
        var _this2 = possibleConstructorReturn(this, _Node.call(this));
        _this2.value = expression;
        return _this2;
      }
      __name(Fragment2, "Fragment");
      return Fragment2;
    }(Node17);
    type3(Fragment, "Fragment");
    alias3(Fragment, "Statement");
    visitor3(Fragment, "value");
    var PrintExpressionStatement3 = function(_Node2) {
      inherits(PrintExpressionStatement4, _Node2);
      function PrintExpressionStatement4(expression) {
        classCallCheck(this, PrintExpressionStatement4);
        var _this3 = possibleConstructorReturn(this, _Node2.call(this));
        _this3.value = expression;
        return _this3;
      }
      __name(PrintExpressionStatement4, "PrintExpressionStatement");
      return PrintExpressionStatement4;
    }(Node17);
    type3(PrintExpressionStatement3, "PrintExpressionStatement");
    alias3(PrintExpressionStatement3, "Statement", "PrintStatement");
    visitor3(PrintExpressionStatement3, "value");
    var PrintTextStatement2 = function(_Node3) {
      inherits(PrintTextStatement3, _Node3);
      function PrintTextStatement3(text) {
        classCallCheck(this, PrintTextStatement3);
        var _this4 = possibleConstructorReturn(this, _Node3.call(this));
        _this4.value = text;
        return _this4;
      }
      __name(PrintTextStatement3, "PrintTextStatement");
      return PrintTextStatement3;
    }(Node17);
    type3(PrintTextStatement2, "PrintTextStatement");
    alias3(PrintTextStatement2, "Statement", "PrintStatement");
    visitor3(PrintTextStatement2, "value");
    var ConstantValue = function(_Node4) {
      inherits(ConstantValue2, _Node4);
      function ConstantValue2(value) {
        classCallCheck(this, ConstantValue2);
        var _this5 = possibleConstructorReturn(this, _Node4.call(this));
        _this5.value = value;
        return _this5;
      }
      __name(ConstantValue2, "ConstantValue");
      ConstantValue2.prototype.toString = /* @__PURE__ */ __name(function toString() {
        return "Const(" + this.value + ")";
      }, "toString");
      return ConstantValue2;
    }(Node17);
    type3(ConstantValue, "ConstantValue");
    alias3(ConstantValue, "Expression", "Literal", "Immutable");
    var StringLiteral2 = function(_ConstantValue) {
      inherits(StringLiteral3, _ConstantValue);
      function StringLiteral3() {
        classCallCheck(this, StringLiteral3);
        return possibleConstructorReturn(this, _ConstantValue.apply(this, arguments));
      }
      __name(StringLiteral3, "StringLiteral");
      return StringLiteral3;
    }(ConstantValue);
    type3(StringLiteral2, "StringLiteral");
    alias3(StringLiteral2, "Expression", "Literal", "Immutable");
    var NumericLiteral2 = function(_ConstantValue2) {
      inherits(NumericLiteral3, _ConstantValue2);
      function NumericLiteral3() {
        classCallCheck(this, NumericLiteral3);
        return possibleConstructorReturn(this, _ConstantValue2.apply(this, arguments));
      }
      __name(NumericLiteral3, "NumericLiteral");
      return NumericLiteral3;
    }(ConstantValue);
    type3(NumericLiteral2, "NumericLiteral");
    alias3(NumericLiteral2, "Expression", "Literal", "Immutable");
    var BooleanLiteral2 = function(_ConstantValue3) {
      inherits(BooleanLiteral3, _ConstantValue3);
      function BooleanLiteral3(value) {
        classCallCheck(this, BooleanLiteral3);
        return possibleConstructorReturn(this, _ConstantValue3.call(this, value));
      }
      __name(BooleanLiteral3, "BooleanLiteral");
      return BooleanLiteral3;
    }(ConstantValue);
    type3(BooleanLiteral2, "BooleanLiteral");
    alias3(BooleanLiteral2, "Expression", "Literal", "Immutable");
    var NullLiteral2 = function(_ConstantValue4) {
      inherits(NullLiteral3, _ConstantValue4);
      function NullLiteral3() {
        classCallCheck(this, NullLiteral3);
        return possibleConstructorReturn(this, _ConstantValue4.call(this, null));
      }
      __name(NullLiteral3, "NullLiteral");
      return NullLiteral3;
    }(ConstantValue);
    type3(NullLiteral2, "NullLiteral");
    alias3(NullLiteral2, "Expression", "Literal", "Immutable");
    var Identifier12 = function(_Node5) {
      inherits(Identifier13, _Node5);
      function Identifier13(name) {
        classCallCheck(this, Identifier13);
        var _this10 = possibleConstructorReturn(this, _Node5.call(this));
        _this10.name = name;
        return _this10;
      }
      __name(Identifier13, "Identifier");
      return Identifier13;
    }(Node17);
    type3(Identifier12, "Identifier");
    alias3(Identifier12, "Expression");
    var UnaryExpression2 = function(_Node6) {
      inherits(UnaryExpression3, _Node6);
      function UnaryExpression3(operator, argument) {
        classCallCheck(this, UnaryExpression3);
        var _this11 = possibleConstructorReturn(this, _Node6.call(this));
        _this11.operator = operator;
        _this11.argument = argument;
        return _this11;
      }
      __name(UnaryExpression3, "UnaryExpression");
      return UnaryExpression3;
    }(Node17);
    type3(UnaryExpression2, "UnaryExpression");
    alias3(UnaryExpression2, "Expression", "UnaryLike");
    visitor3(UnaryExpression2, "argument");
    var BinaryExpression2 = function(_Node7) {
      inherits(BinaryExpression3, _Node7);
      function BinaryExpression3(operator, left, right) {
        classCallCheck(this, BinaryExpression3);
        var _this12 = possibleConstructorReturn(this, _Node7.call(this));
        _this12.operator = operator;
        _this12.left = left;
        _this12.right = right;
        return _this12;
      }
      __name(BinaryExpression3, "BinaryExpression");
      return BinaryExpression3;
    }(Node17);
    type3(BinaryExpression2, "BinaryExpression");
    alias3(BinaryExpression2, "Binary", "Expression");
    visitor3(BinaryExpression2, "left", "right");
    var BinaryConcatExpression3 = function(_BinaryExpression) {
      inherits(BinaryConcatExpression4, _BinaryExpression);
      function BinaryConcatExpression4(left, right) {
        classCallCheck(this, BinaryConcatExpression4);
        var _this13 = possibleConstructorReturn(this, _BinaryExpression.call(this, "~", left, right));
        _this13.wasImplicitConcatenation = false;
        return _this13;
      }
      __name(BinaryConcatExpression4, "BinaryConcatExpression");
      return BinaryConcatExpression4;
    }(BinaryExpression2);
    type3(BinaryConcatExpression3, "BinaryConcatExpression");
    alias3(BinaryConcatExpression3, "BinaryExpression", "Binary", "Expression");
    visitor3(BinaryConcatExpression3, "left", "right");
    var ConditionalExpression2 = function(_Node8) {
      inherits(ConditionalExpression3, _Node8);
      function ConditionalExpression3(test, consequent, alternate) {
        classCallCheck(this, ConditionalExpression3);
        var _this14 = possibleConstructorReturn(this, _Node8.call(this));
        _this14.test = test;
        _this14.consequent = consequent;
        _this14.alternate = alternate;
        return _this14;
      }
      __name(ConditionalExpression3, "ConditionalExpression");
      return ConditionalExpression3;
    }(Node17);
    type3(ConditionalExpression2, "ConditionalExpression");
    alias3(ConditionalExpression2, "Expression", "Conditional");
    visitor3(ConditionalExpression2, "test", "consequent", "alternate");
    var ArrayExpression2 = function(_Node9) {
      inherits(ArrayExpression3, _Node9);
      function ArrayExpression3() {
        var elements = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, ArrayExpression3);
        var _this15 = possibleConstructorReturn(this, _Node9.call(this));
        _this15.elements = elements;
        return _this15;
      }
      __name(ArrayExpression3, "ArrayExpression");
      return ArrayExpression3;
    }(Node17);
    type3(ArrayExpression2, "ArrayExpression");
    alias3(ArrayExpression2, "Expression");
    visitor3(ArrayExpression2, "elements");
    var MemberExpression2 = function(_Node10) {
      inherits(MemberExpression3, _Node10);
      function MemberExpression3(object, property, computed) {
        classCallCheck(this, MemberExpression3);
        var _this16 = possibleConstructorReturn(this, _Node10.call(this));
        _this16.object = object;
        _this16.property = property;
        _this16.computed = computed;
        return _this16;
      }
      __name(MemberExpression3, "MemberExpression");
      return MemberExpression3;
    }(Node17);
    type3(MemberExpression2, "MemberExpression");
    alias3(MemberExpression2, "Expression", "LVal");
    visitor3(MemberExpression2, "object", "property");
    var CallExpression2 = function(_Node11) {
      inherits(CallExpression3, _Node11);
      function CallExpression3(callee, args) {
        classCallCheck(this, CallExpression3);
        var _this17 = possibleConstructorReturn(this, _Node11.call(this));
        _this17.callee = callee;
        _this17.arguments = args;
        return _this17;
      }
      __name(CallExpression3, "CallExpression");
      return CallExpression3;
    }(Node17);
    type3(CallExpression2, "CallExpression");
    alias3(CallExpression2, "Expression", "FunctionInvocation");
    visitor3(CallExpression2, "callee", "arguments");
    var NamedArgumentExpression2 = function(_Node12) {
      inherits(NamedArgumentExpression3, _Node12);
      function NamedArgumentExpression3(name, value) {
        classCallCheck(this, NamedArgumentExpression3);
        var _this18 = possibleConstructorReturn(this, _Node12.call(this));
        _this18.name = name;
        _this18.value = value;
        return _this18;
      }
      __name(NamedArgumentExpression3, "NamedArgumentExpression");
      return NamedArgumentExpression3;
    }(Node17);
    type3(NamedArgumentExpression2, "NamedArgumentExpression");
    alias3(NamedArgumentExpression2, "Expression");
    visitor3(NamedArgumentExpression2, "name", "value");
    var ObjectExpression2 = function(_Node13) {
      inherits(ObjectExpression3, _Node13);
      function ObjectExpression3() {
        var properties = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, ObjectExpression3);
        var _this19 = possibleConstructorReturn(this, _Node13.call(this));
        _this19.properties = properties;
        return _this19;
      }
      __name(ObjectExpression3, "ObjectExpression");
      return ObjectExpression3;
    }(Node17);
    type3(ObjectExpression2, "ObjectExpression");
    alias3(ObjectExpression2, "Expression");
    visitor3(ObjectExpression2, "properties");
    var ObjectProperty2 = function(_Node14) {
      inherits(ObjectProperty3, _Node14);
      function ObjectProperty3(key, value, computed) {
        classCallCheck(this, ObjectProperty3);
        var _this20 = possibleConstructorReturn(this, _Node14.call(this));
        _this20.key = key;
        _this20.value = value;
        _this20.computed = computed;
        return _this20;
      }
      __name(ObjectProperty3, "ObjectProperty");
      return ObjectProperty3;
    }(Node17);
    type3(ObjectProperty2, "ObjectProperty");
    alias3(ObjectProperty2, "Property", "ObjectMember");
    visitor3(ObjectProperty2, "key", "value");
    var SequenceExpression3 = function(_Node15) {
      inherits(SequenceExpression4, _Node15);
      function SequenceExpression4() {
        var expressions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        classCallCheck(this, SequenceExpression4);
        var _this21 = possibleConstructorReturn(this, _Node15.call(this));
        _this21.expressions = expressions;
        return _this21;
      }
      __name(SequenceExpression4, "SequenceExpression");
      SequenceExpression4.prototype.add = /* @__PURE__ */ __name(function add(child) {
        this.expressions.push(child);
        this.loc.end = child.loc.end;
      }, "add");
      return SequenceExpression4;
    }(Node17);
    type3(SequenceExpression3, "SequenceExpression");
    alias3(SequenceExpression3, "Expression", "Scope");
    visitor3(SequenceExpression3, "expressions");
    var SliceExpression2 = function(_Node16) {
      inherits(SliceExpression3, _Node16);
      function SliceExpression3(target, start, end) {
        classCallCheck(this, SliceExpression3);
        var _this22 = possibleConstructorReturn(this, _Node16.call(this));
        _this22.target = target;
        _this22.start = start;
        _this22.end = end;
        return _this22;
      }
      __name(SliceExpression3, "SliceExpression");
      return SliceExpression3;
    }(Node17);
    type3(SliceExpression2, "SliceExpression");
    alias3(SliceExpression2, "Expression");
    visitor3(SliceExpression2, "source", "start", "end");
    var FilterExpression2 = function(_Node17) {
      inherits(FilterExpression3, _Node17);
      function FilterExpression3(target, name, args) {
        classCallCheck(this, FilterExpression3);
        var _this23 = possibleConstructorReturn(this, _Node17.call(this));
        _this23.target = target;
        _this23.name = name;
        _this23.arguments = args;
        return _this23;
      }
      __name(FilterExpression3, "FilterExpression");
      return FilterExpression3;
    }(Node17);
    type3(FilterExpression2, "FilterExpression");
    alias3(FilterExpression2, "Expression");
    visitor3(FilterExpression2, "target", "arguments");
    var Element3 = function(_Node18) {
      inherits(Element4, _Node18);
      function Element4(name) {
        classCallCheck(this, Element4);
        var _this24 = possibleConstructorReturn(this, _Node18.call(this));
        _this24.name = name;
        _this24.attributes = [];
        _this24.children = [];
        _this24.selfClosing = false;
        return _this24;
      }
      __name(Element4, "Element");
      return Element4;
    }(Node17);
    type3(Element3, "Element");
    alias3(Element3, "Expression");
    visitor3(Element3, "attributes", "children");
    var Attribute2 = function(_Node19) {
      inherits(Attribute3, _Node19);
      function Attribute3(name) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        classCallCheck(this, Attribute3);
        var _this25 = possibleConstructorReturn(this, _Node19.call(this));
        _this25.name = name;
        _this25.value = value;
        return _this25;
      }
      __name(Attribute3, "Attribute");
      Attribute3.prototype.isImmutable = /* @__PURE__ */ __name(function isImmutable() {
        return is2(this.name, "Identifier") && is2(this.value, "Immutable");
      }, "isImmutable");
      return Attribute3;
    }(Node17);
    type3(Attribute2, "Attribute");
    visitor3(Attribute2, "name", "value");
    var TwigComment2 = function(_Node20) {
      inherits(TwigComment3, _Node20);
      function TwigComment3(text) {
        classCallCheck(this, TwigComment3);
        var _this26 = possibleConstructorReturn(this, _Node20.call(this));
        _this26.value = text;
        return _this26;
      }
      __name(TwigComment3, "TwigComment");
      return TwigComment3;
    }(Node17);
    type3(TwigComment2, "TwigComment");
    visitor3(TwigComment2, "value");
    var HtmlComment2 = function(_Node21) {
      inherits(HtmlComment3, _Node21);
      function HtmlComment3(text) {
        classCallCheck(this, HtmlComment3);
        var _this27 = possibleConstructorReturn(this, _Node21.call(this));
        _this27.value = text;
        return _this27;
      }
      __name(HtmlComment3, "HtmlComment");
      return HtmlComment3;
    }(Node17);
    type3(HtmlComment2, "HtmlComment");
    visitor3(HtmlComment2, "value");
    var Declaration2 = function(_Node22) {
      inherits(Declaration3, _Node22);
      function Declaration3(declarationType) {
        classCallCheck(this, Declaration3);
        var _this28 = possibleConstructorReturn(this, _Node22.call(this));
        _this28.declarationType = declarationType;
        _this28.parts = [];
        return _this28;
      }
      __name(Declaration3, "Declaration");
      return Declaration3;
    }(Node17);
    type3(Declaration2, "Declaration");
    visitor3(Declaration2, "parts");
    var GenericTwigTag2 = function(_Node23) {
      inherits(GenericTwigTag3, _Node23);
      function GenericTwigTag3(tagName) {
        classCallCheck(this, GenericTwigTag3);
        var _this29 = possibleConstructorReturn(this, _Node23.call(this));
        _this29.tagName = tagName;
        _this29.parts = [];
        _this29.sections = [];
        return _this29;
      }
      __name(GenericTwigTag3, "GenericTwigTag");
      return GenericTwigTag3;
    }(Node17);
    type3(GenericTwigTag2, "GenericTwigTag");
    var GenericToken2 = function(_Node24) {
      inherits(GenericToken3, _Node24);
      function GenericToken3(tokenType, tokenText) {
        classCallCheck(this, GenericToken3);
        var _this30 = possibleConstructorReturn(this, _Node24.call(this));
        _this30.tokenType = tokenType;
        _this30.tokenText = tokenText;
        return _this30;
      }
      __name(GenericToken3, "GenericToken");
      return GenericToken3;
    }(Node17);
    type3(GenericToken2, "GenericToken");
    exports2.TYPE_MAP = TYPE_MAP;
    exports2.ALIAS_TO_TYPE = ALIAS_TO_TYPE;
    exports2.PATH_CACHE_KEY = PATH_CACHE_KEY;
    exports2.Node = Node17;
    exports2.is = is2;
    exports2.visitor = visitor3;
    exports2.alias = alias3;
    exports2.type = type3;
    exports2.Fragment = Fragment;
    exports2.PrintExpressionStatement = PrintExpressionStatement3;
    exports2.PrintTextStatement = PrintTextStatement2;
    exports2.ConstantValue = ConstantValue;
    exports2.StringLiteral = StringLiteral2;
    exports2.NumericLiteral = NumericLiteral2;
    exports2.BooleanLiteral = BooleanLiteral2;
    exports2.NullLiteral = NullLiteral2;
    exports2.Identifier = Identifier12;
    exports2.UnaryExpression = UnaryExpression2;
    exports2.BinaryExpression = BinaryExpression2;
    exports2.BinaryConcatExpression = BinaryConcatExpression3;
    exports2.ConditionalExpression = ConditionalExpression2;
    exports2.ArrayExpression = ArrayExpression2;
    exports2.MemberExpression = MemberExpression2;
    exports2.CallExpression = CallExpression2;
    exports2.NamedArgumentExpression = NamedArgumentExpression2;
    exports2.ObjectExpression = ObjectExpression2;
    exports2.ObjectProperty = ObjectProperty2;
    exports2.SequenceExpression = SequenceExpression3;
    exports2.SliceExpression = SliceExpression2;
    exports2.FilterExpression = FilterExpression2;
    exports2.Element = Element3;
    exports2.Attribute = Attribute2;
    exports2.TwigComment = TwigComment2;
    exports2.HtmlComment = HtmlComment2;
    exports2.Declaration = Declaration2;
    exports2.GenericTwigTag = GenericTwigTag2;
    exports2.GenericToken = GenericToken2;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    module2.exports = arrayMap;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    module2.exports = isSymbol;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(baseToString, "baseToString");
    module2.exports = baseToString;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    __name(baseSlice, "baseSlice");
    module2.exports = baseSlice;
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice = require_baseSlice();
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    __name(castSlice, "castSlice");
    module2.exports = castSlice;
  }
});

// node_modules/lodash/_charsEndIndex.js
var require_charsEndIndex = __commonJS({
  "node_modules/lodash/_charsEndIndex.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    __name(charsEndIndex, "charsEndIndex");
    module2.exports = charsEndIndex;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    __name(asciiToArray, "asciiToArray");
    module2.exports = asciiToArray;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    __name(hasUnicode, "hasUnicode");
    module2.exports = hasUnicode;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    __name(unicodeToArray, "unicodeToArray");
    module2.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    __name(stringToArray, "stringToArray");
    module2.exports = stringToArray;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    __name(toString, "toString");
    module2.exports = toString;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    __name(trimmedEndIndex, "trimmedEndIndex");
    module2.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/trimEnd.js
var require_trimEnd = __commonJS({
  "node_modules/lodash/trimEnd.js"(exports2, module2) {
    var baseToString = require_baseToString();
    var castSlice = require_castSlice();
    var charsEndIndex = require_charsEndIndex();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    var trimmedEndIndex = require_trimmedEndIndex();
    function trimEnd2(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === void 0)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
      return castSlice(strSymbols, 0, end).join("");
    }
    __name(trimEnd2, "trimEnd");
    module2.exports = trimEnd2;
  }
});

// node_modules/lodash/_charsStartIndex.js
var require_charsStartIndex = __commonJS({
  "node_modules/lodash/_charsStartIndex.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    __name(charsStartIndex, "charsStartIndex");
    module2.exports = charsStartIndex;
  }
});

// node_modules/lodash/trimStart.js
var require_trimStart = __commonJS({
  "node_modules/lodash/trimStart.js"(exports2, module2) {
    var baseToString = require_baseToString();
    var castSlice = require_castSlice();
    var charsStartIndex = require_charsStartIndex();
    var stringToArray = require_stringToArray();
    var toString = require_toString();
    var reTrimStart = /^\s+/;
    function trimStart2(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === void 0)) {
        return string.replace(reTrimStart, "");
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
      return castSlice(strSymbols, start).join("");
    }
    __name(trimStart2, "trimStart");
    module2.exports = trimStart2;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    __name(createBaseFor, "createBaseFor");
    module2.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys3();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    __name(baseForOwn, "baseForOwn");
    module2.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    __name(createBaseEach, "createBaseEach");
    module2.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// node_modules/lodash/_baseFilter.js
var require_baseFilter = __commonJS({
  "node_modules/lodash/_baseFilter.js"(exports2, module2) {
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection2) {
        if (predicate(value, index, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    __name(baseFilter, "baseFilter");
    module2.exports = baseFilter;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    __name(arraySome, "arraySome");
    module2.exports = arraySome;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    __name(equalArrays, "equalArrays");
    module2.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    module2.exports = mapToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    __name(equalByTag, "equalByTag");
    module2.exports = equalByTag;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    __name(equalObjects, "equalObjects");
    module2.exports = equalObjects;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    __name(baseIsEqualDeep, "baseIsEqualDeep");
    module2.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    __name(baseIsEqual, "baseIsEqual");
    module2.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    __name(baseIsMatch, "baseIsMatch");
    module2.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    __name(isStrictComparable, "isStrictComparable");
    module2.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys3();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    __name(getMatchData, "getMatchData");
    module2.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    __name(matchesStrictComparable, "matchesStrictComparable");
    module2.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    __name(baseMatches, "baseMatches");
    module2.exports = baseMatches;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type3 = typeof value;
      if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    __name(isKey, "isKey");
    module2.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = /* @__PURE__ */ __name(function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      }, "memoized");
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    __name(memoize, "memoize");
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    __name(memoizeCapped, "memoizeCapped");
    module2.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    __name(castPath, "castPath");
    module2.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    __name(toKey, "toKey");
    module2.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    __name(baseGet, "baseGet");
    module2.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function get(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    __name(get, "get");
    module2.exports = get;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    __name(baseHasIn, "baseHasIn");
    module2.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, result = false;
      while (++index < length) {
        var key = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    __name(hasPath, "hasPath");
    module2.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    __name(hasIn, "hasIn");
    module2.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    __name(baseMatchesProperty, "baseMatchesProperty");
    module2.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports2, module2) {
    function identity(value) {
      return value;
    }
    __name(identity, "identity");
    module2.exports = identity;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(baseProperty, "baseProperty");
    module2.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    __name(basePropertyDeep, "basePropertyDeep");
    module2.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    __name(property, "property");
    module2.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    __name(baseIteratee, "baseIteratee");
    module2.exports = baseIteratee;
  }
});

// node_modules/lodash/filter.js
var require_filter = __commonJS({
  "node_modules/lodash/filter.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var baseFilter = require_baseFilter();
    var baseIteratee = require_baseIteratee();
    var isArray = require_isArray();
    function filter2(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    __name(filter2, "filter");
    module2.exports = filter2;
  }
});

// node_modules/melody-traverse/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/melody-traverse/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var melodyTypes = require_lib2();
    var EXPLODED = Symbol();
    function explode(visitor3) {
      if (visitor3[EXPLODED]) {
        return visitor3;
      }
      visitor3[EXPLODED] = true;
      for (var _iterator = Object.getOwnPropertyNames(visitor3), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var key = _ref;
        var fns = visitor3[key];
        if (typeof fns === "function") {
          fns = visitor3[key] = { enter: fns };
        }
        if (fns.enter && !Array.isArray(fns.enter)) {
          fns.enter = [fns.enter];
        }
        if (fns.exit && !Array.isArray(fns.exit)) {
          fns.exit = [fns.exit];
        }
      }
      var j = 0;
      var visitorKeys = Object.getOwnPropertyNames(visitor3);
      var visitorKeyLength = visitorKeys.length;
      for (; j < visitorKeyLength; j++) {
        var _key = visitorKeys[j];
        if (melodyTypes.ALIAS_TO_TYPE[_key]) {
          var i = 0;
          for (var types = melodyTypes.ALIAS_TO_TYPE[_key], len = types.length; i < len; i++) {
            var type3 = types[i];
            if (!visitor3[type3]) {
              visitor3[type3] = { enter: [] };
            }
            if (visitor3[_key].enter) {
              var _visitor$type$enter;
              (_visitor$type$enter = visitor3[type3].enter).push.apply(_visitor$type$enter, visitor3[_key].enter);
            }
            if (visitor3[_key].exit) {
              var _visitor$type$exit;
              if (!visitor3[type3].exit) {
                visitor3[type3].exit = [];
              }
              (_visitor$type$exit = visitor3[type3].exit).push.apply(_visitor$type$exit, visitor3[_key].exit);
            }
          }
          delete visitor3[_key];
        }
      }
    }
    __name(explode, "explode");
    function merge() {
      var rootVisitor = {};
      var i = 0;
      for (var len = arguments.length; i < len; i++) {
        var visitor3 = arguments.length <= i ? void 0 : arguments[i];
        explode(visitor3);
        var j = 0;
        var visitorTypes = Object.getOwnPropertyNames(visitor3);
        for (var numberOfTypes = visitorTypes.length; j < numberOfTypes; j++) {
          var key = visitorTypes[j];
          var visitorType = visitor3[key];
          if (!rootVisitor[key]) {
            rootVisitor[key] = {};
          }
          var nodeVisitor = rootVisitor[key];
          nodeVisitor.enter = [].concat(nodeVisitor.enter || [], visitorType.enter || []);
          nodeVisitor.exit = [].concat(nodeVisitor.exit || [], visitorType.exit || []);
        }
      }
      return rootVisitor;
    }
    __name(merge, "merge");
    var classCallCheck = /* @__PURE__ */ __name(function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }, "classCallCheck");
    var createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      __name(defineProperties, "defineProperties");
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var TraversalContext = function() {
      function TraversalContext2(scope, visitor3, state, parentPath) {
        classCallCheck(this, TraversalContext2);
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.visitor = visitor3;
        this.queue = null;
        this.priorityQueue = null;
      }
      __name(TraversalContext2, "TraversalContext");
      TraversalContext2.prototype.create = /* @__PURE__ */ __name(function create(parent, container, key, listKey) {
        return Path.get({
          parentPath: this.parentPath,
          parent,
          container,
          key,
          listKey
        });
      }, "create");
      TraversalContext2.prototype.shouldVisit = /* @__PURE__ */ __name(function shouldVisit(node) {
        var visitor3 = this.visitor;
        if (visitor3[node.type]) {
          return true;
        }
        var keys = node.visitorKeys;
        if (!keys || !keys.length) {
          return false;
        }
        var i = void 0, len = void 0;
        for (i = 0, len = keys.length; i < len; i++) {
          if (node[keys[i]]) {
            return true;
          }
        }
        return false;
      }, "shouldVisit");
      TraversalContext2.prototype.visit = /* @__PURE__ */ __name(function visit2(node, key) {
        var nodes = node[key];
        if (!nodes) {
          return false;
        }
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }, "visit");
      TraversalContext2.prototype.visitSingle = /* @__PURE__ */ __name(function visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }, "visitSingle");
      TraversalContext2.prototype.visitMultiple = /* @__PURE__ */ __name(function visitMultiple(container, parent, listKey) {
        if (!container.length) {
          return false;
        }
        var queue = [];
        for (var i = 0, len = container.length; i < len; i++) {
          var node = container[i];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, i, listKey));
          }
        }
        return this.visitQueue(queue);
      }, "visitMultiple");
      TraversalContext2.prototype.visitQueue = /* @__PURE__ */ __name(function visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        var visited = [], stop = false;
        for (var _iterator = queue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var path2 = _ref;
          path2.resync();
          path2.pushContext(this);
          if (visited.indexOf(path2.node) >= 0) {
            continue;
          }
          visited.push(path2.node);
          if (path2.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) {
              break;
            }
          }
        }
        for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var _path = _ref2;
          _path.popContext();
        }
        this.queue = null;
        return stop;
      }, "visitQueue");
      TraversalContext2.prototype.maybeQueue = /* @__PURE__ */ __name(function maybeQueue(path2, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path2);
          } else {
            this.priorityQueue.push(path2);
          }
        }
      }, "maybeQueue");
      return TraversalContext2;
    }();
    function traverse2(parentNode, visitor3, scope) {
      var state = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var parentPath = arguments[4];
      if (!parentNode) {
        return;
      }
      explode(visitor3);
      visit(parentNode, visitor3, scope, state, parentPath);
    }
    __name(traverse2, "traverse");
    function visit(node, visitor3, scope, state, parentPath) {
      var keys = node.visitorKeys;
      if (!keys || !keys.length) {
        return;
      }
      var context = new TraversalContext(scope, visitor3, state, parentPath);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (context.visit(node, key)) {
          return;
        }
      }
    }
    __name(visit, "visit");
    var Binding = function() {
      function Binding2(identifier5, scope, path2) {
        var kind = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "global";
        classCallCheck(this, Binding2);
        this.identifier = identifier5;
        this.scope = scope;
        this.path = path2;
        this.kind = kind;
        this.referenced = false;
        this.references = 0;
        this.referencePaths = [];
        this.definitionPaths = [];
        this.shadowedBinding = null;
        this.contextual = false;
        this.data = /* @__PURE__ */ Object.create(null);
      }
      __name(Binding2, "Binding");
      Binding2.prototype.getData = /* @__PURE__ */ __name(function getData(key) {
        return this.data[key];
      }, "getData");
      Binding2.prototype.setData = /* @__PURE__ */ __name(function setData(key, value) {
        this.data[key] = value;
      }, "setData");
      Binding2.prototype.reference = /* @__PURE__ */ __name(function reference(path2) {
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path2);
      }, "reference");
      Binding2.prototype.getRootDefinition = /* @__PURE__ */ __name(function getRootDefinition() {
        if (this.shadowedBinding) {
          return this.shadowedBinding.getRootDefinition();
        }
        return this;
      }, "getRootDefinition");
      return Binding2;
    }();
    var CACHE_KEY = Symbol();
    var uid = 0;
    var Scope = function() {
      function Scope2(path2, parentScope) {
        classCallCheck(this, Scope2);
        this.uid = uid++;
        this.parent = parentScope;
        this.parentBlock = path2.parent;
        this.block = path2.node;
        this.path = path2;
        this.references = /* @__PURE__ */ Object.create(null);
        this.bindings = /* @__PURE__ */ Object.create(null);
        this.globals = /* @__PURE__ */ Object.create(null);
        this.uids = /* @__PURE__ */ Object.create(null);
        this.escapesContext = false;
        this._contextName = null;
        this.mutated = false;
      }
      __name(Scope2, "Scope");
      Scope2.get = /* @__PURE__ */ __name(function get$$1(path2, parentScope) {
        if (parentScope && parentScope.block == path2.node) {
          return parentScope;
        }
        var cached = getCache(path2.node);
        if (cached) {
          return cached;
        }
        var scope = new Scope2(path2, parentScope);
        path2.node[CACHE_KEY] = scope;
        return scope;
      }, "get$$1");
      Scope2.prototype.getBinding = /* @__PURE__ */ __name(function getBinding(name) {
        var scope = this;
        do {
          var binding = scope.getOwnBinding(name);
          if (binding) {
            return binding;
          }
          if (scope.path.is("RootScope")) {
            return;
          }
        } while (scope = scope.parent);
      }, "getBinding");
      Scope2.prototype.getOwnBinding = /* @__PURE__ */ __name(function getOwnBinding(name) {
        return this.bindings[name];
      }, "getOwnBinding");
      Scope2.prototype.hasOwnBinding = /* @__PURE__ */ __name(function hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }, "hasOwnBinding");
      Scope2.prototype.hasBinding = /* @__PURE__ */ __name(function hasBinding(name) {
        return !name ? false : !!(this.hasOwnBinding(name) || this.parentHasBinding(name));
      }, "hasBinding");
      Scope2.prototype.getRootScope = /* @__PURE__ */ __name(function getRootScope() {
        var scope = this;
        while (scope.parent) {
          scope = scope.parent;
        }
        return scope;
      }, "getRootScope");
      Scope2.prototype.registerBinding = /* @__PURE__ */ __name(function registerBinding(name) {
        var path2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "context";
        var scope = this;
        if (kind === "global" && path2 === null) {
          scope = this.getRootScope();
        } else if (kind === "const") {
          while (scope.parent) {
            scope = scope.parent;
            if (scope.path.is("RootScope")) {
              break;
            }
          }
        }
        if (this.path.state) {
          this.path.state.markIdentifier(name);
        }
        return scope.bindings[name] = new Binding(name, this, path2, kind);
      }, "registerBinding");
      Scope2.prototype.reference = /* @__PURE__ */ __name(function reference(name, path2) {
        var binding = this.getBinding(name);
        if (!binding) {
          binding = this.registerBinding(name);
        }
        binding.reference(path2);
      }, "reference");
      Scope2.prototype.parentHasBinding = /* @__PURE__ */ __name(function parentHasBinding(name) {
        return this.parent && this.parent.hasBinding(name);
      }, "parentHasBinding");
      Scope2.prototype.generateUid = /* @__PURE__ */ __name(function generateUid() {
        var nameHint = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "temp";
        var name = toIdentifier(nameHint);
        var uid2 = void 0, i = 0;
        do {
          uid2 = _generateUid(name, i);
          i++;
        } while (this.hasBinding(uid2));
        return uid2;
      }, "generateUid");
      createClass(Scope2, [{
        key: "contextName",
        set: /* @__PURE__ */ __name(function set$$1(val) {
          this._contextName = val;
        }, "set$$1"),
        get: /* @__PURE__ */ __name(function get$$1() {
          if (this._contextName) {
            return this._contextName;
          }
          if (this.parent) {
            return this.parent.contextName || "_context";
          }
          return "_context";
        }, "get$$1")
      }, {
        key: "needsSubContext",
        get: /* @__PURE__ */ __name(function get$$1() {
          return this.escapesContext && this.hasCustomBindings;
        }, "get$$1")
      }, {
        key: "hasCustomBindings",
        get: /* @__PURE__ */ __name(function get$$1() {
          return !!Object.keys(this.bindings).length;
        }, "get$$1")
      }]);
      return Scope2;
    }();
    function getCache(node) {
      return node[CACHE_KEY];
    }
    __name(getCache, "getCache");
    function toIdentifier(nameHint) {
      var name = nameHint + "";
      name = name.replace(/[^a-zA-Z0-9$_]/g, "");
      name = name.replace(/^[-0-9]+/, "");
      name = name.replace(/[-\s]+(.)?/, function(match, c) {
        return c ? c.toUpperCase() : "";
      });
      name = name.replace(/^_+/, "").replace(/[0-9]+$/, "");
      return name;
    }
    __name(toIdentifier, "toIdentifier");
    function _generateUid(name, i) {
      if (i > 0) {
        return "_" + name + "$" + i;
      }
      return "_" + name;
    }
    __name(_generateUid, "_generateUid");
    var Path = function() {
      function Path2(parent) {
        classCallCheck(this, Path2);
        this.parent = parent;
        this.inList = false;
        this.listKey = null;
        this.parentKey = null;
        this.container = null;
        this.parentPath = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.state = null;
        this.data = /* @__PURE__ */ Object.create(null);
        this.contexts = [];
        this.scope = null;
        this.visitor = null;
        this.shouldSkip = false;
        this.shouldStop = false;
        this.removed = false;
      }
      __name(Path2, "Path");
      Path2.get = /* @__PURE__ */ __name(function get$$1(_ref) {
        var parentPath = _ref.parentPath, parent = _ref.parent, container = _ref.container, listKey = _ref.listKey, key = _ref.key;
        var targetNode = container[key], paths = parent && parent[melodyTypes.PATH_CACHE_KEY] || (parent ? parent[melodyTypes.PATH_CACHE_KEY] = [] : []);
        var path2 = void 0;
        for (var i = 0, len = paths.length; i < len; i++) {
          var candidate = paths[i];
          if (candidate.node === targetNode) {
            path2 = candidate;
            break;
          }
        }
        if (!path2) {
          path2 = new Path2(parent);
        }
        path2.inList = !!listKey;
        path2.listKey = listKey;
        path2.parentKey = listKey || key;
        path2.container = container;
        path2.parentPath = parentPath || path2.parentPath;
        path2.key = key;
        path2.node = path2.container[path2.key];
        path2.type = path2.node && path2.node.type;
        if (!path2.node) {
          console.log("Path has no node " + path2.parentKey + " > " + path2.key);
        }
        paths.push(path2);
        return path2;
      }, "get$$1");
      Path2.prototype.setData = /* @__PURE__ */ __name(function setData(key, val) {
        return this.data[key] = val;
      }, "setData");
      Path2.prototype.getData = /* @__PURE__ */ __name(function getData(key, def) {
        var val = this.data[key];
        if (!val && def) {
          return this.data[key] = def;
        }
        return val;
      }, "getData");
      Path2.prototype.pushContext = /* @__PURE__ */ __name(function pushContext(context) {
        this.contexts.push(context);
        this.setContext(context);
      }, "pushContext");
      Path2.prototype.popContext = /* @__PURE__ */ __name(function popContext() {
        this.contexts.pop();
        this.setContext(this.contexts[this.contexts.length - 1]);
      }, "popContext");
      Path2.prototype.setContext = /* @__PURE__ */ __name(function setContext(context) {
        this.shouldSkip = false;
        this.shouldStop = false;
        this.removed = false;
        if (context) {
          this.context = context;
          this.state = context.state;
          this.visitor = context.visitor;
        }
        this.setScope();
        return this;
      }, "setContext");
      Path2.prototype.getScope = /* @__PURE__ */ __name(function getScope(scope) {
        if (melodyTypes.Node.isScope(this.node)) {
          if (this.node.type === "BlockStatement") {
            return Scope.get(this, scope.getRootScope());
          }
          return Scope.get(this, scope);
        }
        return scope;
      }, "getScope");
      Path2.prototype.setScope = /* @__PURE__ */ __name(function setScope() {
        var target = this.context && this.context.scope;
        if (!target) {
          var path2 = this.parentPath;
          while (path2 && !target) {
            target = path2.scope;
            path2 = path2.parentPath;
          }
        }
        this.scope = this.getScope(target);
      }, "setScope");
      Path2.prototype.visit = /* @__PURE__ */ __name(function visit$$1() {
        if (!this.node) {
          return false;
        }
        if (call(this, "enter") || this.shouldSkip) {
          return this.shouldStop;
        }
        visit(this.node, this.visitor, this.scope, this.state, this);
        call(this, "exit");
        return this.shouldStop;
      }, "visit$$1");
      Path2.prototype.skip = /* @__PURE__ */ __name(function skip() {
        this.shouldSkip = true;
      }, "skip");
      Path2.prototype.stop = /* @__PURE__ */ __name(function stop() {
        this.shouldStop = true;
        this.shouldSkip = true;
      }, "stop");
      Path2.prototype.resync = /* @__PURE__ */ __name(function resync() {
        if (this.removed) {
          return;
        }
        if (this.parentPath) {
          this.parent = this.parentPath.node;
        }
        if (this.parent && this.inList) {
          var newContainer = this.parent[this.listKey];
          if (this.container !== newContainer) {
            this.container = newContainer || null;
          }
        }
        if (this.container && this.node !== this.container[this.key]) {
          this.key = null;
          if (Array.isArray(this.container)) {
            var i = void 0, len = void 0;
            for (i = 0, len = this.container.length; i < len; i++) {
              if (this.container[i] === this.node) {
                this.setKey(i);
                break;
              }
            }
          } else {
            var key = void 0;
            for (key in this.container) {
              if (this.container[key] === this.node) {
                this.setKey(key);
                break;
              }
            }
          }
        }
      }, "resync");
      Path2.prototype.setKey = /* @__PURE__ */ __name(function setKey(key) {
        this.key = key;
        this.node = this.container[this.key];
        this.type = this.node && this.node.type;
      }, "setKey");
      Path2.prototype.requeue = /* @__PURE__ */ __name(function requeue() {
        var path2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
        if (path2.removed) {
          return;
        }
        for (var _iterator = this.contexts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref2;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref2 = _i.value;
          }
          var context = _ref2;
          context.maybeQueue(path2);
        }
      }, "requeue");
      Path2.prototype.replaceWith = /* @__PURE__ */ __name(function replaceWith(value) {
        this.resync();
        var replacement = value instanceof Path2 ? value.node : value;
        if (this.node === replacement) {
          return;
        }
        _replaceWith(this, replacement);
        this.type = replacement.type;
        this.resync();
        this.setScope();
        this.requeue();
      }, "replaceWith");
      Path2.prototype.replaceWithJS = /* @__PURE__ */ __name(function replaceWithJS(replacement) {
        this.resync();
        _replaceWith(this, replacement);
        this.type = replacement.type;
        this.resync();
        this.setScope();
      }, "replaceWithJS");
      Path2.prototype.replaceWithMultipleJS = /* @__PURE__ */ __name(function replaceWithMultipleJS() {
        var _container;
        this.resync();
        if (!this.container) {
          throw new Error("Path does not have a container");
        }
        if (!Array.isArray(this.container)) {
          throw new Error("Container of path is not an array");
        }
        for (var _len = arguments.length, replacements = Array(_len), _key = 0; _key < _len; _key++) {
          replacements[_key] = arguments[_key];
        }
        (_container = this.container).splice.apply(_container, [this.key, 1].concat(replacements));
        this.resync();
        this.updateSiblingKeys(this.key, replacements.length - 1);
        markRemoved(this);
      }, "replaceWithMultipleJS");
      Path2.prototype.remove = /* @__PURE__ */ __name(function remove() {
        this.resync();
        if (Array.isArray(this.container)) {
          this.container.splice(this.key, 1);
          this.updateSiblingKeys(this.key, -1);
        } else {
          _replaceWith(this, null);
        }
        markRemoved(this);
      }, "remove");
      Path2.prototype.updateSiblingKeys = /* @__PURE__ */ __name(function updateSiblingKeys(fromIndex, incrementBy) {
        if (!this.parent) {
          return;
        }
        var paths = this.parent[melodyTypes.PATH_CACHE_KEY];
        for (var _iterator2 = paths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
          var _ref3;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref3 = _i2.value;
          }
          var path2 = _ref3;
          if (path2.key >= fromIndex) {
            path2.key += incrementBy;
          }
        }
      }, "updateSiblingKeys");
      Path2.prototype.is = /* @__PURE__ */ __name(function is2(type3) {
        return melodyTypes.is(this.node, type3);
      }, "is");
      Path2.prototype.findParentPathOfType = /* @__PURE__ */ __name(function findParentPathOfType(type3) {
        var path2 = this.parentPath;
        while (path2 && !path2.is(type3)) {
          path2 = path2.parentPath;
        }
        return path2 && path2.type === type3 ? path2 : null;
      }, "findParentPathOfType");
      Path2.prototype.get = /* @__PURE__ */ __name(function get$$1(key) {
        var _this = this;
        var parts = key.split("."), context = this.context;
        if (parts.length === 1) {
          var node = this.node, container = node[key];
          if (Array.isArray(container)) {
            return container.map(function(_, i) {
              return Path2.get({
                listKey: key,
                parentPath: _this,
                parent: node,
                container,
                key: i
              }).setContext(context);
            });
          } else {
            return Path2.get({
              parentPath: this,
              parent: node,
              container: node,
              key
            }).setContext(context);
          }
        } else {
          var path2 = this;
          for (var _iterator3 = parts, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
            var _ref4;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref4 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref4 = _i3.value;
            }
            var part = _ref4;
            if (Array.isArray(path2)) {
              path2 = path2[part];
            } else {
              path2 = path2.get(part);
            }
          }
          return path2;
        }
      }, "get$$1");
      return Path2;
    }();
    function markRemoved(path2) {
      path2.shouldSkip = true;
      path2.removed = true;
      path2.node = null;
    }
    __name(markRemoved, "markRemoved");
    function _replaceWith(path2, node) {
      if (!path2.container) {
        throw new Error("Path does not have a container");
      }
      path2.node = path2.container[path2.key] = node;
    }
    __name(_replaceWith, "_replaceWith");
    function call(path2, key) {
      if (!path2.node) {
        return false;
      }
      var visitor3 = path2.visitor[path2.node.type];
      if (!visitor3 || !visitor3[key]) {
        return false;
      }
      var fns = visitor3[key];
      for (var i = 0, len = fns.length; i < len; i++) {
        var fn = fns[i];
        if (!fn) {
          continue;
        }
        var node = path2.node;
        if (!node) {
          return true;
        }
        fn.call(path2.state, path2, path2.state);
        if (path2.node !== node) {
          return true;
        }
        if (path2.shouldStop || path2.shouldSkip || path2.removed) {
          return true;
        }
      }
      return false;
    }
    __name(call, "call");
    exports2.Scope = Scope;
    exports2.Path = Path;
    exports2.merge = merge;
    exports2.explode = explode;
    exports2.traverse = traverse2;
    exports2.visit = visit;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    __name(cloneDeep, "cloneDeep");
    module2.exports = cloneDeep;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports2, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    __name(apply, "apply");
    module2.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports2, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    __name(overRest, "overRest");
    module2.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports2, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    __name(constant, "constant");
    module2.exports = constant;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports2, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports2, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    __name(shortOut, "shortOut");
    module2.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports2, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports2, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    __name(baseRest, "baseRest");
    module2.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type3 = typeof index;
      if (type3 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type3 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    __name(isIterateeCall, "isIterateeCall");
    module2.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    __name(createAssigner, "createAssigner");
    module2.exports = createAssigner;
  }
});

// node_modules/lodash/assign.js
var require_assign = __commonJS({
  "node_modules/lodash/assign.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var isArrayLike = require_isArrayLike();
    var isPrototype = require_isPrototype();
    var keys = require_keys3();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    module2.exports = assign;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }
    __name(baseHas, "baseHas");
    module2.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has2 = __commonJS({
  "node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath = require_hasPath();
    function has(object, path2) {
      return object != null && hasPath(object, path2, baseHas);
    }
    __name(has, "has");
    module2.exports = has;
  }
});

// node_modules/babel-runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/babel-runtime/helpers/classCallCheck.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.default = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
  }
});

// node_modules/babel-traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "node_modules/babel-traverse/lib/path/lib/virtual-types.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.Flow = exports2.Pure = exports2.Generated = exports2.User = exports2.Var = exports2.BlockScoped = exports2.Referenced = exports2.Scope = exports2.Expression = exports2.Statement = exports2.BindingIdentifier = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = void 0;
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    var ReferencedIdentifier = exports2.ReferencedIdentifier = {
      types: ["Identifier", "JSXIdentifier"],
      checkPath: /* @__PURE__ */ __name(function checkPath(_ref, opts) {
        var node = _ref.node, parent = _ref.parent;
        if (!t5.isIdentifier(node, opts) && !t5.isJSXMemberExpression(parent, opts)) {
          if (t5.isJSXIdentifier(node, opts)) {
            if (_babelTypes.react.isCompatTag(node.name))
              return false;
          } else {
            return false;
          }
        }
        return t5.isReferenced(node, parent);
      }, "checkPath")
    };
    var ReferencedMemberExpression = exports2.ReferencedMemberExpression = {
      types: ["MemberExpression"],
      checkPath: /* @__PURE__ */ __name(function checkPath(_ref2) {
        var node = _ref2.node, parent = _ref2.parent;
        return t5.isMemberExpression(node) && t5.isReferenced(node, parent);
      }, "checkPath")
    };
    var BindingIdentifier = exports2.BindingIdentifier = {
      types: ["Identifier"],
      checkPath: /* @__PURE__ */ __name(function checkPath(_ref3) {
        var node = _ref3.node, parent = _ref3.parent;
        return t5.isIdentifier(node) && t5.isBinding(node, parent);
      }, "checkPath")
    };
    var Statement = exports2.Statement = {
      types: ["Statement"],
      checkPath: /* @__PURE__ */ __name(function checkPath(_ref4) {
        var node = _ref4.node, parent = _ref4.parent;
        if (t5.isStatement(node)) {
          if (t5.isVariableDeclaration(node)) {
            if (t5.isForXStatement(parent, { left: node }))
              return false;
            if (t5.isForStatement(parent, { init: node }))
              return false;
          }
          return true;
        } else {
          return false;
        }
      }, "checkPath")
    };
    var Expression = exports2.Expression = {
      types: ["Expression"],
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        if (path2.isIdentifier()) {
          return path2.isReferencedIdentifier();
        } else {
          return t5.isExpression(path2.node);
        }
      }, "checkPath")
    };
    var Scope = exports2.Scope = {
      types: ["Scopable"],
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        return t5.isScope(path2.node, path2.parent);
      }, "checkPath")
    };
    var Referenced = exports2.Referenced = {
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        return t5.isReferenced(path2.node, path2.parent);
      }, "checkPath")
    };
    var BlockScoped = exports2.BlockScoped = {
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        return t5.isBlockScoped(path2.node);
      }, "checkPath")
    };
    var Var = exports2.Var = {
      types: ["VariableDeclaration"],
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        return t5.isVar(path2.node);
      }, "checkPath")
    };
    var User = exports2.User = {
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        return path2.node && !!path2.node.loc;
      }, "checkPath")
    };
    var Generated = exports2.Generated = {
      checkPath: /* @__PURE__ */ __name(function checkPath(path2) {
        return !path2.isUser();
      }, "checkPath")
    };
    var Pure = exports2.Pure = {
      checkPath: /* @__PURE__ */ __name(function checkPath(path2, opts) {
        return path2.scope.isPure(path2.node, opts);
      }, "checkPath")
    };
    var Flow = exports2.Flow = {
      types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
      checkPath: /* @__PURE__ */ __name(function checkPath(_ref5) {
        var node = _ref5.node;
        if (t5.isFlow(node)) {
          return true;
        } else if (t5.isImportDeclaration(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else if (t5.isExportDeclaration(node)) {
          return node.exportKind === "type";
        } else if (t5.isImportSpecifier(node)) {
          return node.importKind === "type" || node.importKind === "typeof";
        } else {
          return false;
        }
      }, "checkPath")
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type3 = typeof val;
      if (type3 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type3 === "number" && isNaN(val) === false) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n3 = parseFloat(match[1]);
      var type3 = (match[2] || "ms").toLowerCase();
      switch (type3) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y;
        case "days":
        case "day":
        case "d":
          return n3 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    __name(parse2, "parse");
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, n3, name) {
      if (ms < n3) {
        return;
      }
      if (ms < n3 * 1.5) {
        return Math.floor(ms / n3) + " " + name;
      }
      return Math.ceil(ms / n3) + " " + name + "s";
    }
    __name(plural, "plural");
  }
});

// node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/debug/src/debug.js"(exports2, module2) {
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    __name(selectColor, "selectColor");
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      __name(debug, "debug");
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports2.init === "function") {
        exports2.init(debug);
      }
      return debug;
    }
    __name(createDebug, "createDebug");
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    __name(enable, "enable");
    function disable() {
      exports2.enable("");
    }
    __name(disable, "disable");
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    __name(enabled, "enabled");
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
    __name(coerce, "coerce");
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    __name(log, "log");
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    __name(save, "save");
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
    __name(localstorage, "localstorage");
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    __name(useColors, "useColors");
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    __name(log, "log");
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    __name(createWritableStdioStream, "createWritableStdioStream");
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    __name(init, "init");
    exports2.enable(load());
  }
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/invariant/invariant.js
var require_invariant = __commonJS({
  "node_modules/invariant/invariant.js"(exports2, module2) {
    "use strict";
    var NODE_ENV = process.env.NODE_ENV;
    var invariant = /* @__PURE__ */ __name(function(condition, format, a, b, c, d, e, f) {
      if (NODE_ENV !== "production") {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    }, "invariant");
    module2.exports = invariant;
  }
});

// node_modules/core-js/library/modules/_redefine-all.js
var require_redefine_all = __commonJS({
  "node_modules/core-js/library/modules/_redefine-all.js"(exports2, module2) {
    var hide = require_hide();
    module2.exports = function(target, src, safe) {
      for (var key in src) {
        if (safe && target[key])
          target[key] = src[key];
        else
          hide(target, key, src[key]);
      }
      return target;
    };
  }
});

// node_modules/core-js/library/modules/_an-instance.js
var require_an_instance = __commonJS({
  "node_modules/core-js/library/modules/_an-instance.js"(exports2, module2) {
    module2.exports = function(it, Constructor, name, forbiddenField) {
      if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
        throw TypeError(name + ": incorrect invocation!");
      }
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_iter-call.js
var require_iter_call = __commonJS({
  "node_modules/core-js/library/modules/_iter-call.js"(exports2, module2) {
    var anObject = require_an_object();
    module2.exports = function(iterator, fn, value, entries) {
      try {
        return entries ? fn(anObject(value)[0], value[1]) : fn(value);
      } catch (e) {
        var ret = iterator["return"];
        if (ret !== void 0)
          anObject(ret.call(iterator));
        throw e;
      }
    };
  }
});

// node_modules/core-js/library/modules/_is-array-iter.js
var require_is_array_iter = __commonJS({
  "node_modules/core-js/library/modules/_is-array-iter.js"(exports2, module2) {
    var Iterators = require_iterators();
    var ITERATOR = require_wks()("iterator");
    var ArrayProto = Array.prototype;
    module2.exports = function(it) {
      return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
  }
});

// node_modules/core-js/library/modules/_for-of.js
var require_for_of = __commonJS({
  "node_modules/core-js/library/modules/_for-of.js"(exports2, module2) {
    var ctx = require_ctx();
    var call = require_iter_call();
    var isArrayIter = require_is_array_iter();
    var anObject = require_an_object();
    var toLength = require_to_length();
    var getIterFn = require_core_get_iterator_method();
    var BREAK = {};
    var RETURN = {};
    var exports2 = module2.exports = function(iterable, entries, fn, that, ITERATOR) {
      var iterFn = ITERATOR ? function() {
        return iterable;
      } : getIterFn(iterable);
      var f = ctx(fn, that, entries ? 2 : 1);
      var index = 0;
      var length, step, iterator, result;
      if (typeof iterFn != "function")
        throw TypeError(iterable + " is not iterable!");
      if (isArrayIter(iterFn))
        for (length = toLength(iterable.length); length > index; index++) {
          result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
          if (result === BREAK || result === RETURN)
            return result;
        }
      else
        for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
          result = call(iterator, f, step.value, entries);
          if (result === BREAK || result === RETURN)
            return result;
        }
    };
    exports2.BREAK = BREAK;
    exports2.RETURN = RETURN;
  }
});

// node_modules/core-js/library/modules/_set-species.js
var require_set_species = __commonJS({
  "node_modules/core-js/library/modules/_set-species.js"(exports2, module2) {
    "use strict";
    var global2 = require_global();
    var core = require_core4();
    var dP = require_object_dp();
    var DESCRIPTORS = require_descriptors();
    var SPECIES = require_wks()("species");
    module2.exports = function(KEY) {
      var C = typeof core[KEY] == "function" ? core[KEY] : global2[KEY];
      if (DESCRIPTORS && C && !C[SPECIES])
        dP.f(C, SPECIES, {
          configurable: true,
          get: function() {
            return this;
          }
        });
    };
  }
});

// node_modules/core-js/library/modules/_validate-collection.js
var require_validate_collection = __commonJS({
  "node_modules/core-js/library/modules/_validate-collection.js"(exports2, module2) {
    var isObject = require_is_object();
    module2.exports = function(it, TYPE) {
      if (!isObject(it) || it._t !== TYPE)
        throw TypeError("Incompatible receiver, " + TYPE + " required!");
      return it;
    };
  }
});

// node_modules/core-js/library/modules/_collection-strong.js
var require_collection_strong = __commonJS({
  "node_modules/core-js/library/modules/_collection-strong.js"(exports2, module2) {
    "use strict";
    var dP = require_object_dp().f;
    var create = require_object_create();
    var redefineAll = require_redefine_all();
    var ctx = require_ctx();
    var anInstance = require_an_instance();
    var forOf = require_for_of();
    var $iterDefine = require_iter_define();
    var step = require_iter_step();
    var setSpecies = require_set_species();
    var DESCRIPTORS = require_descriptors();
    var fastKey = require_meta().fastKey;
    var validate = require_validate_collection();
    var SIZE = DESCRIPTORS ? "_s" : "size";
    var getEntry = /* @__PURE__ */ __name(function(that, key) {
      var index = fastKey(key);
      var entry;
      if (index !== "F")
        return that._i[index];
      for (entry = that._f; entry; entry = entry.n) {
        if (entry.k == key)
          return entry;
      }
    }, "getEntry");
    module2.exports = {
      getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
          anInstance(that, C, NAME, "_i");
          that._t = NAME;
          that._i = create(null);
          that._f = void 0;
          that._l = void 0;
          that[SIZE] = 0;
          if (iterable != void 0)
            forOf(iterable, IS_MAP, that[ADDER], that);
        });
        redefineAll(C.prototype, {
          clear: /* @__PURE__ */ __name(function clear() {
            for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
              entry.r = true;
              if (entry.p)
                entry.p = entry.p.n = void 0;
              delete data[entry.i];
            }
            that._f = that._l = void 0;
            that[SIZE] = 0;
          }, "clear"),
          "delete": function(key) {
            var that = validate(this, NAME);
            var entry = getEntry(that, key);
            if (entry) {
              var next = entry.n;
              var prev = entry.p;
              delete that._i[entry.i];
              entry.r = true;
              if (prev)
                prev.n = next;
              if (next)
                next.p = prev;
              if (that._f == entry)
                that._f = next;
              if (that._l == entry)
                that._l = prev;
              that[SIZE]--;
            }
            return !!entry;
          },
          forEach: /* @__PURE__ */ __name(function forEach(callbackfn) {
            validate(this, NAME);
            var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
            var entry;
            while (entry = entry ? entry.n : this._f) {
              f(entry.v, entry.k, this);
              while (entry && entry.r)
                entry = entry.p;
            }
          }, "forEach"),
          has: /* @__PURE__ */ __name(function has(key) {
            return !!getEntry(validate(this, NAME), key);
          }, "has")
        });
        if (DESCRIPTORS)
          dP(C.prototype, "size", {
            get: function() {
              return validate(this, NAME)[SIZE];
            }
          });
        return C;
      },
      def: function(that, key, value) {
        var entry = getEntry(that, key);
        var prev, index;
        if (entry) {
          entry.v = value;
        } else {
          that._l = entry = {
            i: index = fastKey(key, true),
            k: key,
            v: value,
            p: prev = that._l,
            n: void 0,
            r: false
          };
          if (!that._f)
            that._f = entry;
          if (prev)
            prev.n = entry;
          that[SIZE]++;
          if (index !== "F")
            that._i[index] = entry;
        }
        return that;
      },
      getEntry,
      setStrong: function(C, NAME, IS_MAP) {
        $iterDefine(C, NAME, function(iterated, kind) {
          this._t = validate(iterated, NAME);
          this._k = kind;
          this._l = void 0;
        }, function() {
          var that = this;
          var kind = that._k;
          var entry = that._l;
          while (entry && entry.r)
            entry = entry.p;
          if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
            that._t = void 0;
            return step(1);
          }
          if (kind == "keys")
            return step(0, entry.k);
          if (kind == "values")
            return step(0, entry.v);
          return step(0, [entry.k, entry.v]);
        }, IS_MAP ? "entries" : "values", !IS_MAP, true);
        setSpecies(NAME);
      }
    };
  }
});

// node_modules/core-js/library/modules/_array-species-constructor.js
var require_array_species_constructor = __commonJS({
  "node_modules/core-js/library/modules/_array-species-constructor.js"(exports2, module2) {
    var isObject = require_is_object();
    var isArray = require_is_array();
    var SPECIES = require_wks()("species");
    module2.exports = function(original) {
      var C;
      if (isArray(original)) {
        C = original.constructor;
        if (typeof C == "function" && (C === Array || isArray(C.prototype)))
          C = void 0;
        if (isObject(C)) {
          C = C[SPECIES];
          if (C === null)
            C = void 0;
        }
      }
      return C === void 0 ? Array : C;
    };
  }
});

// node_modules/core-js/library/modules/_array-species-create.js
var require_array_species_create = __commonJS({
  "node_modules/core-js/library/modules/_array-species-create.js"(exports2, module2) {
    var speciesConstructor = require_array_species_constructor();
    module2.exports = function(original, length) {
      return new (speciesConstructor(original))(length);
    };
  }
});

// node_modules/core-js/library/modules/_array-methods.js
var require_array_methods = __commonJS({
  "node_modules/core-js/library/modules/_array-methods.js"(exports2, module2) {
    var ctx = require_ctx();
    var IObject = require_iobject();
    var toObject = require_to_object();
    var toLength = require_to_length();
    var asc = require_array_species_create();
    module2.exports = function(TYPE, $create) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      var create = $create || asc;
      return function($this, callbackfn, that) {
        var O = toObject($this);
        var self2 = IObject(O);
        var f = ctx(callbackfn, that, 3);
        var length = toLength(self2.length);
        var index = 0;
        var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
        var val, res;
        for (; length > index; index++)
          if (NO_HOLES || index in self2) {
            val = self2[index];
            res = f(val, index, O);
            if (TYPE) {
              if (IS_MAP)
                result[index] = res;
              else if (res)
                switch (TYPE) {
                  case 3:
                    return true;
                  case 5:
                    return val;
                  case 6:
                    return index;
                  case 2:
                    result.push(val);
                }
              else if (IS_EVERY)
                return false;
            }
          }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
      };
    };
  }
});

// node_modules/core-js/library/modules/_collection.js
var require_collection = __commonJS({
  "node_modules/core-js/library/modules/_collection.js"(exports2, module2) {
    "use strict";
    var global2 = require_global();
    var $export = require_export();
    var meta = require_meta();
    var fails = require_fails();
    var hide = require_hide();
    var redefineAll = require_redefine_all();
    var forOf = require_for_of();
    var anInstance = require_an_instance();
    var isObject = require_is_object();
    var setToStringTag = require_set_to_string_tag();
    var dP = require_object_dp().f;
    var each = require_array_methods()(0);
    var DESCRIPTORS = require_descriptors();
    module2.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
      var Base = global2[NAME];
      var C = Base;
      var ADDER = IS_MAP ? "set" : "add";
      var proto = C && C.prototype;
      var O = {};
      if (!DESCRIPTORS || typeof C != "function" || !(IS_WEAK || proto.forEach && !fails(function() {
        new C().entries().next();
      }))) {
        C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
        redefineAll(C.prototype, methods);
        meta.NEED = true;
      } else {
        C = wrapper(function(target, iterable) {
          anInstance(target, C, NAME, "_c");
          target._c = new Base();
          if (iterable != void 0)
            forOf(iterable, IS_MAP, target[ADDER], target);
        });
        each("add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON".split(","), function(KEY) {
          var IS_ADDER = KEY == "add" || KEY == "set";
          if (KEY in proto && !(IS_WEAK && KEY == "clear"))
            hide(C.prototype, KEY, function(a, b) {
              anInstance(this, C, KEY);
              if (!IS_ADDER && IS_WEAK && !isObject(a))
                return KEY == "get" ? void 0 : false;
              var result = this._c[KEY](a === 0 ? 0 : a, b);
              return IS_ADDER ? this : result;
            });
        });
        IS_WEAK || dP(C.prototype, "size", {
          get: function() {
            return this._c.size;
          }
        });
      }
      setToStringTag(C, NAME);
      O[NAME] = C;
      $export($export.G + $export.W + $export.F, O);
      if (!IS_WEAK)
        common.setStrong(C, NAME, IS_MAP);
      return C;
    };
  }
});

// node_modules/core-js/library/modules/es6.map.js
var require_es6_map = __commonJS({
  "node_modules/core-js/library/modules/es6.map.js"(exports2, module2) {
    "use strict";
    var strong = require_collection_strong();
    var validate = require_validate_collection();
    var MAP = "Map";
    module2.exports = require_collection()(MAP, function(get) {
      return /* @__PURE__ */ __name(function Map2() {
        return get(this, arguments.length > 0 ? arguments[0] : void 0);
      }, "Map");
    }, {
      get: /* @__PURE__ */ __name(function get(key) {
        var entry = strong.getEntry(validate(this, MAP), key);
        return entry && entry.v;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(key, value) {
        return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
      }, "set")
    }, strong, true);
  }
});

// node_modules/core-js/library/modules/_array-from-iterable.js
var require_array_from_iterable = __commonJS({
  "node_modules/core-js/library/modules/_array-from-iterable.js"(exports2, module2) {
    var forOf = require_for_of();
    module2.exports = function(iter, ITERATOR) {
      var result = [];
      forOf(iter, false, result.push, result, ITERATOR);
      return result;
    };
  }
});

// node_modules/core-js/library/modules/_collection-to-json.js
var require_collection_to_json = __commonJS({
  "node_modules/core-js/library/modules/_collection-to-json.js"(exports2, module2) {
    var classof = require_classof();
    var from = require_array_from_iterable();
    module2.exports = function(NAME) {
      return /* @__PURE__ */ __name(function toJSON() {
        if (classof(this) != NAME)
          throw TypeError(NAME + "#toJSON isn't generic");
        return from(this);
      }, "toJSON");
    };
  }
});

// node_modules/core-js/library/modules/es7.map.to-json.js
var require_es7_map_to_json = __commonJS({
  "node_modules/core-js/library/modules/es7.map.to-json.js"() {
    var $export = require_export();
    $export($export.P + $export.R, "Map", { toJSON: require_collection_to_json()("Map") });
  }
});

// node_modules/core-js/library/modules/_set-collection-of.js
var require_set_collection_of = __commonJS({
  "node_modules/core-js/library/modules/_set-collection-of.js"(exports2, module2) {
    "use strict";
    var $export = require_export();
    module2.exports = function(COLLECTION) {
      $export($export.S, COLLECTION, { of: /* @__PURE__ */ __name(function of() {
        var length = arguments.length;
        var A = new Array(length);
        while (length--)
          A[length] = arguments[length];
        return new this(A);
      }, "of") });
    };
  }
});

// node_modules/core-js/library/modules/es7.map.of.js
var require_es7_map_of = __commonJS({
  "node_modules/core-js/library/modules/es7.map.of.js"() {
    require_set_collection_of()("Map");
  }
});

// node_modules/core-js/library/modules/_set-collection-from.js
var require_set_collection_from = __commonJS({
  "node_modules/core-js/library/modules/_set-collection-from.js"(exports2, module2) {
    "use strict";
    var $export = require_export();
    var aFunction = require_a_function();
    var ctx = require_ctx();
    var forOf = require_for_of();
    module2.exports = function(COLLECTION) {
      $export($export.S, COLLECTION, { from: /* @__PURE__ */ __name(function from(source) {
        var mapFn = arguments[1];
        var mapping, A, n3, cb;
        aFunction(this);
        mapping = mapFn !== void 0;
        if (mapping)
          aFunction(mapFn);
        if (source == void 0)
          return new this();
        A = [];
        if (mapping) {
          n3 = 0;
          cb = ctx(mapFn, arguments[2], 2);
          forOf(source, false, function(nextItem) {
            A.push(cb(nextItem, n3++));
          });
        } else {
          forOf(source, false, A.push, A);
        }
        return new this(A);
      }, "from") });
    };
  }
});

// node_modules/core-js/library/modules/es7.map.from.js
var require_es7_map_from = __commonJS({
  "node_modules/core-js/library/modules/es7.map.from.js"() {
    require_set_collection_from()("Map");
  }
});

// node_modules/core-js/library/fn/map.js
var require_map = __commonJS({
  "node_modules/core-js/library/fn/map.js"(exports2, module2) {
    require_es6_object_to_string();
    require_es6_string_iterator();
    require_web_dom_iterable();
    require_es6_map();
    require_es7_map_to_json();
    require_es7_map_of();
    require_es7_map_from();
    module2.exports = require_core4().Map;
  }
});

// node_modules/babel-runtime/core-js/map.js
var require_map2 = __commonJS({
  "node_modules/babel-runtime/core-js/map.js"(exports2, module2) {
    module2.exports = { "default": require_map(), __esModule: true };
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    __name(isString, "isString");
    module2.exports = isString;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    __name(baseTrim, "baseTrim");
    module2.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim = require_baseTrim();
    var isObject = require_isObject();
    var isSymbol = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module2.exports = toNumber;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports2, module2) {
    var toNumber = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    module2.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports2, module2) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    module2.exports = toInteger;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    __name(baseValues, "baseValues");
    module2.exports = baseValues;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys3();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    __name(values, "values");
    module2.exports = values;
  }
});

// node_modules/lodash/includes.js
var require_includes = __commonJS({
  "node_modules/lodash/includes.js"(exports2, module2) {
    var baseIndexOf = require_baseIndexOf();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var toInteger = require_toInteger();
    var values = require_values();
    var nativeMax = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    __name(includes, "includes");
    module2.exports = includes;
  }
});

// node_modules/lodash/_baseRepeat.js
var require_baseRepeat = __commonJS({
  "node_modules/lodash/_baseRepeat.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var nativeFloor = Math.floor;
    function baseRepeat(string, n3) {
      var result = "";
      if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
        return result;
      }
      do {
        if (n3 % 2) {
          result += string;
        }
        n3 = nativeFloor(n3 / 2);
        if (n3) {
          string += string;
        }
      } while (n3);
      return result;
    }
    __name(baseRepeat, "baseRepeat");
    module2.exports = baseRepeat;
  }
});

// node_modules/lodash/repeat.js
var require_repeat = __commonJS({
  "node_modules/lodash/repeat.js"(exports2, module2) {
    var baseRepeat = require_baseRepeat();
    var isIterateeCall = require_isIterateeCall();
    var toInteger = require_toInteger();
    var toString = require_toString();
    function repeat(string, n3, guard) {
      if (guard ? isIterateeCall(string, n3, guard) : n3 === void 0) {
        n3 = 1;
      } else {
        n3 = toInteger(n3);
      }
      return baseRepeat(toString(string), n3);
    }
    __name(repeat, "repeat");
    module2.exports = repeat;
  }
});

// node_modules/babel-traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "node_modules/babel-traverse/lib/scope/binding.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var Binding = function() {
      function Binding2(_ref) {
        var existing = _ref.existing, identifier5 = _ref.identifier, scope = _ref.scope, path2 = _ref.path, kind = _ref.kind;
        (0, _classCallCheck3.default)(this, Binding2);
        this.identifier = identifier5;
        this.scope = scope;
        this.path = path2;
        this.kind = kind;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.clearValue();
        if (existing) {
          this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);
        }
      }
      __name(Binding2, "Binding");
      Binding2.prototype.deoptValue = /* @__PURE__ */ __name(function deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }, "deoptValue");
      Binding2.prototype.setValue = /* @__PURE__ */ __name(function setValue(value) {
        if (this.hasDeoptedValue)
          return;
        this.hasValue = true;
        this.value = value;
      }, "setValue");
      Binding2.prototype.clearValue = /* @__PURE__ */ __name(function clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }, "clearValue");
      Binding2.prototype.reassign = /* @__PURE__ */ __name(function reassign(path2) {
        this.constant = false;
        if (this.constantViolations.indexOf(path2) !== -1) {
          return;
        }
        this.constantViolations.push(path2);
      }, "reassign");
      Binding2.prototype.reference = /* @__PURE__ */ __name(function reference(path2) {
        if (this.referencePaths.indexOf(path2) !== -1) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path2);
      }, "reference");
      Binding2.prototype.dereference = /* @__PURE__ */ __name(function dereference() {
        this.references--;
        this.referenced = !!this.references;
      }, "dereference");
      return Binding2;
    }();
    exports2.default = Binding;
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "node_modules/babel-traverse/lib/scope/lib/renamer.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _binding = require_binding();
    var _binding2 = _interopRequireDefault(_binding);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var renameVisitor = {
      ReferencedIdentifier: /* @__PURE__ */ __name(function ReferencedIdentifier(_ref, state) {
        var node = _ref.node;
        if (node.name === state.oldName) {
          node.name = state.newName;
        }
      }, "ReferencedIdentifier"),
      Scope: /* @__PURE__ */ __name(function Scope(path2, state) {
        if (!path2.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path2.skip();
        }
      }, "Scope"),
      "AssignmentExpression|Declaration": /* @__PURE__ */ __name(function AssignmentExpressionDeclaration(path2, state) {
        var ids = path2.getOuterBindingIdentifiers();
        for (var name in ids) {
          if (name === state.oldName)
            ids[name].name = state.newName;
        }
      }, "AssignmentExpressionDeclaration")
    };
    var Renamer = function() {
      function Renamer2(binding, oldName, newName) {
        (0, _classCallCheck3.default)(this, Renamer2);
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      __name(Renamer2, "Renamer");
      Renamer2.prototype.maybeConvertFromExportDeclaration = /* @__PURE__ */ __name(function maybeConvertFromExportDeclaration(parentDeclar) {
        var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;
        if (!exportDeclar)
          return;
        var isDefault = exportDeclar.isExportDefaultDeclaration();
        if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {
          parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier("default");
        }
        var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();
        var specifiers = [];
        for (var name in bindingIdentifiers) {
          var localName = name === this.oldName ? this.newName : name;
          var exportedName = isDefault ? "default" : name;
          specifiers.push(t5.exportSpecifier(t5.identifier(localName), t5.identifier(exportedName)));
        }
        if (specifiers.length) {
          var aliasDeclar = t5.exportNamedDeclaration(null, specifiers);
          if (parentDeclar.isFunctionDeclaration()) {
            aliasDeclar._blockHoist = 3;
          }
          exportDeclar.insertAfter(aliasDeclar);
          exportDeclar.replaceWith(parentDeclar.node);
        }
      }, "maybeConvertFromExportDeclaration");
      Renamer2.prototype.rename = /* @__PURE__ */ __name(function rename(block) {
        var binding = this.binding, oldName = this.oldName, newName = this.newName;
        var scope = binding.scope, path2 = binding.path;
        var parentDeclar = path2.find(function(path3) {
          return path3.isDeclaration() || path3.isFunctionExpression();
        });
        if (parentDeclar) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
        scope.traverse(block || scope.block, renameVisitor, this);
        if (!block) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (binding.type === "hoisted") {
        }
      }, "rename");
      return Renamer2;
    }();
    exports2.default = Renamer;
    module2.exports = exports2["default"];
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports2, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// node_modules/babel-messages/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/babel-messages/lib/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.MESSAGES = void 0;
    var _stringify = require_stringify2();
    var _stringify2 = _interopRequireDefault(_stringify);
    exports2.get = get;
    exports2.parseArgs = parseArgs;
    var _util = require("util");
    var util = _interopRequireWildcard(_util);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var MESSAGES = exports2.MESSAGES = {
      tailCallReassignmentDeopt: "Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence",
      classesIllegalBareSuper: "Illegal use of bare super",
      classesIllegalSuperCall: "Direct super call is illegal in non-constructor, use super.$1() instead",
      scopeDuplicateDeclaration: "Duplicate declaration $1",
      settersNoRest: "Setters aren't allowed to have a rest",
      noAssignmentsInForHead: "No assignments allowed in for-in/of head",
      expectedMemberExpressionOrIdentifier: "Expected type MemberExpression or Identifier",
      invalidParentForThisNode: "We don't know how to handle this node within the current parent - please open an issue",
      readOnly: "$1 is read-only",
      unknownForHead: "Unknown node type $1 in ForStatement",
      didYouMean: "Did you mean $1?",
      codeGeneratorDeopt: "Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.",
      missingTemplatesDirectory: "no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues",
      unsupportedOutputType: "Unsupported output type $1",
      illegalMethodName: "Illegal method name $1",
      lostTrackNodePath: "We lost track of this node's position, likely because the AST was directly manipulated",
      modulesIllegalExportName: "Illegal export $1",
      modulesDuplicateDeclarations: "Duplicate module declarations with the same source but in different scopes",
      undeclaredVariable: "Reference to undeclared variable $1",
      undeclaredVariableType: "Referencing a type alias outside of a type annotation",
      undeclaredVariableSuggestion: "Reference to undeclared variable $1 - did you mean $2?",
      traverseNeedsParent: "You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a $1 node without passing scope and parentPath.",
      traverseVerifyRootFunction: "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?",
      traverseVerifyVisitorProperty: "You passed `traverse()` a visitor object with the property $1 that has the invalid property $2",
      traverseVerifyNodeType: "You gave us a visitor for the node type $1 but it's not a valid type",
      pluginNotObject: "Plugin $2 specified in $1 was expected to return an object when invoked but returned $3",
      pluginNotFunction: "Plugin $2 specified in $1 was expected to return a function but returned $3",
      pluginUnknown: "Unknown plugin $1 specified in $2 at $3, attempted to resolve relative to $4",
      pluginInvalidProperty: "Plugin $2 specified in $1 provided an invalid property of $3"
    };
    function get(key) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var msg = MESSAGES[key];
      if (!msg)
        throw new ReferenceError("Unknown message " + (0, _stringify2.default)(key));
      args = parseArgs(args);
      return msg.replace(/\$(\d+)/g, function(str, i) {
        return args[i - 1];
      });
    }
    __name(get, "get");
    function parseArgs(args) {
      return args.map(function(val) {
        if (val != null && val.inspect) {
          return val.inspect();
        } else {
          try {
            return (0, _stringify2.default)(val) || val + "";
          } catch (e) {
            return util.inspect(val);
          }
        }
      });
    }
    __name(parseArgs, "parseArgs");
  }
});

// node_modules/globals/globals.json
var require_globals = __commonJS({
  "node_modules/globals/globals.json"(exports2, module2) {
    module2.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        System: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es6: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        System: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AutocompleteErrorEvent: false,
        BarProp: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        blur: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        CDATASection: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClientRect: false,
        ClientRectList: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConvolverNode: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSAnimation: false,
        CSSFontFaceRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CSSTransition: false,
        CSSUnknownRule: false,
        CSSViewportRule: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        Debug: false,
        defaultStatus: false,
        defaultstatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentTimeline: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMParser: false,
        DOMSettableTokenList: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ElementTimeControl: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        FederatedCredential: false,
        fetch: false,
        File: false,
        FileError: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAppletElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBlockquoteElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLIsIndexElement: false,
        HTMLKeygenElement: false,
        HTMLLabelElement: false,
        HTMLLayerElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBEnvironment: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        Image: false,
        ImageBitmap: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        InputMethodContext: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: false,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyError: false,
        MediaKeyEvent: false,
        MediaKeyMessageEvent: false,
        MediaKeys: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaSource: false,
        MediaRecorder: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        navigator: false,
        Navigator: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        onbeforeunload: true,
        onblur: true,
        onerror: true,
        onfocus: true,
        onload: true,
        onresize: true,
        onunload: true,
        open: false,
        openDatabase: false,
        opener: false,
        opera: false,
        Option: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        parent: false,
        PasswordCredential: false,
        Path2D: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        Plugin: false,
        PluginArray: false,
        PopStateEvent: false,
        postMessage: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        RadioNodeList: false,
        Range: false,
        ReadableByteStream: false,
        ReadableStream: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        resizeTo: false,
        Response: false,
        RTCIceCandidate: false,
        RTCSessionDescription: false,
        RTCPeerConnection: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedKeyframeList: false,
        SharedWorker: false,
        showModalDialog: false,
        SiteBoundCredential: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        status: false,
        statusbar: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAltGlyphDefElement: false,
        SVGAltGlyphElement: false,
        SVGAltGlyphItemElement: false,
        SVGAngle: false,
        SVGAnimateColorElement: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPathData: false,
        SVGAnimatedPoints: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGColor: false,
        SVGColorProfileElement: false,
        SVGColorProfileRule: false,
        SVGComponentTransferFunctionElement: false,
        SVGCSSRule: false,
        SVGCursorElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGDocument: false,
        SVGElement: false,
        SVGElementInstance: false,
        SVGElementInstanceList: false,
        SVGEllipseElement: false,
        SVGEvent: false,
        SVGExternalResourcesRequired: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGFilterPrimitiveStandardAttributes: false,
        SVGFitToViewBox: false,
        SVGFontElement: false,
        SVGFontFaceElement: false,
        SVGFontFaceFormatElement: false,
        SVGFontFaceNameElement: false,
        SVGFontFaceSrcElement: false,
        SVGFontFaceUriElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGlyphElement: false,
        SVGGlyphRefElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGHKernElement: false,
        SVGICCColor: false,
        SVGImageElement: false,
        SVGLangSpace: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGLocatable: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMissingGlyphElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPaint: false,
        SVGPathElement: false,
        SVGPathSeg: false,
        SVGPathSegArcAbs: false,
        SVGPathSegArcRel: false,
        SVGPathSegClosePath: false,
        SVGPathSegCurvetoCubicAbs: false,
        SVGPathSegCurvetoCubicRel: false,
        SVGPathSegCurvetoCubicSmoothAbs: false,
        SVGPathSegCurvetoCubicSmoothRel: false,
        SVGPathSegCurvetoQuadraticAbs: false,
        SVGPathSegCurvetoQuadraticRel: false,
        SVGPathSegCurvetoQuadraticSmoothAbs: false,
        SVGPathSegCurvetoQuadraticSmoothRel: false,
        SVGPathSegLinetoAbs: false,
        SVGPathSegLinetoHorizontalAbs: false,
        SVGPathSegLinetoHorizontalRel: false,
        SVGPathSegLinetoRel: false,
        SVGPathSegLinetoVerticalAbs: false,
        SVGPathSegLinetoVerticalRel: false,
        SVGPathSegList: false,
        SVGPathSegMovetoAbs: false,
        SVGPathSegMovetoRel: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGRenderingIntent: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStylable: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTests: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformable: false,
        SVGTransformList: false,
        SVGTRefElement: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGURIReference: false,
        SVGUseElement: false,
        SVGViewElement: false,
        SVGViewSpec: false,
        SVGVKernElement: false,
        SVGZoomAndPan: false,
        SVGZoomEvent: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeEvent: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLTexture: false,
        WebGLUniformLocation: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        XDomainRequest: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestProgressEvent: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathException: false,
        XPathExpression: false,
        XPathNamespace: false,
        XPathNSResolver: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        arguments: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        GLOBAL: false,
        global: false,
        Intl: false,
        module: false,
        process: false,
        require: false,
        root: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false
      },
      commonjs: {
        exports: true,
        module: false,
        require: false,
        global: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        check: false,
        describe: false,
        expect: false,
        gen: false,
        it: false,
        fdescribe: false,
        fit: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        Java: false,
        java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        Y: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ls: false,
        ln: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        $: false,
        _: false,
        Accounts: false,
        AccountsClient: false,
        AccountsServer: false,
        AccountsCommon: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPServer: false,
        DDPRateLimiter: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        caches: false,
        Cache: false,
        CacheStorage: false,
        Client: false,
        clients: false,
        Clients: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        FetchEvent: false,
        importScripts: false,
        registration: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        skipWaiting: false,
        WindowClient: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        By: false,
        by: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      }
    };
  }
});

// node_modules/globals/index.js
var require_globals2 = __commonJS({
  "node_modules/globals/index.js"(exports2, module2) {
    module2.exports = require_globals();
  }
});

// node_modules/core-js/library/modules/_object-assign.js
var require_object_assign = __commonJS({
  "node_modules/core-js/library/modules/_object-assign.js"(exports2, module2) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var getKeys = require_object_keys();
    var gOPS = require_object_gops();
    var pIE = require_object_pie();
    var toObject = require_to_object();
    var IObject = require_iobject();
    var $assign = Object.assign;
    module2.exports = !$assign || require_fails()(function() {
      var A = {};
      var B = {};
      var S = Symbol();
      var K = "abcdefghijklmnopqrst";
      A[S] = 7;
      K.split("").forEach(function(k) {
        B[k] = k;
      });
      return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join("") != K;
    }) ? /* @__PURE__ */ __name(function assign(target, source) {
      var T = toObject(target);
      var aLen = arguments.length;
      var index = 1;
      var getSymbols = gOPS.f;
      var isEnum = pIE.f;
      while (aLen > index) {
        var S = IObject(arguments[index++]);
        var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while (length > j) {
          key = keys[j++];
          if (!DESCRIPTORS || isEnum.call(S, key))
            T[key] = S[key];
        }
      }
      return T;
    }, "assign") : $assign;
  }
});

// node_modules/core-js/library/modules/_collection-weak.js
var require_collection_weak = __commonJS({
  "node_modules/core-js/library/modules/_collection-weak.js"(exports2, module2) {
    "use strict";
    var redefineAll = require_redefine_all();
    var getWeak = require_meta().getWeak;
    var anObject = require_an_object();
    var isObject = require_is_object();
    var anInstance = require_an_instance();
    var forOf = require_for_of();
    var createArrayMethod = require_array_methods();
    var $has = require_has();
    var validate = require_validate_collection();
    var arrayFind = createArrayMethod(5);
    var arrayFindIndex = createArrayMethod(6);
    var id = 0;
    var uncaughtFrozenStore = /* @__PURE__ */ __name(function(that) {
      return that._l || (that._l = new UncaughtFrozenStore());
    }, "uncaughtFrozenStore");
    var UncaughtFrozenStore = /* @__PURE__ */ __name(function() {
      this.a = [];
    }, "UncaughtFrozenStore");
    var findUncaughtFrozen = /* @__PURE__ */ __name(function(store, key) {
      return arrayFind(store.a, function(it) {
        return it[0] === key;
      });
    }, "findUncaughtFrozen");
    UncaughtFrozenStore.prototype = {
      get: function(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          return entry[1];
      },
      has: function(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry)
          entry[1] = value;
        else
          this.a.push([key, value]);
      },
      "delete": function(key) {
        var index = arrayFindIndex(this.a, function(it) {
          return it[0] === key;
        });
        if (~index)
          this.a.splice(index, 1);
        return !!~index;
      }
    };
    module2.exports = {
      getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
        var C = wrapper(function(that, iterable) {
          anInstance(that, C, NAME, "_i");
          that._t = NAME;
          that._i = id++;
          that._l = void 0;
          if (iterable != void 0)
            forOf(iterable, IS_MAP, that[ADDER], that);
        });
        redefineAll(C.prototype, {
          "delete": function(key) {
            if (!isObject(key))
              return false;
            var data = getWeak(key);
            if (data === true)
              return uncaughtFrozenStore(validate(this, NAME))["delete"](key);
            return data && $has(data, this._i) && delete data[this._i];
          },
          has: /* @__PURE__ */ __name(function has(key) {
            if (!isObject(key))
              return false;
            var data = getWeak(key);
            if (data === true)
              return uncaughtFrozenStore(validate(this, NAME)).has(key);
            return data && $has(data, this._i);
          }, "has")
        });
        return C;
      },
      def: function(that, key, value) {
        var data = getWeak(anObject(key), true);
        if (data === true)
          uncaughtFrozenStore(that).set(key, value);
        else
          data[that._i] = value;
        return that;
      },
      ufstore: uncaughtFrozenStore
    };
  }
});

// node_modules/core-js/library/modules/es6.weak-map.js
var require_es6_weak_map = __commonJS({
  "node_modules/core-js/library/modules/es6.weak-map.js"(exports2, module2) {
    "use strict";
    var global2 = require_global();
    var each = require_array_methods()(0);
    var redefine = require_redefine();
    var meta = require_meta();
    var assign = require_object_assign();
    var weak = require_collection_weak();
    var isObject = require_is_object();
    var validate = require_validate_collection();
    var NATIVE_WEAK_MAP = require_validate_collection();
    var IS_IE11 = !global2.ActiveXObject && "ActiveXObject" in global2;
    var WEAK_MAP = "WeakMap";
    var getWeak = meta.getWeak;
    var isExtensible = Object.isExtensible;
    var uncaughtFrozenStore = weak.ufstore;
    var InternalMap;
    var wrapper = /* @__PURE__ */ __name(function(get) {
      return /* @__PURE__ */ __name(function WeakMap() {
        return get(this, arguments.length > 0 ? arguments[0] : void 0);
      }, "WeakMap");
    }, "wrapper");
    var methods = {
      get: /* @__PURE__ */ __name(function get(key) {
        if (isObject(key)) {
          var data = getWeak(key);
          if (data === true)
            return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
          return data ? data[this._i] : void 0;
        }
      }, "get"),
      set: /* @__PURE__ */ __name(function set(key, value) {
        return weak.def(validate(this, WEAK_MAP), key, value);
      }, "set")
    };
    var $WeakMap = module2.exports = require_collection()(WEAK_MAP, wrapper, methods, weak, true, true);
    if (NATIVE_WEAK_MAP && IS_IE11) {
      InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
      assign(InternalMap.prototype, methods);
      meta.NEED = true;
      each(["delete", "has", "get", "set"], function(key) {
        var proto = $WeakMap.prototype;
        var method = proto[key];
        redefine(proto, key, function(a, b) {
          if (isObject(a) && !isExtensible(a)) {
            if (!this._f)
              this._f = new InternalMap();
            var result = this._f[key](a, b);
            return key == "set" ? this : result;
          }
          return method.call(this, a, b);
        });
      });
    }
  }
});

// node_modules/core-js/library/modules/es7.weak-map.of.js
var require_es7_weak_map_of = __commonJS({
  "node_modules/core-js/library/modules/es7.weak-map.of.js"() {
    require_set_collection_of()("WeakMap");
  }
});

// node_modules/core-js/library/modules/es7.weak-map.from.js
var require_es7_weak_map_from = __commonJS({
  "node_modules/core-js/library/modules/es7.weak-map.from.js"() {
    require_set_collection_from()("WeakMap");
  }
});

// node_modules/core-js/library/fn/weak-map.js
var require_weak_map = __commonJS({
  "node_modules/core-js/library/fn/weak-map.js"(exports2, module2) {
    require_es6_object_to_string();
    require_web_dom_iterable();
    require_es6_weak_map();
    require_es7_weak_map_of();
    require_es7_weak_map_from();
    module2.exports = require_core4().WeakMap;
  }
});

// node_modules/babel-runtime/core-js/weak-map.js
var require_weak_map2 = __commonJS({
  "node_modules/babel-runtime/core-js/weak-map.js"(exports2, module2) {
    module2.exports = { "default": require_weak_map(), __esModule: true };
  }
});

// node_modules/babel-traverse/lib/cache.js
var require_cache = __commonJS({
  "node_modules/babel-traverse/lib/cache.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.scope = exports2.path = void 0;
    var _weakMap = require_weak_map2();
    var _weakMap2 = _interopRequireDefault(_weakMap);
    exports2.clear = clear;
    exports2.clearPath = clearPath;
    exports2.clearScope = clearScope;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var path2 = exports2.path = new _weakMap2.default();
    var scope = exports2.scope = new _weakMap2.default();
    function clear() {
      clearPath();
      clearScope();
    }
    __name(clear, "clear");
    function clearPath() {
      exports2.path = path2 = new _weakMap2.default();
    }
    __name(clearPath, "clearPath");
    function clearScope() {
      exports2.scope = scope = new _weakMap2.default();
    }
    __name(clearScope, "clearScope");
  }
});

// node_modules/babel-traverse/lib/scope/index.js
var require_scope = __commonJS({
  "node_modules/babel-traverse/lib/scope/index.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _keys = require_keys2();
    var _keys2 = _interopRequireDefault(_keys);
    var _create = require_create2();
    var _create2 = _interopRequireDefault(_create);
    var _map = require_map2();
    var _map2 = _interopRequireDefault(_map);
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _includes = require_includes();
    var _includes2 = _interopRequireDefault(_includes);
    var _repeat = require_repeat();
    var _repeat2 = _interopRequireDefault(_repeat);
    var _renamer = require_renamer();
    var _renamer2 = _interopRequireDefault(_renamer);
    var _index = require_lib7();
    var _index2 = _interopRequireDefault(_index);
    var _defaults = require_defaults();
    var _defaults2 = _interopRequireDefault(_defaults);
    var _babelMessages = require_lib4();
    var messages = _interopRequireWildcard(_babelMessages);
    var _binding2 = require_binding();
    var _binding3 = _interopRequireDefault(_binding2);
    var _globals = require_globals2();
    var _globals2 = _interopRequireDefault(_globals);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    var _cache = require_cache();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _crawlCallsCount = 0;
    function getCache(path2, parentScope, self2) {
      var scopes = _cache.scope.get(path2.node) || [];
      for (var _iterator = scopes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var scope = _ref;
        if (scope.parent === parentScope && scope.path === path2)
          return scope;
      }
      scopes.push(self2);
      if (!_cache.scope.has(path2.node)) {
        _cache.scope.set(path2.node, scopes);
      }
    }
    __name(getCache, "getCache");
    function gatherNodeParts(node, parts) {
      if (t5.isModuleDeclaration(node)) {
        if (node.source) {
          gatherNodeParts(node.source, parts);
        } else if (node.specifiers && node.specifiers.length) {
          for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var specifier = _ref2;
            gatherNodeParts(specifier, parts);
          }
        } else if (node.declaration) {
          gatherNodeParts(node.declaration, parts);
        }
      } else if (t5.isModuleSpecifier(node)) {
        gatherNodeParts(node.local, parts);
      } else if (t5.isMemberExpression(node)) {
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
      } else if (t5.isIdentifier(node)) {
        parts.push(node.name);
      } else if (t5.isLiteral(node)) {
        parts.push(node.value);
      } else if (t5.isCallExpression(node)) {
        gatherNodeParts(node.callee, parts);
      } else if (t5.isObjectExpression(node) || t5.isObjectPattern(node)) {
        for (var _iterator3 = node.properties, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var prop = _ref3;
          gatherNodeParts(prop.key || prop.argument, parts);
        }
      }
    }
    __name(gatherNodeParts, "gatherNodeParts");
    var collectorVisitor = {
      For: /* @__PURE__ */ __name(function For(path2) {
        for (var _iterator4 = t5.FOR_INIT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4); ; ) {
          var _ref4;
          if (_isArray4) {
            if (_i4 >= _iterator4.length)
              break;
            _ref4 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done)
              break;
            _ref4 = _i4.value;
          }
          var key = _ref4;
          var declar = path2.get(key);
          if (declar.isVar())
            path2.scope.getFunctionParent().registerBinding("var", declar);
        }
      }, "For"),
      Declaration: /* @__PURE__ */ __name(function Declaration2(path2) {
        if (path2.isBlockScoped())
          return;
        if (path2.isExportDeclaration() && path2.get("declaration").isDeclaration())
          return;
        path2.scope.getFunctionParent().registerDeclaration(path2);
      }, "Declaration"),
      ReferencedIdentifier: /* @__PURE__ */ __name(function ReferencedIdentifier(path2, state) {
        state.references.push(path2);
      }, "ReferencedIdentifier"),
      ForXStatement: /* @__PURE__ */ __name(function ForXStatement(path2, state) {
        var left = path2.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(left);
        }
      }, "ForXStatement"),
      ExportDeclaration: {
        exit: /* @__PURE__ */ __name(function exit(path2) {
          var node = path2.node, scope = path2.scope;
          var declar = node.declaration;
          if (t5.isClassDeclaration(declar) || t5.isFunctionDeclaration(declar)) {
            var _id = declar.id;
            if (!_id)
              return;
            var binding = scope.getBinding(_id.name);
            if (binding)
              binding.reference(path2);
          } else if (t5.isVariableDeclaration(declar)) {
            for (var _iterator5 = declar.declarations, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5); ; ) {
              var _ref5;
              if (_isArray5) {
                if (_i5 >= _iterator5.length)
                  break;
                _ref5 = _iterator5[_i5++];
              } else {
                _i5 = _iterator5.next();
                if (_i5.done)
                  break;
                _ref5 = _i5.value;
              }
              var decl = _ref5;
              var ids = t5.getBindingIdentifiers(decl);
              for (var name in ids) {
                var _binding = scope.getBinding(name);
                if (_binding)
                  _binding.reference(path2);
              }
            }
          }
        }, "exit")
      },
      LabeledStatement: /* @__PURE__ */ __name(function LabeledStatement(path2) {
        path2.scope.getProgramParent().addGlobal(path2.node);
        path2.scope.getBlockParent().registerDeclaration(path2);
      }, "LabeledStatement"),
      AssignmentExpression: /* @__PURE__ */ __name(function AssignmentExpression(path2, state) {
        state.assignments.push(path2);
      }, "AssignmentExpression"),
      UpdateExpression: /* @__PURE__ */ __name(function UpdateExpression(path2, state) {
        state.constantViolations.push(path2.get("argument"));
      }, "UpdateExpression"),
      UnaryExpression: /* @__PURE__ */ __name(function UnaryExpression2(path2, state) {
        if (path2.node.operator === "delete") {
          state.constantViolations.push(path2.get("argument"));
        }
      }, "UnaryExpression"),
      BlockScoped: /* @__PURE__ */ __name(function BlockScoped(path2) {
        var scope = path2.scope;
        if (scope.path === path2)
          scope = scope.parent;
        scope.getBlockParent().registerDeclaration(path2);
      }, "BlockScoped"),
      ClassDeclaration: /* @__PURE__ */ __name(function ClassDeclaration(path2) {
        var id = path2.node.id;
        if (!id)
          return;
        var name = id.name;
        path2.scope.bindings[name] = path2.scope.getBinding(name);
      }, "ClassDeclaration"),
      Block: /* @__PURE__ */ __name(function Block(path2) {
        var paths = path2.get("body");
        for (var _iterator6 = paths, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6); ; ) {
          var _ref6;
          if (_isArray6) {
            if (_i6 >= _iterator6.length)
              break;
            _ref6 = _iterator6[_i6++];
          } else {
            _i6 = _iterator6.next();
            if (_i6.done)
              break;
            _ref6 = _i6.value;
          }
          var bodyPath = _ref6;
          if (bodyPath.isFunctionDeclaration()) {
            path2.scope.getBlockParent().registerDeclaration(bodyPath);
          }
        }
      }, "Block")
    };
    var uid = 0;
    var Scope = function() {
      function Scope2(path2, parentScope) {
        (0, _classCallCheck3.default)(this, Scope2);
        if (parentScope && parentScope.block === path2.node) {
          return parentScope;
        }
        var cached = getCache(path2, parentScope, this);
        if (cached)
          return cached;
        this.uid = uid++;
        this.parent = parentScope;
        this.hub = path2.hub;
        this.parentBlock = path2.parent;
        this.block = path2.node;
        this.path = path2;
        this.labels = new _map2.default();
      }
      __name(Scope2, "Scope");
      Scope2.prototype.traverse = /* @__PURE__ */ __name(function traverse2(node, opts, state) {
        (0, _index2.default)(node, opts, this, state, this.path);
      }, "traverse");
      Scope2.prototype.generateDeclaredUidIdentifier = /* @__PURE__ */ __name(function generateDeclaredUidIdentifier() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "temp";
        var id = this.generateUidIdentifier(name);
        this.push({ id });
        return id;
      }, "generateDeclaredUidIdentifier");
      Scope2.prototype.generateUidIdentifier = /* @__PURE__ */ __name(function generateUidIdentifier() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "temp";
        return t5.identifier(this.generateUid(name));
      }, "generateUidIdentifier");
      Scope2.prototype.generateUid = /* @__PURE__ */ __name(function generateUid() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "temp";
        name = t5.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
        var uid2 = void 0;
        var i = 0;
        do {
          uid2 = this._generateUid(name, i);
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        var program = this.getProgramParent();
        program.references[uid2] = true;
        program.uids[uid2] = true;
        return uid2;
      }, "generateUid");
      Scope2.prototype._generateUid = /* @__PURE__ */ __name(function _generateUid(name, i) {
        var id = name;
        if (i > 1)
          id += i;
        return "_" + id;
      }, "_generateUid");
      Scope2.prototype.generateUidIdentifierBasedOnNode = /* @__PURE__ */ __name(function generateUidIdentifierBasedOnNode(parent, defaultName) {
        var node = parent;
        if (t5.isAssignmentExpression(parent)) {
          node = parent.left;
        } else if (t5.isVariableDeclarator(parent)) {
          node = parent.id;
        } else if (t5.isObjectProperty(node) || t5.isObjectMethod(node)) {
          node = node.key;
        }
        var parts = [];
        gatherNodeParts(node, parts);
        var id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUidIdentifier(id.slice(0, 20));
      }, "generateUidIdentifierBasedOnNode");
      Scope2.prototype.isStatic = /* @__PURE__ */ __name(function isStatic(node) {
        if (t5.isThisExpression(node) || t5.isSuper(node)) {
          return true;
        }
        if (t5.isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }, "isStatic");
      Scope2.prototype.maybeGenerateMemoised = /* @__PURE__ */ __name(function maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          var _id2 = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush)
            this.push({ id: _id2 });
          return _id2;
        }
      }, "maybeGenerateMemoised");
      Scope2.prototype.checkBlockScopedCollisions = /* @__PURE__ */ __name(function checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param")
          return;
        if (kind === "hoisted" && local.kind === "let")
          return;
        var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");
        if (duplicate) {
          throw this.hub.file.buildCodeFrameError(id, messages.get("scopeDuplicateDeclaration", name), TypeError);
        }
      }, "checkBlockScopedCollisions");
      Scope2.prototype.rename = /* @__PURE__ */ __name(function rename(oldName, newName, block) {
        var binding = this.getBinding(oldName);
        if (binding) {
          newName = newName || this.generateUidIdentifier(oldName).name;
          return new _renamer2.default(binding, oldName, newName).rename(block);
        }
      }, "rename");
      Scope2.prototype._renameFromMap = /* @__PURE__ */ __name(function _renameFromMap(map, oldName, newName, value) {
        if (map[oldName]) {
          map[newName] = value;
          map[oldName] = null;
        }
      }, "_renameFromMap");
      Scope2.prototype.dump = /* @__PURE__ */ __name(function dump() {
        var sep = (0, _repeat2.default)("-", 60);
        console.log(sep);
        var scope = this;
        do {
          console.log("#", scope.block.type);
          for (var name in scope.bindings) {
            var binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }, "dump");
      Scope2.prototype.toArray = /* @__PURE__ */ __name(function toArray(node, i) {
        var file = this.hub.file;
        if (t5.isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (binding && binding.constant && binding.path.isGenericType("Array"))
            return node;
        }
        if (t5.isArrayExpression(node)) {
          return node;
        }
        if (t5.isIdentifier(node, { name: "arguments" })) {
          return t5.callExpression(t5.memberExpression(t5.memberExpression(t5.memberExpression(t5.identifier("Array"), t5.identifier("prototype")), t5.identifier("slice")), t5.identifier("call")), [node]);
        }
        var helperName = "toArray";
        var args = [node];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (i) {
          args.push(t5.numericLiteral(i));
          helperName = "slicedToArray";
        }
        return t5.callExpression(file.addHelper(helperName), args);
      }, "toArray");
      Scope2.prototype.hasLabel = /* @__PURE__ */ __name(function hasLabel(name) {
        return !!this.getLabel(name);
      }, "hasLabel");
      Scope2.prototype.getLabel = /* @__PURE__ */ __name(function getLabel(name) {
        return this.labels.get(name);
      }, "getLabel");
      Scope2.prototype.registerLabel = /* @__PURE__ */ __name(function registerLabel(path2) {
        this.labels.set(path2.node.label.name, path2);
      }, "registerLabel");
      Scope2.prototype.registerDeclaration = /* @__PURE__ */ __name(function registerDeclaration(path2) {
        if (path2.isLabeledStatement()) {
          this.registerLabel(path2);
        } else if (path2.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path2.get("id"), path2);
        } else if (path2.isVariableDeclaration()) {
          var declarations = path2.get("declarations");
          for (var _iterator7 = declarations, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7); ; ) {
            var _ref7;
            if (_isArray7) {
              if (_i7 >= _iterator7.length)
                break;
              _ref7 = _iterator7[_i7++];
            } else {
              _i7 = _iterator7.next();
              if (_i7.done)
                break;
              _ref7 = _i7.value;
            }
            var declar = _ref7;
            this.registerBinding(path2.node.kind, declar);
          }
        } else if (path2.isClassDeclaration()) {
          this.registerBinding("let", path2);
        } else if (path2.isImportDeclaration()) {
          var specifiers = path2.get("specifiers");
          for (var _iterator8 = specifiers, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8); ; ) {
            var _ref8;
            if (_isArray8) {
              if (_i8 >= _iterator8.length)
                break;
              _ref8 = _iterator8[_i8++];
            } else {
              _i8 = _iterator8.next();
              if (_i8.done)
                break;
              _ref8 = _i8.value;
            }
            var specifier = _ref8;
            this.registerBinding("module", specifier);
          }
        } else if (path2.isExportDeclaration()) {
          var _declar = path2.get("declaration");
          if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
            this.registerDeclaration(_declar);
          }
        } else {
          this.registerBinding("unknown", path2);
        }
      }, "registerDeclaration");
      Scope2.prototype.buildUndefinedNode = /* @__PURE__ */ __name(function buildUndefinedNode() {
        if (this.hasBinding("undefined")) {
          return t5.unaryExpression("void", t5.numericLiteral(0), true);
        } else {
          return t5.identifier("undefined");
        }
      }, "buildUndefinedNode");
      Scope2.prototype.registerConstantViolation = /* @__PURE__ */ __name(function registerConstantViolation(path2) {
        var ids = path2.getBindingIdentifiers();
        for (var name in ids) {
          var binding = this.getBinding(name);
          if (binding)
            binding.reassign(path2);
        }
      }, "registerConstantViolation");
      Scope2.prototype.registerBinding = /* @__PURE__ */ __name(function registerBinding(kind, path2) {
        var bindingPath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : path2;
        if (!kind)
          throw new ReferenceError("no `kind`");
        if (path2.isVariableDeclaration()) {
          var declarators = path2.get("declarations");
          for (var _iterator9 = declarators, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9); ; ) {
            var _ref9;
            if (_isArray9) {
              if (_i9 >= _iterator9.length)
                break;
              _ref9 = _iterator9[_i9++];
            } else {
              _i9 = _iterator9.next();
              if (_i9.done)
                break;
              _ref9 = _i9.value;
            }
            var declar = _ref9;
            this.registerBinding(kind, declar);
          }
          return;
        }
        var parent = this.getProgramParent();
        var ids = path2.getBindingIdentifiers(true);
        for (var name in ids) {
          for (var _iterator10 = ids[name], _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10); ; ) {
            var _ref10;
            if (_isArray10) {
              if (_i10 >= _iterator10.length)
                break;
              _ref10 = _iterator10[_i10++];
            } else {
              _i10 = _iterator10.next();
              if (_i10.done)
                break;
              _ref10 = _i10.value;
            }
            var _id3 = _ref10;
            var local = this.getOwnBinding(name);
            if (local) {
              if (local.identifier === _id3)
                continue;
              this.checkBlockScopedCollisions(local, kind, name, _id3);
            }
            if (local && local.path.isFlow())
              local = null;
            parent.references[name] = true;
            this.bindings[name] = new _binding3.default({
              identifier: _id3,
              existing: local,
              scope: this,
              path: bindingPath,
              kind
            });
          }
        }
      }, "registerBinding");
      Scope2.prototype.addGlobal = /* @__PURE__ */ __name(function addGlobal(node) {
        this.globals[node.name] = node;
      }, "addGlobal");
      Scope2.prototype.hasUid = /* @__PURE__ */ __name(function hasUid(name) {
        var scope = this;
        do {
          if (scope.uids[name])
            return true;
        } while (scope = scope.parent);
        return false;
      }, "hasUid");
      Scope2.prototype.hasGlobal = /* @__PURE__ */ __name(function hasGlobal(name) {
        var scope = this;
        do {
          if (scope.globals[name])
            return true;
        } while (scope = scope.parent);
        return false;
      }, "hasGlobal");
      Scope2.prototype.hasReference = /* @__PURE__ */ __name(function hasReference(name) {
        var scope = this;
        do {
          if (scope.references[name])
            return true;
        } while (scope = scope.parent);
        return false;
      }, "hasReference");
      Scope2.prototype.isPure = /* @__PURE__ */ __name(function isPure(node, constantsOnly) {
        if (t5.isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (!binding)
            return false;
          if (constantsOnly)
            return binding.constant;
          return true;
        } else if (t5.isClass(node)) {
          if (node.superClass && !this.isPure(node.superClass, constantsOnly))
            return false;
          return this.isPure(node.body, constantsOnly);
        } else if (t5.isClassBody(node)) {
          for (var _iterator11 = node.body, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : (0, _getIterator3.default)(_iterator11); ; ) {
            var _ref11;
            if (_isArray11) {
              if (_i11 >= _iterator11.length)
                break;
              _ref11 = _iterator11[_i11++];
            } else {
              _i11 = _iterator11.next();
              if (_i11.done)
                break;
              _ref11 = _i11.value;
            }
            var method = _ref11;
            if (!this.isPure(method, constantsOnly))
              return false;
          }
          return true;
        } else if (t5.isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (t5.isArrayExpression(node)) {
          for (var _iterator12 = node.elements, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : (0, _getIterator3.default)(_iterator12); ; ) {
            var _ref12;
            if (_isArray12) {
              if (_i12 >= _iterator12.length)
                break;
              _ref12 = _iterator12[_i12++];
            } else {
              _i12 = _iterator12.next();
              if (_i12.done)
                break;
              _ref12 = _i12.value;
            }
            var elem = _ref12;
            if (!this.isPure(elem, constantsOnly))
              return false;
          }
          return true;
        } else if (t5.isObjectExpression(node)) {
          for (var _iterator13 = node.properties, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : (0, _getIterator3.default)(_iterator13); ; ) {
            var _ref13;
            if (_isArray13) {
              if (_i13 >= _iterator13.length)
                break;
              _ref13 = _iterator13[_i13++];
            } else {
              _i13 = _iterator13.next();
              if (_i13.done)
                break;
              _ref13 = _i13.value;
            }
            var prop = _ref13;
            if (!this.isPure(prop, constantsOnly))
              return false;
          }
          return true;
        } else if (t5.isClassMethod(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          if (node.kind === "get" || node.kind === "set")
            return false;
          return true;
        } else if (t5.isClassProperty(node) || t5.isObjectProperty(node)) {
          if (node.computed && !this.isPure(node.key, constantsOnly))
            return false;
          return this.isPure(node.value, constantsOnly);
        } else if (t5.isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else {
          return t5.isPureish(node);
        }
      }, "isPure");
      Scope2.prototype.setData = /* @__PURE__ */ __name(function setData(key, val) {
        return this.data[key] = val;
      }, "setData");
      Scope2.prototype.getData = /* @__PURE__ */ __name(function getData(key) {
        var scope = this;
        do {
          var data = scope.data[key];
          if (data != null)
            return data;
        } while (scope = scope.parent);
      }, "getData");
      Scope2.prototype.removeData = /* @__PURE__ */ __name(function removeData(key) {
        var scope = this;
        do {
          var data = scope.data[key];
          if (data != null)
            scope.data[key] = null;
        } while (scope = scope.parent);
      }, "removeData");
      Scope2.prototype.init = /* @__PURE__ */ __name(function init() {
        if (!this.references)
          this.crawl();
      }, "init");
      Scope2.prototype.crawl = /* @__PURE__ */ __name(function crawl() {
        _crawlCallsCount++;
        this._crawl();
        _crawlCallsCount--;
      }, "crawl");
      Scope2.prototype._crawl = /* @__PURE__ */ __name(function _crawl() {
        var path2 = this.path;
        this.references = (0, _create2.default)(null);
        this.bindings = (0, _create2.default)(null);
        this.globals = (0, _create2.default)(null);
        this.uids = (0, _create2.default)(null);
        this.data = (0, _create2.default)(null);
        if (path2.isLoop()) {
          for (var _iterator14 = t5.FOR_INIT_KEYS, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : (0, _getIterator3.default)(_iterator14); ; ) {
            var _ref14;
            if (_isArray14) {
              if (_i14 >= _iterator14.length)
                break;
              _ref14 = _iterator14[_i14++];
            } else {
              _i14 = _iterator14.next();
              if (_i14.done)
                break;
              _ref14 = _i14.value;
            }
            var key = _ref14;
            var node = path2.get(key);
            if (node.isBlockScoped())
              this.registerBinding(node.node.kind, node);
          }
        }
        if (path2.isFunctionExpression() && path2.has("id")) {
          if (!path2.get("id").node[t5.NOT_LOCAL_BINDING]) {
            this.registerBinding("local", path2.get("id"), path2);
          }
        }
        if (path2.isClassExpression() && path2.has("id")) {
          if (!path2.get("id").node[t5.NOT_LOCAL_BINDING]) {
            this.registerBinding("local", path2);
          }
        }
        if (path2.isFunction()) {
          var params = path2.get("params");
          for (var _iterator15 = params, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : (0, _getIterator3.default)(_iterator15); ; ) {
            var _ref15;
            if (_isArray15) {
              if (_i15 >= _iterator15.length)
                break;
              _ref15 = _iterator15[_i15++];
            } else {
              _i15 = _iterator15.next();
              if (_i15.done)
                break;
              _ref15 = _i15.value;
            }
            var param = _ref15;
            this.registerBinding("param", param);
          }
        }
        if (path2.isCatchClause()) {
          this.registerBinding("let", path2);
        }
        var parent = this.getProgramParent();
        if (parent.crawling)
          return;
        var state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        path2.traverse(collectorVisitor, state);
        this.crawling = false;
        for (var _iterator16 = state.assignments, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : (0, _getIterator3.default)(_iterator16); ; ) {
          var _ref16;
          if (_isArray16) {
            if (_i16 >= _iterator16.length)
              break;
            _ref16 = _iterator16[_i16++];
          } else {
            _i16 = _iterator16.next();
            if (_i16.done)
              break;
            _ref16 = _i16.value;
          }
          var _path = _ref16;
          var ids = _path.getBindingIdentifiers();
          var programParent = void 0;
          for (var name in ids) {
            if (_path.scope.getBinding(name))
              continue;
            programParent = programParent || _path.scope.getProgramParent();
            programParent.addGlobal(ids[name]);
          }
          _path.scope.registerConstantViolation(_path);
        }
        for (var _iterator17 = state.references, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : (0, _getIterator3.default)(_iterator17); ; ) {
          var _ref17;
          if (_isArray17) {
            if (_i17 >= _iterator17.length)
              break;
            _ref17 = _iterator17[_i17++];
          } else {
            _i17 = _iterator17.next();
            if (_i17.done)
              break;
            _ref17 = _i17.value;
          }
          var ref = _ref17;
          var binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            ref.scope.getProgramParent().addGlobal(ref.node);
          }
        }
        for (var _iterator18 = state.constantViolations, _isArray18 = Array.isArray(_iterator18), _i18 = 0, _iterator18 = _isArray18 ? _iterator18 : (0, _getIterator3.default)(_iterator18); ; ) {
          var _ref18;
          if (_isArray18) {
            if (_i18 >= _iterator18.length)
              break;
            _ref18 = _iterator18[_i18++];
          } else {
            _i18 = _iterator18.next();
            if (_i18.done)
              break;
            _ref18 = _i18.value;
          }
          var _path2 = _ref18;
          _path2.scope.registerConstantViolation(_path2);
        }
      }, "_crawl");
      Scope2.prototype.push = /* @__PURE__ */ __name(function push(opts) {
        var path2 = this.path;
        if (!path2.isBlockStatement() && !path2.isProgram()) {
          path2 = this.getBlockParent().path;
        }
        if (path2.isSwitchStatement()) {
          path2 = this.getFunctionParent().path;
        }
        if (path2.isLoop() || path2.isCatchClause() || path2.isFunction()) {
          t5.ensureBlock(path2.node);
          path2 = path2.get("body");
        }
        var unique = opts.unique;
        var kind = opts.kind || "var";
        var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        var dataKey = "declaration:" + kind + ":" + blockHoist;
        var declarPath = !unique && path2.getData(dataKey);
        if (!declarPath) {
          var declar = t5.variableDeclaration(kind, []);
          declar._generated = true;
          declar._blockHoist = blockHoist;
          var _path$unshiftContaine = path2.unshiftContainer("body", [declar]);
          declarPath = _path$unshiftContaine[0];
          if (!unique)
            path2.setData(dataKey, declarPath);
        }
        var declarator = t5.variableDeclarator(opts.id, opts.init);
        declarPath.node.declarations.push(declarator);
        this.registerBinding(kind, declarPath.get("declarations").pop());
      }, "push");
      Scope2.prototype.getProgramParent = /* @__PURE__ */ __name(function getProgramParent() {
        var scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a Function or Program...");
      }, "getProgramParent");
      Scope2.prototype.getFunctionParent = /* @__PURE__ */ __name(function getFunctionParent() {
        var scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a Function or Program...");
      }, "getFunctionParent");
      Scope2.prototype.getBlockParent = /* @__PURE__ */ __name(function getBlockParent() {
        var scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }, "getBlockParent");
      Scope2.prototype.getAllBindings = /* @__PURE__ */ __name(function getAllBindings() {
        var ids = (0, _create2.default)(null);
        var scope = this;
        do {
          (0, _defaults2.default)(ids, scope.bindings);
          scope = scope.parent;
        } while (scope);
        return ids;
      }, "getAllBindings");
      Scope2.prototype.getAllBindingsOfKind = /* @__PURE__ */ __name(function getAllBindingsOfKind() {
        var ids = (0, _create2.default)(null);
        for (var _iterator19 = arguments, _isArray19 = Array.isArray(_iterator19), _i19 = 0, _iterator19 = _isArray19 ? _iterator19 : (0, _getIterator3.default)(_iterator19); ; ) {
          var _ref19;
          if (_isArray19) {
            if (_i19 >= _iterator19.length)
              break;
            _ref19 = _iterator19[_i19++];
          } else {
            _i19 = _iterator19.next();
            if (_i19.done)
              break;
            _ref19 = _i19.value;
          }
          var kind = _ref19;
          var scope = this;
          do {
            for (var name in scope.bindings) {
              var binding = scope.bindings[name];
              if (binding.kind === kind)
                ids[name] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      }, "getAllBindingsOfKind");
      Scope2.prototype.bindingIdentifierEquals = /* @__PURE__ */ __name(function bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }, "bindingIdentifierEquals");
      Scope2.prototype.warnOnFlowBinding = /* @__PURE__ */ __name(function warnOnFlowBinding(binding) {
        if (_crawlCallsCount === 0 && binding && binding.path.isFlow()) {
          console.warn("\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\n        Support for this will be removed in version 7. To find out the caller, grep for this\n        message and change it to a `console.trace()`.\n      ");
        }
        return binding;
      }, "warnOnFlowBinding");
      Scope2.prototype.getBinding = /* @__PURE__ */ __name(function getBinding(name) {
        var scope = this;
        do {
          var binding = scope.getOwnBinding(name);
          if (binding)
            return this.warnOnFlowBinding(binding);
        } while (scope = scope.parent);
      }, "getBinding");
      Scope2.prototype.getOwnBinding = /* @__PURE__ */ __name(function getOwnBinding(name) {
        return this.warnOnFlowBinding(this.bindings[name]);
      }, "getOwnBinding");
      Scope2.prototype.getBindingIdentifier = /* @__PURE__ */ __name(function getBindingIdentifier(name) {
        var info = this.getBinding(name);
        return info && info.identifier;
      }, "getBindingIdentifier");
      Scope2.prototype.getOwnBindingIdentifier = /* @__PURE__ */ __name(function getOwnBindingIdentifier(name) {
        var binding = this.bindings[name];
        return binding && binding.identifier;
      }, "getOwnBindingIdentifier");
      Scope2.prototype.hasOwnBinding = /* @__PURE__ */ __name(function hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }, "hasOwnBinding");
      Scope2.prototype.hasBinding = /* @__PURE__ */ __name(function hasBinding(name, noGlobals) {
        if (!name)
          return false;
        if (this.hasOwnBinding(name))
          return true;
        if (this.parentHasBinding(name, noGlobals))
          return true;
        if (this.hasUid(name))
          return true;
        if (!noGlobals && (0, _includes2.default)(Scope2.globals, name))
          return true;
        if (!noGlobals && (0, _includes2.default)(Scope2.contextVariables, name))
          return true;
        return false;
      }, "hasBinding");
      Scope2.prototype.parentHasBinding = /* @__PURE__ */ __name(function parentHasBinding(name, noGlobals) {
        return this.parent && this.parent.hasBinding(name, noGlobals);
      }, "parentHasBinding");
      Scope2.prototype.moveBindingTo = /* @__PURE__ */ __name(function moveBindingTo(name, scope) {
        var info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }, "moveBindingTo");
      Scope2.prototype.removeOwnBinding = /* @__PURE__ */ __name(function removeOwnBinding(name) {
        delete this.bindings[name];
      }, "removeOwnBinding");
      Scope2.prototype.removeBinding = /* @__PURE__ */ __name(function removeBinding(name) {
        var info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
        }
        var scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }, "removeBinding");
      return Scope2;
    }();
    Scope.globals = (0, _keys2.default)(_globals2.default.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    exports2.default = Scope;
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "node_modules/babel-traverse/lib/path/ancestry.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.findParent = findParent;
    exports2.find = find;
    exports2.getFunctionParent = getFunctionParent;
    exports2.getStatementParent = getStatementParent;
    exports2.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports2.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports2.getAncestry = getAncestry;
    exports2.isAncestor = isAncestor;
    exports2.isDescendant = isDescendant;
    exports2.inType = inType;
    exports2.inShadow = inShadow;
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    var _index = require_path();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function findParent(callback) {
      var path2 = this;
      while (path2 = path2.parentPath) {
        if (callback(path2))
          return path2;
      }
      return null;
    }
    __name(findParent, "findParent");
    function find(callback) {
      var path2 = this;
      do {
        if (callback(path2))
          return path2;
      } while (path2 = path2.parentPath);
      return null;
    }
    __name(find, "find");
    function getFunctionParent() {
      return this.findParent(function(path2) {
        return path2.isFunction() || path2.isProgram();
      });
    }
    __name(getFunctionParent, "getFunctionParent");
    function getStatementParent() {
      var path2 = this;
      do {
        if (Array.isArray(path2.container)) {
          return path2;
        }
      } while (path2 = path2.parentPath);
    }
    __name(getStatementParent, "getStatementParent");
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        var earliest = void 0;
        var keys = t5.VISITOR_KEYS[deepest.type];
        for (var _iterator = ancestries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var ancestry = _ref;
          var path2 = ancestry[i + 1];
          if (!earliest) {
            earliest = path2;
            continue;
          }
          if (path2.listKey && earliest.listKey === path2.listKey) {
            if (path2.key < earliest.key) {
              earliest = path2;
              continue;
            }
          }
          var earliestKeyIndex = keys.indexOf(earliest.parentKey);
          var currentKeyIndex = keys.indexOf(path2.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path2;
          }
        }
        return earliest;
      });
    }
    __name(getEarliestCommonAncestorFrom, "getEarliestCommonAncestorFrom");
    function getDeepestCommonAncestorFrom(paths, filter2) {
      var _this = this;
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      var minDepth = Infinity;
      var lastCommonIndex = void 0, lastCommon = void 0;
      var ancestries = paths.map(function(path2) {
        var ancestry2 = [];
        do {
          ancestry2.unshift(path2);
        } while ((path2 = path2.parentPath) && path2 !== _this);
        if (ancestry2.length < minDepth) {
          minDepth = ancestry2.length;
        }
        return ancestry2;
      });
      var first = ancestries[0];
      depthLoop:
        for (var i = 0; i < minDepth; i++) {
          var shouldMatch = first[i];
          for (var _iterator2 = ancestries, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var ancestry = _ref2;
            if (ancestry[i] !== shouldMatch) {
              break depthLoop;
            }
          }
          lastCommonIndex = i;
          lastCommon = shouldMatch;
        }
      if (lastCommon) {
        if (filter2) {
          return filter2(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    __name(getDeepestCommonAncestorFrom, "getDeepestCommonAncestorFrom");
    function getAncestry() {
      var path2 = this;
      var paths = [];
      do {
        paths.push(path2);
      } while (path2 = path2.parentPath);
      return paths;
    }
    __name(getAncestry, "getAncestry");
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    __name(isAncestor, "isAncestor");
    function isDescendant(maybeAncestor) {
      return !!this.findParent(function(parent) {
        return parent === maybeAncestor;
      });
    }
    __name(isDescendant, "isDescendant");
    function inType() {
      var path2 = this;
      while (path2) {
        for (var _iterator3 = arguments, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var type3 = _ref3;
          if (path2.node.type === type3)
            return true;
        }
        path2 = path2.parentPath;
      }
      return false;
    }
    __name(inType, "inType");
    function inShadow(key) {
      var parentFn = this.isFunction() ? this : this.findParent(function(p) {
        return p.isFunction();
      });
      if (!parentFn)
        return;
      if (parentFn.isFunctionExpression() || parentFn.isFunctionDeclaration()) {
        var shadow = parentFn.node.shadow;
        if (shadow && (!key || shadow[key] !== false)) {
          return parentFn;
        }
      } else if (parentFn.isArrowFunctionExpression()) {
        return parentFn;
      }
      return null;
    }
    __name(inShadow, "inShadow");
  }
});

// node_modules/babel-traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "node_modules/babel-traverse/lib/path/inference/inferer-reference.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.default = function(node) {
      if (!this.isReferenced())
        return;
      var binding = this.scope.getBinding(node.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(this, node.name);
        }
      }
      if (node.name === "undefined") {
        return t5.voidTypeAnnotation();
      } else if (node.name === "NaN" || node.name === "Infinity") {
        return t5.numberTypeAnnotation();
      } else if (node.name === "arguments") {
      }
    };
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function getTypeAnnotationBindingConstantViolations(path2, name) {
      var binding = path2.scope.getBinding(name);
      var types = [];
      path2.typeAnnotation = t5.unionTypeAnnotation(types);
      var functionConstantViolations = [];
      var constantViolations = getConstantViolationsBefore(binding, path2, functionConstantViolations);
      var testType = getConditionalAnnotation(path2, name);
      if (testType) {
        var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter(function(path3) {
          return testConstantViolations.indexOf(path3) < 0;
        });
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations = constantViolations.concat(functionConstantViolations);
        for (var _iterator = constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var violation = _ref;
          types.push(violation.getTypeAnnotation());
        }
      }
      if (types.length) {
        return t5.createUnionTypeAnnotation(types);
      }
    }
    __name(getTypeAnnotationBindingConstantViolations, "getTypeAnnotationBindingConstantViolations");
    function getConstantViolationsBefore(binding, path2, functions) {
      var violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter(function(violation) {
        violation = violation.resolve();
        var status = violation._guessExecutionStatusRelativeTo(path2);
        if (functions && status === "function")
          functions.push(violation);
        return status === "before";
      });
    }
    __name(getConstantViolationsBefore, "getConstantViolationsBefore");
    function inferAnnotationFromBinaryExpression(name, path2) {
      var operator = path2.node.operator;
      var right = path2.get("right").resolve();
      var left = path2.get("left").resolve();
      var target = void 0;
      if (left.isIdentifier({ name })) {
        target = right;
      } else if (right.isIdentifier({ name })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        } else if (t5.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
          return t5.numberTypeAnnotation();
        } else {
          return;
        }
      } else {
        if (operator !== "===")
          return;
      }
      var typeofPath = void 0;
      var typePath = void 0;
      if (left.isUnaryExpression({ operator: "typeof" })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({ operator: "typeof" })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typePath && !typeofPath)
        return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral())
        return;
      var typeValue = typePath.node.value;
      if (typeof typeValue !== "string")
        return;
      if (!typeofPath.get("argument").isIdentifier({ name }))
        return;
      return t5.createTypeAnnotationBasedOnTypeof(typePath.node.value);
    }
    __name(inferAnnotationFromBinaryExpression, "inferAnnotationFromBinaryExpression");
    function getParentConditionalPath(path2) {
      var parentPath = void 0;
      while (parentPath = path2.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path2.key === "test") {
            return;
          } else {
            return parentPath;
          }
        } else {
          path2 = parentPath;
        }
      }
    }
    __name(getParentConditionalPath, "getParentConditionalPath");
    function getConditionalAnnotation(path2, name) {
      var ifStatement2 = getParentConditionalPath(path2);
      if (!ifStatement2)
        return;
      var test = ifStatement2.get("test");
      var paths = [test];
      var types = [];
      do {
        var _path = paths.shift().resolve();
        if (_path.isLogicalExpression()) {
          paths.push(_path.get("left"));
          paths.push(_path.get("right"));
        }
        if (_path.isBinaryExpression()) {
          var type3 = inferAnnotationFromBinaryExpression(name, _path);
          if (type3)
            types.push(type3);
        }
      } while (paths.length);
      if (types.length) {
        return {
          typeAnnotation: t5.createUnionTypeAnnotation(types),
          ifStatement: ifStatement2
        };
      } else {
        return getConditionalAnnotation(ifStatement2, name);
      }
    }
    __name(getConditionalAnnotation, "getConditionalAnnotation");
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "node_modules/babel-traverse/lib/path/inference/inferers.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = exports2.Identifier = void 0;
    var _infererReference = require_inferer_reference();
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _interopRequireDefault(_infererReference).default;
      }, "get")
    });
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.NewExpression = NewExpression;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2.UnaryExpression = UnaryExpression2;
    exports2.BinaryExpression = BinaryExpression2;
    exports2.LogicalExpression = LogicalExpression;
    exports2.ConditionalExpression = ConditionalExpression2;
    exports2.SequenceExpression = SequenceExpression3;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.StringLiteral = StringLiteral2;
    exports2.NumericLiteral = NumericLiteral2;
    exports2.BooleanLiteral = BooleanLiteral2;
    exports2.NullLiteral = NullLiteral2;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.ObjectExpression = ObjectExpression2;
    exports2.ArrayExpression = ArrayExpression2;
    exports2.RestElement = RestElement;
    exports2.CallExpression = CallExpression2;
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function VariableDeclarator() {
      var id = this.get("id");
      if (id.isIdentifier()) {
        return this.get("init").getTypeAnnotation();
      } else {
        return;
      }
    }
    __name(VariableDeclarator, "VariableDeclarator");
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    __name(TypeCastExpression, "TypeCastExpression");
    TypeCastExpression.validParent = true;
    function NewExpression(node) {
      if (this.get("callee").isIdentifier()) {
        return t5.genericTypeAnnotation(node.callee);
      }
    }
    __name(NewExpression, "NewExpression");
    function TemplateLiteral() {
      return t5.stringTypeAnnotation();
    }
    __name(TemplateLiteral, "TemplateLiteral");
    function UnaryExpression2(node) {
      var operator = node.operator;
      if (operator === "void") {
        return t5.voidTypeAnnotation();
      } else if (t5.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t5.numberTypeAnnotation();
      } else if (t5.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t5.stringTypeAnnotation();
      } else if (t5.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
        return t5.booleanTypeAnnotation();
      }
    }
    __name(UnaryExpression2, "UnaryExpression");
    function BinaryExpression2(node) {
      var operator = node.operator;
      if (t5.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t5.numberTypeAnnotation();
      } else if (t5.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t5.booleanTypeAnnotation();
      } else if (operator === "+") {
        var right = this.get("right");
        var left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return t5.numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return t5.stringTypeAnnotation();
        }
        return t5.unionTypeAnnotation([t5.stringTypeAnnotation(), t5.numberTypeAnnotation()]);
      }
    }
    __name(BinaryExpression2, "BinaryExpression");
    function LogicalExpression() {
      return t5.createUnionTypeAnnotation([this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()]);
    }
    __name(LogicalExpression, "LogicalExpression");
    function ConditionalExpression2() {
      return t5.createUnionTypeAnnotation([this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()]);
    }
    __name(ConditionalExpression2, "ConditionalExpression");
    function SequenceExpression3() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    __name(SequenceExpression3, "SequenceExpression");
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    __name(AssignmentExpression, "AssignmentExpression");
    function UpdateExpression(node) {
      var operator = node.operator;
      if (operator === "++" || operator === "--") {
        return t5.numberTypeAnnotation();
      }
    }
    __name(UpdateExpression, "UpdateExpression");
    function StringLiteral2() {
      return t5.stringTypeAnnotation();
    }
    __name(StringLiteral2, "StringLiteral");
    function NumericLiteral2() {
      return t5.numberTypeAnnotation();
    }
    __name(NumericLiteral2, "NumericLiteral");
    function BooleanLiteral2() {
      return t5.booleanTypeAnnotation();
    }
    __name(BooleanLiteral2, "BooleanLiteral");
    function NullLiteral2() {
      return t5.nullLiteralTypeAnnotation();
    }
    __name(NullLiteral2, "NullLiteral");
    function RegExpLiteral() {
      return t5.genericTypeAnnotation(t5.identifier("RegExp"));
    }
    __name(RegExpLiteral, "RegExpLiteral");
    function ObjectExpression2() {
      return t5.genericTypeAnnotation(t5.identifier("Object"));
    }
    __name(ObjectExpression2, "ObjectExpression");
    function ArrayExpression2() {
      return t5.genericTypeAnnotation(t5.identifier("Array"));
    }
    __name(ArrayExpression2, "ArrayExpression");
    function RestElement() {
      return ArrayExpression2();
    }
    __name(RestElement, "RestElement");
    RestElement.validParent = true;
    function Func() {
      return t5.genericTypeAnnotation(t5.identifier("Function"));
    }
    __name(Func, "Func");
    exports2.FunctionExpression = Func;
    exports2.ArrowFunctionExpression = Func;
    exports2.FunctionDeclaration = Func;
    exports2.ClassExpression = Func;
    exports2.ClassDeclaration = Func;
    function CallExpression2() {
      return resolveCall(this.get("callee"));
    }
    __name(CallExpression2, "CallExpression");
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    __name(TaggedTemplateExpression, "TaggedTemplateExpression");
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        if (callee.is("async")) {
          if (callee.is("generator")) {
            return t5.genericTypeAnnotation(t5.identifier("AsyncIterator"));
          } else {
            return t5.genericTypeAnnotation(t5.identifier("Promise"));
          }
        } else {
          if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
    __name(resolveCall, "resolveCall");
  }
});

// node_modules/babel-traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "node_modules/babel-traverse/lib/path/inference/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.getTypeAnnotation = getTypeAnnotation;
    exports2._getTypeAnnotation = _getTypeAnnotation;
    exports2.isBaseType = isBaseType;
    exports2.couldBeBaseType = couldBeBaseType;
    exports2.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports2.isGenericType = isGenericType;
    var _inferers = require_inferers();
    var inferers = _interopRequireWildcard(_inferers);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function getTypeAnnotation() {
      if (this.typeAnnotation)
        return this.typeAnnotation;
      var type3 = this._getTypeAnnotation() || t5.anyTypeAnnotation();
      if (t5.isTypeAnnotation(type3))
        type3 = type3.typeAnnotation;
      return this.typeAnnotation = type3;
    }
    __name(getTypeAnnotation, "getTypeAnnotation");
    function _getTypeAnnotation() {
      var node = this.node;
      if (!node) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          var declar = this.parentPath.parentPath;
          var declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return t5.stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return t5.anyTypeAnnotation();
          }
          return t5.voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node.typeAnnotation) {
        return node.typeAnnotation;
      }
      var inferer = inferers[node.type];
      if (inferer) {
        return inferer.call(this, node);
      }
      inferer = inferers[this.parentPath.type];
      if (inferer && inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    }
    __name(_getTypeAnnotation, "_getTypeAnnotation");
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    __name(isBaseType, "isBaseType");
    function _isBaseType(baseName, type3, soft) {
      if (baseName === "string") {
        return t5.isStringTypeAnnotation(type3);
      } else if (baseName === "number") {
        return t5.isNumberTypeAnnotation(type3);
      } else if (baseName === "boolean") {
        return t5.isBooleanTypeAnnotation(type3);
      } else if (baseName === "any") {
        return t5.isAnyTypeAnnotation(type3);
      } else if (baseName === "mixed") {
        return t5.isMixedTypeAnnotation(type3);
      } else if (baseName === "empty") {
        return t5.isEmptyTypeAnnotation(type3);
      } else if (baseName === "void") {
        return t5.isVoidTypeAnnotation(type3);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error("Unknown base type " + baseName);
        }
      }
    }
    __name(_isBaseType, "_isBaseType");
    function couldBeBaseType(name) {
      var type3 = this.getTypeAnnotation();
      if (t5.isAnyTypeAnnotation(type3))
        return true;
      if (t5.isUnionTypeAnnotation(type3)) {
        for (var _iterator = type3.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var type22 = _ref;
          if (t5.isAnyTypeAnnotation(type22) || _isBaseType(name, type22, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name, type3, true);
      }
    }
    __name(couldBeBaseType, "couldBeBaseType");
    function baseTypeStrictlyMatches(right) {
      var left = this.getTypeAnnotation();
      right = right.getTypeAnnotation();
      if (!t5.isAnyTypeAnnotation(left) && t5.isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
    }
    __name(baseTypeStrictlyMatches, "baseTypeStrictlyMatches");
    function isGenericType(genericName) {
      var type3 = this.getTypeAnnotation();
      return t5.isGenericTypeAnnotation(type3) && t5.isIdentifier(type3.id, { name: genericName });
    }
    __name(isGenericType, "isGenericType");
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match) {
      var token = { type: "invalid", value: match[0] };
      if (match[1])
        token.type = "string", token.closed = !!(match[3] || match[4]);
      else if (match[5])
        token.type = "comment";
      else if (match[6])
        token.type = "comment", token.closed = !!match[7];
      else if (match[8])
        token.type = "regex";
      else if (match[9])
        token.type = "number";
      else if (match[10])
        token.type = "name";
      else if (match[11])
        token.type = "punctuator";
      else if (match[12])
        token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    function assembleStyles() {
      var styles = {
        modifiers: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        colors: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39]
        },
        bgColors: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49]
        }
      };
      styles.colors.grey = styles.colors.gray;
      Object.keys(styles).forEach(function(groupName) {
        var group2 = styles[groupName];
        Object.keys(group2).forEach(function(styleName) {
          var style = group2[styleName];
          styles[styleName] = group2[styleName] = {
            open: "\x1B[" + style[0] + "m",
            close: "\x1B[" + style[1] + "m"
          };
        });
        Object.defineProperty(styles, groupName, {
          value: group2,
          enumerable: false
        });
      });
      return styles;
    }
    __name(assembleStyles, "assembleStyles");
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex()();
    module2.exports = function(str) {
      return typeof str === "string" ? str.replace(ansiRegex, "") : str;
    };
  }
});

// node_modules/has-ansi/index.js
var require_has_ansi = __commonJS({
  "node_modules/has-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    var re = new RegExp(ansiRegex().source);
    module2.exports = re.test.bind(re);
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var argv = process.argv;
    var terminator = argv.indexOf("--");
    var hasFlag = /* @__PURE__ */ __name(function(flag) {
      flag = "--" + flag;
      var pos = argv.indexOf(flag);
      return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
    }, "hasFlag");
    module2.exports = function() {
      if ("FORCE_COLOR" in process.env) {
        return true;
      }
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
        return false;
      }
      if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stripAnsi = require_strip_ansi();
    var hasAnsi = require_has_ansi();
    var supportsColor = require_supports_color();
    var defineProps = Object.defineProperties;
    var isSimpleWindowsTerm = process.platform === "win32" && !/^xterm/i.test(process.env.TERM);
    function Chalk(options2) {
      this.enabled = !options2 || options2.enabled === void 0 ? supportsColor : options2.enabled;
    }
    __name(Chalk, "Chalk");
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    var styles = function() {
      var ret = {};
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build.call(this, this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(/* @__PURE__ */ __name(function chalk() {
    }, "chalk"), styles);
    function build(_styles) {
      var builder = /* @__PURE__ */ __name(function() {
        return applyStyle.apply(builder, arguments);
      }, "builder");
      builder._styles = _styles;
      builder.enabled = this.enabled;
      builder.__proto__ = proto;
      return builder;
    }
    __name(build, "build");
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      var originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && (nestedStyles.indexOf("gray") !== -1 || nestedStyles.indexOf("grey") !== -1)) {
        ansiStyles.dim.open = "";
      }
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    __name(applyStyle, "applyStyle");
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build.call(this, [name]);
          }
        };
      });
      return ret;
    }
    __name(init, "init");
    defineProps(Chalk.prototype, init());
    module2.exports = new Chalk();
    module2.exports.styles = ansiStyles;
    module2.exports.hasColor = hasAnsi;
    module2.exports.stripColor = stripAnsi;
    module2.exports.supportsColor = supportsColor;
  }
});

// node_modules/babel-code-frame/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/babel-code-frame/lib/index.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    exports2.default = function(rawLines, lineNumber, colNumber) {
      var opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      colNumber = Math.max(colNumber, 0);
      var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;
      var chalk = _chalk2.default;
      if (opts.forceColor) {
        chalk = new _chalk2.default.constructor({ enabled: true });
      }
      var maybeHighlight = /* @__PURE__ */ __name(function maybeHighlight2(chalkFn, string) {
        return highlighted ? chalkFn(string) : string;
      }, "maybeHighlight");
      var defs = getDefs(chalk);
      if (highlighted)
        rawLines = highlight(defs, rawLines);
      var linesAbove = opts.linesAbove || 2;
      var linesBelow = opts.linesBelow || 3;
      var lines = rawLines.split(NEWLINE);
      var start = Math.max(lineNumber - (linesAbove + 1), 0);
      var end = Math.min(lines.length, lineNumber + linesBelow);
      if (!lineNumber && !colNumber) {
        start = 0;
        end = lines.length;
      }
      var numberMaxWidth = String(end).length;
      var frame = lines.slice(start, end).map(function(line2, index) {
        var number = start + 1 + index;
        var paddedNumber = (" " + number).slice(-numberMaxWidth);
        var gutter = " " + paddedNumber + " | ";
        if (number === lineNumber) {
          var markerLine = "";
          if (colNumber) {
            var markerSpacing = line2.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^")].join("");
          }
          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line2, markerLine].join("");
        } else {
          return " " + maybeHighlight(defs.gutter, gutter) + line2;
        }
      }).join("\n");
      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    };
    var _jsTokens = require_js_tokens();
    var _jsTokens2 = _interopRequireDefault(_jsTokens);
    var _esutils = require_utils();
    var _esutils2 = _interopRequireDefault(_esutils);
    var _chalk = require_chalk();
    var _chalk2 = _interopRequireDefault(_chalk);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsx_tag: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold,
        gutter: chalk.grey,
        marker: chalk.red.bold
      };
    }
    __name(getDefs, "getDefs");
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var BRACKET = /^[()\[\]{}]$/;
    function getTokenType(match) {
      var _match$slice = match.slice(-2), offset = _match$slice[0], text = _match$slice[1];
      var token = (0, _jsTokens.matchToToken)(match);
      if (token.type === "name") {
        if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsx_tag";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      return token.type;
    }
    __name(getTokenType, "getTokenType");
    function highlight(defs, text) {
      return text.replace(_jsTokens2.default, function() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var type3 = getTokenType(args);
        var colorize = defs[type3];
        if (colorize) {
          return args[0].split(NEWLINE).map(function(str) {
            return colorize(str);
          }).join("\n");
        } else {
          return args[0];
        }
      });
    }
    __name(highlight, "highlight");
    module2.exports = exports2["default"];
  }
});

// node_modules/babylon/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/babylon/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makePredicate(words) {
      words = words.split(" ");
      return function(str) {
        return words.indexOf(str) >= 0;
      };
    }
    __name(makePredicate, "makePredicate");
    var reservedWords = {
      6: makePredicate("enum await"),
      strict: makePredicate("implements interface let package private protected public static yield"),
      strictBind: makePredicate("eval arguments")
    };
    var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];
    function isInAstralSet(code, set) {
      var pos = 65536;
      for (var i = 0; i < set.length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
    }
    __name(isInAstralSet, "isInAstralSet");
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code < 91)
        return true;
      if (code < 97)
        return code === 95;
      if (code < 123)
        return true;
      if (code <= 65535)
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    __name(isIdentifierStart, "isIdentifierStart");
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code < 91)
        return true;
      if (code < 97)
        return code === 95;
      if (code < 123)
        return true;
      if (code <= 65535)
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    __name(isIdentifierChar, "isIdentifierChar");
    var defaultOptions = {
      sourceType: "script",
      sourceFilename: void 0,
      startLine: 1,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      plugins: [],
      strictMode: null
    };
    function getOptions(opts) {
      var options2 = {};
      for (var key in defaultOptions) {
        options2[key] = opts && key in opts ? opts[key] : defaultOptions[key];
      }
      return options2;
    }
    __name(getOptions, "getOptions");
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var classCallCheck = /* @__PURE__ */ __name(function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }, "classCallCheck");
    var inherits = /* @__PURE__ */ __name(function(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }, "inherits");
    var possibleConstructorReturn = /* @__PURE__ */ __name(function(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }, "possibleConstructorReturn");
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var TokenType = /* @__PURE__ */ __name(function TokenType2(label) {
      var conf = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      classCallCheck(this, TokenType2);
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    }, "TokenType");
    var KeywordTokenType = function(_TokenType) {
      inherits(KeywordTokenType2, _TokenType);
      function KeywordTokenType2(name) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        classCallCheck(this, KeywordTokenType2);
        options2.keyword = name;
        return possibleConstructorReturn(this, _TokenType.call(this, name, options2));
      }
      __name(KeywordTokenType2, "KeywordTokenType");
      return KeywordTokenType2;
    }(TokenType);
    var BinopTokenType = function(_TokenType2) {
      inherits(BinopTokenType2, _TokenType2);
      function BinopTokenType2(name, prec) {
        classCallCheck(this, BinopTokenType2);
        return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr, binop: prec }));
      }
      __name(BinopTokenType2, "BinopTokenType");
      return BinopTokenType2;
    }(TokenType);
    var types = {
      num: new TokenType("num", { startsExpr }),
      regexp: new TokenType("regexp", { startsExpr }),
      string: new TokenType("string", { startsExpr }),
      name: new TokenType("name", { startsExpr }),
      eof: new TokenType("eof"),
      bracketL: new TokenType("[", { beforeExpr, startsExpr }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr, startsExpr }),
      braceBarL: new TokenType("{|", { beforeExpr, startsExpr }),
      braceR: new TokenType("}"),
      braceBarR: new TokenType("|}"),
      parenL: new TokenType("(", { beforeExpr, startsExpr }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", { beforeExpr }),
      semi: new TokenType(";", { beforeExpr }),
      colon: new TokenType(":", { beforeExpr }),
      doubleColon: new TokenType("::", { beforeExpr }),
      dot: new TokenType("."),
      question: new TokenType("?", { beforeExpr }),
      arrow: new TokenType("=>", { beforeExpr }),
      template: new TokenType("template"),
      ellipsis: new TokenType("...", { beforeExpr }),
      backQuote: new TokenType("`", { startsExpr }),
      dollarBraceL: new TokenType("${", { beforeExpr, startsExpr }),
      at: new TokenType("@"),
      eq: new TokenType("=", { beforeExpr, isAssign }),
      assign: new TokenType("_=", { beforeExpr, isAssign }),
      incDec: new TokenType("++/--", { prefix, postfix, startsExpr }),
      prefix: new TokenType("prefix", { beforeExpr, prefix, startsExpr }),
      logicalOR: new BinopTokenType("||", 1),
      logicalAND: new BinopTokenType("&&", 2),
      bitwiseOR: new BinopTokenType("|", 3),
      bitwiseXOR: new BinopTokenType("^", 4),
      bitwiseAND: new BinopTokenType("&", 5),
      equality: new BinopTokenType("==/!=", 6),
      relational: new BinopTokenType("</>", 7),
      bitShift: new BinopTokenType("<</>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr, binop: 9, prefix, startsExpr }),
      modulo: new BinopTokenType("%", 10),
      star: new BinopTokenType("*", 10),
      slash: new BinopTokenType("/", 10),
      exponent: new TokenType("**", { beforeExpr, binop: 11, rightAssociative: true })
    };
    var keywords = {
      "break": new KeywordTokenType("break"),
      "case": new KeywordTokenType("case", { beforeExpr }),
      "catch": new KeywordTokenType("catch"),
      "continue": new KeywordTokenType("continue"),
      "debugger": new KeywordTokenType("debugger"),
      "default": new KeywordTokenType("default", { beforeExpr }),
      "do": new KeywordTokenType("do", { isLoop, beforeExpr }),
      "else": new KeywordTokenType("else", { beforeExpr }),
      "finally": new KeywordTokenType("finally"),
      "for": new KeywordTokenType("for", { isLoop }),
      "function": new KeywordTokenType("function", { startsExpr }),
      "if": new KeywordTokenType("if"),
      "return": new KeywordTokenType("return", { beforeExpr }),
      "switch": new KeywordTokenType("switch"),
      "throw": new KeywordTokenType("throw", { beforeExpr }),
      "try": new KeywordTokenType("try"),
      "var": new KeywordTokenType("var"),
      "let": new KeywordTokenType("let"),
      "const": new KeywordTokenType("const"),
      "while": new KeywordTokenType("while", { isLoop }),
      "with": new KeywordTokenType("with"),
      "new": new KeywordTokenType("new", { beforeExpr, startsExpr }),
      "this": new KeywordTokenType("this", { startsExpr }),
      "super": new KeywordTokenType("super", { startsExpr }),
      "class": new KeywordTokenType("class"),
      "extends": new KeywordTokenType("extends", { beforeExpr }),
      "export": new KeywordTokenType("export"),
      "import": new KeywordTokenType("import", { startsExpr }),
      "yield": new KeywordTokenType("yield", { beforeExpr, startsExpr }),
      "null": new KeywordTokenType("null", { startsExpr }),
      "true": new KeywordTokenType("true", { startsExpr }),
      "false": new KeywordTokenType("false", { startsExpr }),
      "in": new KeywordTokenType("in", { beforeExpr, binop: 7 }),
      "instanceof": new KeywordTokenType("instanceof", { beforeExpr, binop: 7 }),
      "typeof": new KeywordTokenType("typeof", { beforeExpr, prefix, startsExpr }),
      "void": new KeywordTokenType("void", { beforeExpr, prefix, startsExpr }),
      "delete": new KeywordTokenType("delete", { beforeExpr, prefix, startsExpr })
    };
    Object.keys(keywords).forEach(function(name) {
      types["_" + name] = keywords[name];
    });
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      return code === 10 || code === 13 || code === 8232 || code === 8233;
    }
    __name(isNewLine, "isNewLine");
    var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var TokContext = /* @__PURE__ */ __name(function TokContext2(token, isExpr, preserveSpace, override) {
      classCallCheck(this, TokContext2);
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
    }, "TokContext");
    var types$1 = {
      braceStatement: new TokContext("{", false),
      braceExpression: new TokContext("{", true),
      templateQuasi: new TokContext("${", true),
      parenStatement: new TokContext("(", false),
      parenExpression: new TokContext("(", true),
      template: new TokContext("`", true, true, function(p) {
        return p.readTmplToken();
      }),
      functionExpression: new TokContext("function", true)
    };
    types.parenR.updateContext = types.braceR.updateContext = function() {
      if (this.state.context.length === 1) {
        this.state.exprAllowed = true;
        return;
      }
      var out = this.state.context.pop();
      if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {
        this.state.context.pop();
        this.state.exprAllowed = false;
      } else if (out === types$1.templateQuasi) {
        this.state.exprAllowed = true;
      } else {
        this.state.exprAllowed = !out.isExpr;
      }
    };
    types.name.updateContext = function(prevType) {
      this.state.exprAllowed = false;
      if (prevType === types._let || prevType === types._const || prevType === types._var) {
        if (lineBreak.test(this.input.slice(this.state.end))) {
          this.state.exprAllowed = true;
        }
      }
    };
    types.braceL.updateContext = function(prevType) {
      this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
      this.state.exprAllowed = true;
    };
    types.dollarBraceL.updateContext = function() {
      this.state.context.push(types$1.templateQuasi);
      this.state.exprAllowed = true;
    };
    types.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
      this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
      this.state.exprAllowed = true;
    };
    types.incDec.updateContext = function() {
    };
    types._function.updateContext = function() {
      if (this.curContext() !== types$1.braceStatement) {
        this.state.context.push(types$1.functionExpression);
      }
      this.state.exprAllowed = false;
    };
    types.backQuote.updateContext = function() {
      if (this.curContext() === types$1.template) {
        this.state.context.pop();
      } else {
        this.state.context.push(types$1.template);
      }
      this.state.exprAllowed = false;
    };
    var Position = /* @__PURE__ */ __name(function Position2(line2, col) {
      classCallCheck(this, Position2);
      this.line = line2;
      this.column = col;
    }, "Position");
    var SourceLocation = /* @__PURE__ */ __name(function SourceLocation2(start, end) {
      classCallCheck(this, SourceLocation2);
      this.start = start;
      this.end = end;
    }, "SourceLocation");
    function getLineInfo(input, offset) {
      for (var line2 = 1, cur = 0; ; ) {
        lineBreakG.lastIndex = cur;
        var match = lineBreakG.exec(input);
        if (match && match.index < offset) {
          ++line2;
          cur = match.index + match[0].length;
        } else {
          return new Position(line2, offset - cur);
        }
      }
    }
    __name(getLineInfo, "getLineInfo");
    var State2 = function() {
      function State3() {
        classCallCheck(this, State3);
      }
      __name(State3, "State");
      State3.prototype.init = /* @__PURE__ */ __name(function init(options2, input) {
        this.strict = options2.strictMode === false ? false : options2.sourceType === "module";
        this.input = input;
        this.potentialArrowAt = -1;
        this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = false;
        this.labels = [];
        this.decorators = [];
        this.tokens = [];
        this.comments = [];
        this.trailingComments = [];
        this.leadingComments = [];
        this.commentStack = [];
        this.pos = this.lineStart = 0;
        this.curLine = options2.startLine;
        this.type = types.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = [types$1.braceStatement];
        this.exprAllowed = true;
        this.containsEsc = this.containsOctal = false;
        this.octalPosition = null;
        this.invalidTemplateEscapePosition = null;
        this.exportedIdentifiers = [];
        return this;
      }, "init");
      State3.prototype.curPosition = /* @__PURE__ */ __name(function curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart);
      }, "curPosition");
      State3.prototype.clone = /* @__PURE__ */ __name(function clone(skipArrays) {
        var state = new State3();
        for (var key in this) {
          var val = this[key];
          if ((!skipArrays || key === "context") && Array.isArray(val)) {
            val = val.slice();
          }
          state[key] = val;
        }
        return state;
      }, "clone");
      return State3;
    }();
    var Token = /* @__PURE__ */ __name(function Token2(state) {
      classCallCheck(this, Token2);
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }, "Token");
    function codePointToString(code) {
      if (code <= 65535) {
        return String.fromCharCode(code);
      } else {
        return String.fromCharCode((code - 65536 >> 10) + 55296, (code - 65536 & 1023) + 56320);
      }
    }
    __name(codePointToString, "codePointToString");
    var Tokenizer = function() {
      function Tokenizer2(options2, input) {
        classCallCheck(this, Tokenizer2);
        this.state = new State2();
        this.state.init(options2, input);
      }
      __name(Tokenizer2, "Tokenizer");
      Tokenizer2.prototype.next = /* @__PURE__ */ __name(function next() {
        if (!this.isLookahead) {
          this.state.tokens.push(new Token(this.state));
        }
        this.state.lastTokEnd = this.state.end;
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }, "next");
      Tokenizer2.prototype.eat = /* @__PURE__ */ __name(function eat(type3) {
        if (this.match(type3)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }, "eat");
      Tokenizer2.prototype.match = /* @__PURE__ */ __name(function match(type3) {
        return this.state.type === type3;
      }, "match");
      Tokenizer2.prototype.isKeyword = /* @__PURE__ */ __name(function isKeyword$$1(word) {
        return isKeyword(word);
      }, "isKeyword$$1");
      Tokenizer2.prototype.lookahead = /* @__PURE__ */ __name(function lookahead() {
        var old = this.state;
        this.state = old.clone(true);
        this.isLookahead = true;
        this.next();
        this.isLookahead = false;
        var curr = this.state.clone(true);
        this.state = old;
        return curr;
      }, "lookahead");
      Tokenizer2.prototype.setStrict = /* @__PURE__ */ __name(function setStrict(strict) {
        this.state.strict = strict;
        if (!this.match(types.num) && !this.match(types.string))
          return;
        this.state.pos = this.state.start;
        while (this.state.pos < this.state.lineStart) {
          this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
          --this.state.curLine;
        }
        this.nextToken();
      }, "setStrict");
      Tokenizer2.prototype.curContext = /* @__PURE__ */ __name(function curContext() {
        return this.state.context[this.state.context.length - 1];
      }, "curContext");
      Tokenizer2.prototype.nextToken = /* @__PURE__ */ __name(function nextToken() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace)
          this.skipSpace();
        this.state.containsOctal = false;
        this.state.octalPosition = null;
        this.state.start = this.state.pos;
        this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.input.length)
          return this.finishToken(types.eof);
        if (curContext.override) {
          return curContext.override(this);
        } else {
          return this.readToken(this.fullCharCodeAtPos());
        }
      }, "nextToken");
      Tokenizer2.prototype.readToken = /* @__PURE__ */ __name(function readToken(code) {
        if (isIdentifierStart(code) || code === 92) {
          return this.readWord();
        } else {
          return this.getTokenFromCode(code);
        }
      }, "readToken");
      Tokenizer2.prototype.fullCharCodeAtPos = /* @__PURE__ */ __name(function fullCharCodeAtPos() {
        var code = this.input.charCodeAt(this.state.pos);
        if (code <= 55295 || code >= 57344)
          return code;
        var next = this.input.charCodeAt(this.state.pos + 1);
        return (code << 10) + next - 56613888;
      }, "fullCharCodeAtPos");
      Tokenizer2.prototype.pushComment = /* @__PURE__ */ __name(function pushComment(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "CommentBlock" : "CommentLine",
          value: text,
          start,
          end,
          loc: new SourceLocation(startLoc, endLoc)
        };
        if (!this.isLookahead) {
          this.state.tokens.push(comment);
          this.state.comments.push(comment);
          this.addComment(comment);
        }
      }, "pushComment");
      Tokenizer2.prototype.skipBlockComment = /* @__PURE__ */ __name(function skipBlockComment() {
        var startLoc = this.state.curPosition();
        var start = this.state.pos;
        var end = this.input.indexOf("*/", this.state.pos += 2);
        if (end === -1)
          this.raise(this.state.pos - 2, "Unterminated comment");
        this.state.pos = end + 2;
        lineBreakG.lastIndex = start;
        var match = void 0;
        while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
          ++this.state.curLine;
          this.state.lineStart = match.index + match[0].length;
        }
        this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
      }, "skipBlockComment");
      Tokenizer2.prototype.skipLineComment = /* @__PURE__ */ __name(function skipLineComment(startSkip) {
        var start = this.state.pos;
        var startLoc = this.state.curPosition();
        var ch = this.input.charCodeAt(this.state.pos += startSkip);
        while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
          ++this.state.pos;
          ch = this.input.charCodeAt(this.state.pos);
        }
        this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
      }, "skipLineComment");
      Tokenizer2.prototype.skipSpace = /* @__PURE__ */ __name(function skipSpace() {
        loop:
          while (this.state.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.state.pos;
                } else {
                  break loop;
                }
            }
          }
      }, "skipSpace");
      Tokenizer2.prototype.finishToken = /* @__PURE__ */ __name(function finishToken(type3, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        var prevType = this.state.type;
        this.state.type = type3;
        this.state.value = val;
        this.updateContext(prevType);
      }, "finishToken");
      Tokenizer2.prototype.readToken_dot = /* @__PURE__ */ __name(function readToken_dot() {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 46 && next2 === 46) {
          this.state.pos += 3;
          return this.finishToken(types.ellipsis);
        } else {
          ++this.state.pos;
          return this.finishToken(types.dot);
        }
      }, "readToken_dot");
      Tokenizer2.prototype.readToken_slash = /* @__PURE__ */ __name(function readToken_slash() {
        if (this.state.exprAllowed) {
          ++this.state.pos;
          return this.readRegexp();
        }
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        } else {
          return this.finishOp(types.slash, 1);
        }
      }, "readToken_slash");
      Tokenizer2.prototype.readToken_mult_modulo = /* @__PURE__ */ __name(function readToken_mult_modulo(code) {
        var type3 = code === 42 ? types.star : types.modulo;
        var width = 1;
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type3 = types.exponent;
        }
        if (next === 61) {
          width++;
          type3 = types.assign;
        }
        return this.finishOp(type3, width);
      }, "readToken_mult_modulo");
      Tokenizer2.prototype.readToken_pipe_amp = /* @__PURE__ */ __name(function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code)
          return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        if (next === 61)
          return this.finishOp(types.assign, 2);
        if (code === 124 && next === 125 && this.hasPlugin("flow"))
          return this.finishOp(types.braceBarR, 2);
        return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
      }, "readToken_pipe_amp");
      Tokenizer2.prototype.readToken_caret = /* @__PURE__ */ __name(function readToken_caret() {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        } else {
          return this.finishOp(types.bitwiseXOR, 1);
        }
      }, "readToken_caret");
      Tokenizer2.prototype.readToken_plus_min = /* @__PURE__ */ __name(function readToken_plus_min(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types.assign, 2);
        } else {
          return this.finishOp(types.plusMin, 1);
        }
      }, "readToken_plus_min");
      Tokenizer2.prototype.readToken_lt_gt = /* @__PURE__ */ __name(function readToken_lt_gt(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.state.pos + size) === 61)
            return this.finishOp(types.assign, size + 1);
          return this.finishOp(types.bitShift, size);
        }
        if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
          if (this.inModule)
            this.unexpected();
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types.relational, size);
      }, "readToken_lt_gt");
      Tokenizer2.prototype.readToken_eq_excl = /* @__PURE__ */ __name(function readToken_eq_excl(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61)
          return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        if (code === 61 && next === 62) {
          this.state.pos += 2;
          return this.finishToken(types.arrow);
        }
        return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
      }, "readToken_eq_excl");
      Tokenizer2.prototype.getTokenFromCode = /* @__PURE__ */ __name(function getTokenFromCode(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.state.pos;
            return this.finishToken(types.parenL);
          case 41:
            ++this.state.pos;
            return this.finishToken(types.parenR);
          case 59:
            ++this.state.pos;
            return this.finishToken(types.semi);
          case 44:
            ++this.state.pos;
            return this.finishToken(types.comma);
          case 91:
            ++this.state.pos;
            return this.finishToken(types.bracketL);
          case 93:
            ++this.state.pos;
            return this.finishToken(types.bracketR);
          case 123:
            if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              return this.finishOp(types.braceBarL, 2);
            } else {
              ++this.state.pos;
              return this.finishToken(types.braceL);
            }
          case 125:
            ++this.state.pos;
            return this.finishToken(types.braceR);
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              return this.finishOp(types.doubleColon, 2);
            } else {
              ++this.state.pos;
              return this.finishToken(types.colon);
            }
          case 63:
            ++this.state.pos;
            return this.finishToken(types.question);
          case 64:
            ++this.state.pos;
            return this.finishToken(types.at);
          case 96:
            ++this.state.pos;
            return this.finishToken(types.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88)
              return this.readRadixNumber(16);
            if (next === 111 || next === 79)
              return this.readRadixNumber(8);
            if (next === 98 || next === 66)
              return this.readRadixNumber(2);
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 126:
            return this.finishOp(types.prefix, 1);
        }
        this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
      }, "getTokenFromCode");
      Tokenizer2.prototype.finishOp = /* @__PURE__ */ __name(function finishOp(type3, size) {
        var str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        return this.finishToken(type3, str);
      }, "finishOp");
      Tokenizer2.prototype.readRegexp = /* @__PURE__ */ __name(function readRegexp() {
        var start = this.state.pos;
        var escaped = void 0, inClass = void 0;
        for (; ; ) {
          if (this.state.pos >= this.input.length)
            this.raise(start, "Unterminated regular expression");
          var ch = this.input.charAt(this.state.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          }
          ++this.state.pos;
        }
        var content = this.input.slice(start, this.state.pos);
        ++this.state.pos;
        var mods = this.readWord1();
        if (mods) {
          var validFlags = /^[gmsiyu]*$/;
          if (!validFlags.test(mods))
            this.raise(start, "Invalid regular expression flag");
        }
        return this.finishToken(types.regexp, {
          pattern: content,
          flags: mods
        });
      }, "readRegexp");
      Tokenizer2.prototype.readInt = /* @__PURE__ */ __name(function readInt(radix, len) {
        var start = this.state.pos;
        var total = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = this.input.charCodeAt(this.state.pos);
          var val = void 0;
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix)
            break;
          ++this.state.pos;
          total = total * radix + val;
        }
        if (this.state.pos === start || len != null && this.state.pos - start !== len)
          return null;
        return total;
      }, "readInt");
      Tokenizer2.prototype.readRadixNumber = /* @__PURE__ */ __name(function readRadixNumber(radix) {
        this.state.pos += 2;
        var val = this.readInt(radix);
        if (val == null)
          this.raise(this.state.start + 2, "Expected number in radix " + radix);
        if (isIdentifierStart(this.fullCharCodeAtPos()))
          this.raise(this.state.pos, "Identifier directly after number");
        return this.finishToken(types.num, val);
      }, "readRadixNumber");
      Tokenizer2.prototype.readNumber = /* @__PURE__ */ __name(function readNumber(startsWithDot) {
        var start = this.state.pos;
        var octal = this.input.charCodeAt(start) === 48;
        var isFloat = false;
        if (!startsWithDot && this.readInt(10) === null)
          this.raise(start, "Invalid number");
        if (octal && this.state.pos == start + 1)
          octal = false;
        var next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !octal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45)
            ++this.state.pos;
          if (this.readInt(10) === null)
            this.raise(start, "Invalid number");
          isFloat = true;
        }
        if (isIdentifierStart(this.fullCharCodeAtPos()))
          this.raise(this.state.pos, "Identifier directly after number");
        var str = this.input.slice(start, this.state.pos);
        var val = void 0;
        if (isFloat) {
          val = parseFloat(str);
        } else if (!octal || str.length === 1) {
          val = parseInt(str, 10);
        } else if (this.state.strict) {
          this.raise(start, "Invalid number");
        } else if (/[89]/.test(str)) {
          val = parseInt(str, 10);
        } else {
          val = parseInt(str, 8);
        }
        return this.finishToken(types.num, val);
      }, "readNumber");
      Tokenizer2.prototype.readCodePoint = /* @__PURE__ */ __name(function readCodePoint(throwOnInvalid) {
        var ch = this.input.charCodeAt(this.state.pos);
        var code = void 0;
        if (ch === 123) {
          var codePos = ++this.state.pos;
          code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, throwOnInvalid);
          ++this.state.pos;
          if (code === null) {
            --this.state.invalidTemplateEscapePosition;
          } else if (code > 1114111) {
            if (throwOnInvalid) {
              this.raise(codePos, "Code point out of bounds");
            } else {
              this.state.invalidTemplateEscapePosition = codePos - 2;
              return null;
            }
          }
        } else {
          code = this.readHexChar(4, throwOnInvalid);
        }
        return code;
      }, "readCodePoint");
      Tokenizer2.prototype.readString = /* @__PURE__ */ __name(function readString(quote) {
        var out = "", chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.input.length)
            this.raise(this.state.start, "Unterminated string constant");
          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.state.pos;
          } else {
            if (isNewLine(ch))
              this.raise(this.state.start, "Unterminated string constant");
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types.string, out);
      }, "readString");
      Tokenizer2.prototype.readTmplToken = /* @__PURE__ */ __name(function readTmplToken() {
        var out = "", chunkStart = this.state.pos, containsInvalid = false;
        for (; ; ) {
          if (this.state.pos >= this.input.length)
            this.raise(this.state.start, "Unterminated template");
          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
            if (this.state.pos === this.state.start && this.match(types.template)) {
              if (ch === 36) {
                this.state.pos += 2;
                return this.finishToken(types.dollarBraceL);
              } else {
                ++this.state.pos;
                return this.finishToken(types.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.state.pos);
            return this.finishToken(types.template, containsInvalid ? null : out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            var escaped = this.readEscapedChar(true);
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            ++this.state.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.state.pos) === 10)
                  ++this.state.pos;
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
      }, "readTmplToken");
      Tokenizer2.prototype.readEscapedChar = /* @__PURE__ */ __name(function readEscapedChar(inTemplate) {
        var throwOnInvalid = !inTemplate;
        var ch = this.input.charCodeAt(++this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120: {
            var code = this.readHexChar(2, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }
          case 117: {
            var _code = this.readCodePoint(throwOnInvalid);
            return _code === null ? null : codePointToString(_code);
          }
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10)
              ++this.state.pos;
          case 10:
            this.state.lineStart = this.state.pos;
            ++this.state.curLine;
            return "";
          default:
            if (ch >= 48 && ch <= 55) {
              var codePos = this.state.pos - 1;
              var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              if (octal > 0) {
                if (inTemplate) {
                  this.state.invalidTemplateEscapePosition = codePos;
                  return null;
                } else if (this.state.strict) {
                  this.raise(codePos, "Octal literal in strict mode");
                } else if (!this.state.containsOctal) {
                  this.state.containsOctal = true;
                  this.state.octalPosition = codePos;
                }
              }
              this.state.pos += octalStr.length - 1;
              return String.fromCharCode(octal);
            }
            return String.fromCharCode(ch);
        }
      }, "readEscapedChar");
      Tokenizer2.prototype.readHexChar = /* @__PURE__ */ __name(function readHexChar(len, throwOnInvalid) {
        var codePos = this.state.pos;
        var n3 = this.readInt(16, len);
        if (n3 === null) {
          if (throwOnInvalid) {
            this.raise(codePos, "Bad character escape sequence");
          } else {
            this.state.pos = codePos - 1;
            this.state.invalidTemplateEscapePosition = codePos - 1;
          }
        }
        return n3;
      }, "readHexChar");
      Tokenizer2.prototype.readWord1 = /* @__PURE__ */ __name(function readWord1() {
        this.state.containsEsc = false;
        var word = "", first = true, chunkStart = this.state.pos;
        while (this.state.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            var escStart = this.state.pos;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.state.pos;
            var esc = this.readCodePoint(true);
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
              this.raise(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.state.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }, "readWord1");
      Tokenizer2.prototype.readWord = /* @__PURE__ */ __name(function readWord() {
        var word = this.readWord1();
        var type3 = types.name;
        if (!this.state.containsEsc && this.isKeyword(word)) {
          type3 = keywords[word];
        }
        return this.finishToken(type3, word);
      }, "readWord");
      Tokenizer2.prototype.braceIsBlock = /* @__PURE__ */ __name(function braceIsBlock(prevType) {
        if (prevType === types.colon) {
          var parent = this.curContext();
          if (parent === types$1.braceStatement || parent === types$1.braceExpression) {
            return !parent.isExpr;
          }
        }
        if (prevType === types._return) {
          return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
        }
        if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {
          return true;
        }
        if (prevType === types.braceL) {
          return this.curContext() === types$1.braceStatement;
        }
        return !this.state.exprAllowed;
      }, "braceIsBlock");
      Tokenizer2.prototype.updateContext = /* @__PURE__ */ __name(function updateContext(prevType) {
        var type3 = this.state.type;
        var update = void 0;
        if (type3.keyword && prevType === types.dot) {
          this.state.exprAllowed = false;
        } else if (update = type3.updateContext) {
          update.call(this, prevType);
        } else {
          this.state.exprAllowed = type3.beforeExpr;
        }
      }, "updateContext");
      return Tokenizer2;
    }();
    var plugins = {};
    var frozenDeprecatedWildcardPluginList = ["jsx", "doExpressions", "objectRestSpread", "decorators", "classProperties", "exportExtensions", "asyncGenerators", "functionBind", "functionSent", "dynamicImport", "flow"];
    var Parser2 = function(_Tokenizer) {
      inherits(Parser3, _Tokenizer);
      function Parser3(options2, input) {
        classCallCheck(this, Parser3);
        options2 = getOptions(options2);
        var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options2, input));
        _this.options = options2;
        _this.inModule = _this.options.sourceType === "module";
        _this.input = input;
        _this.plugins = _this.loadPlugins(_this.options.plugins);
        _this.filename = options2.sourceFilename;
        if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
          _this.skipLineComment(2);
        }
        return _this;
      }
      __name(Parser3, "Parser");
      Parser3.prototype.isReservedWord = /* @__PURE__ */ __name(function isReservedWord(word) {
        if (word === "await") {
          return this.inModule;
        } else {
          return reservedWords[6](word);
        }
      }, "isReservedWord");
      Parser3.prototype.hasPlugin = /* @__PURE__ */ __name(function hasPlugin(name) {
        if (this.plugins["*"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) {
          return true;
        }
        return !!this.plugins[name];
      }, "hasPlugin");
      Parser3.prototype.extend = /* @__PURE__ */ __name(function extend(name, f) {
        this[name] = f(this[name]);
      }, "extend");
      Parser3.prototype.loadAllPlugins = /* @__PURE__ */ __name(function loadAllPlugins() {
        var _this2 = this;
        var pluginNames = Object.keys(plugins).filter(function(name) {
          return name !== "flow" && name !== "estree";
        });
        pluginNames.push("flow");
        pluginNames.forEach(function(name) {
          var plugin = plugins[name];
          if (plugin)
            plugin(_this2);
        });
      }, "loadAllPlugins");
      Parser3.prototype.loadPlugins = /* @__PURE__ */ __name(function loadPlugins2(pluginList) {
        if (pluginList.indexOf("*") >= 0) {
          this.loadAllPlugins();
          return { "*": true };
        }
        var pluginMap = {};
        if (pluginList.indexOf("flow") >= 0) {
          pluginList = pluginList.filter(function(plugin2) {
            return plugin2 !== "flow";
          });
          pluginList.push("flow");
        }
        if (pluginList.indexOf("estree") >= 0) {
          pluginList = pluginList.filter(function(plugin2) {
            return plugin2 !== "estree";
          });
          pluginList.unshift("estree");
        }
        for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var name = _ref;
          if (!pluginMap[name]) {
            pluginMap[name] = true;
            var plugin = plugins[name];
            if (plugin)
              plugin(this);
          }
        }
        return pluginMap;
      }, "loadPlugins");
      Parser3.prototype.parse = /* @__PURE__ */ __name(function parse3() {
        var file = this.startNode();
        var program = this.startNode();
        this.nextToken();
        return this.parseTopLevel(file, program);
      }, "parse");
      return Parser3;
    }(Tokenizer);
    var pp = Parser2.prototype;
    pp.addExtra = function(node, key, val) {
      if (!node)
        return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    };
    pp.isRelational = function(op) {
      return this.match(types.relational) && this.state.value === op;
    };
    pp.expectRelational = function(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    };
    pp.isContextual = function(name) {
      return this.match(types.name) && this.state.value === name;
    };
    pp.eatContextual = function(name) {
      return this.state.value === name && this.eat(types.name);
    };
    pp.expectContextual = function(name, message) {
      if (!this.eatContextual(name))
        this.unexpected(null, message);
    };
    pp.canInsertSemicolon = function() {
      return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    };
    pp.isLineTerminator = function() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    };
    pp.semicolon = function() {
      if (!this.isLineTerminator())
        this.unexpected(null, types.semi);
    };
    pp.expect = function(type3, pos) {
      return this.eat(type3) || this.unexpected(pos, type3);
    };
    pp.unexpected = function(pos) {
      var messageOrType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Unexpected token";
      if (messageOrType && (typeof messageOrType === "undefined" ? "undefined" : _typeof(messageOrType)) === "object" && messageOrType.label) {
        messageOrType = "Unexpected token, expected " + messageOrType.label;
      }
      this.raise(pos != null ? pos : this.state.start, messageOrType);
    };
    var pp$1 = Parser2.prototype;
    pp$1.parseTopLevel = function(file, program) {
      program.sourceType = this.options.sourceType;
      this.parseBlockBody(program, true, true, types.eof);
      file.program = this.finishNode(program, "Program");
      file.comments = this.state.comments;
      file.tokens = this.state.tokens;
      return this.finishNode(file, "File");
    };
    var loopLabel = { kind: "loop" };
    var switchLabel = { kind: "switch" };
    pp$1.stmtToDirective = function(stmt) {
      var expr = stmt.expression;
      var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      var directive = this.startNodeAt(stmt.start, stmt.loc.start);
      var raw = this.input.slice(expr.start, expr.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    };
    pp$1.parseStatement = function(declaration, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }
      var starttype = this.state.type;
      var node = this.startNode();
      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types._debugger:
          return this.parseDebuggerStatement(node);
        case types._do:
          return this.parseDoStatement(node);
        case types._for:
          return this.parseForStatement(node);
        case types._function:
          if (!declaration)
            this.unexpected();
          return this.parseFunctionStatement(node);
        case types._class:
          if (!declaration)
            this.unexpected();
          return this.parseClass(node, true);
        case types._if:
          return this.parseIfStatement(node);
        case types._return:
          return this.parseReturnStatement(node);
        case types._switch:
          return this.parseSwitchStatement(node);
        case types._throw:
          return this.parseThrowStatement(node);
        case types._try:
          return this.parseTryStatement(node);
        case types._let:
        case types._const:
          if (!declaration)
            this.unexpected();
        case types._var:
          return this.parseVarStatement(node, starttype);
        case types._while:
          return this.parseWhileStatement(node);
        case types._with:
          return this.parseWithStatement(node);
        case types.braceL:
          return this.parseBlock();
        case types.semi:
          return this.parseEmptyStatement(node);
        case types._export:
        case types._import:
          if (this.hasPlugin("dynamicImport") && this.lookahead().type === types.parenL)
            break;
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.state.start, `'import' and 'export' may appear only with 'sourceType: "module"'`);
            }
          }
          return starttype === types._import ? this.parseImport(node) : this.parseExport(node);
        case types.name:
          if (this.state.value === "async") {
            var state = this.state.clone();
            this.next();
            if (this.match(types._function) && !this.canInsertSemicolon()) {
              this.expect(types._function);
              return this.parseFunction(node, true, false, true);
            } else {
              this.state = state;
            }
          }
      }
      var maybeName = this.state.value;
      var expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    };
    pp$1.takeDecorators = function(node) {
      if (this.state.decorators.length) {
        node.decorators = this.state.decorators;
        this.state.decorators = [];
      }
    };
    pp$1.parseDecorators = function(allowExport) {
      while (this.match(types.at)) {
        var decorator = this.parseDecorator();
        this.state.decorators.push(decorator);
      }
      if (allowExport && this.match(types._export)) {
        return;
      }
      if (!this.match(types._class)) {
        this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
      }
    };
    pp$1.parseDecorator = function() {
      if (!this.hasPlugin("decorators")) {
        this.unexpected();
      }
      var node = this.startNode();
      this.next();
      node.expression = this.parseMaybeAssign();
      return this.finishNode(node, "Decorator");
    };
    pp$1.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.isLineTerminator()) {
        node.label = null;
      } else if (!this.match(types.name)) {
        this.unexpected();
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }
      var i = void 0;
      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop"))
            break;
          if (node.label && isBreak)
            break;
        }
      }
      if (i === this.state.labels.length)
        this.raise(node.start, "Unsyntactic " + keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$1.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    pp$1.parseDoStatement = function(node) {
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseParenExpression();
      this.eat(types.semi);
      return this.finishNode(node, "DoWhileStatement");
    };
    pp$1.parseForStatement = function(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var forAwait = false;
      if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
        forAwait = true;
        this.next();
      }
      this.expect(types.parenL);
      if (this.match(types.semi)) {
        if (forAwait) {
          this.unexpected();
        }
        return this.parseFor(node, null);
      }
      if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {
        var _init = this.startNode();
        var varKind = this.state.type;
        this.next();
        this.parseVar(_init, true, varKind);
        this.finishNode(_init, "VariableDeclaration");
        if (this.match(types._in) || this.isContextual("of")) {
          if (_init.declarations.length === 1 && !_init.declarations[0].init) {
            return this.parseForIn(node, _init, forAwait);
          }
        }
        if (forAwait) {
          this.unexpected();
        }
        return this.parseFor(node, _init);
      }
      var refShorthandDefaultPos = { start: 0 };
      var init = this.parseExpression(true, refShorthandDefaultPos);
      if (this.match(types._in) || this.isContextual("of")) {
        var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        this.toAssignable(init, void 0, description);
        this.checkLVal(init, void 0, void 0, description);
        return this.parseForIn(node, init, forAwait);
      } else if (refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      if (forAwait) {
        this.unexpected();
      }
      return this.parseFor(node, init);
    };
    pp$1.parseFunctionStatement = function(node) {
      this.next();
      return this.parseFunction(node, true);
    };
    pp$1.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement(false);
      node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;
      return this.finishNode(node, "IfStatement");
    };
    pp$1.parseReturnStatement = function(node) {
      if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, "'return' outside of function");
      }
      this.next();
      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    pp$1.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      var cur = void 0;
      for (var sawDefault; !this.match(types.braceR); ) {
        if (this.match(types._case) || this.match(types._default)) {
          var isCase = this.match(types._case);
          if (cur)
            this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault)
              this.raise(this.state.lastTokStart, "Multiple default clauses");
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(true));
          } else {
            this.unexpected();
          }
        }
      }
      if (cur)
        this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    pp$1.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)))
        this.raise(this.state.lastTokEnd, "Illegal newline after throw");
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    var empty = [];
    pp$1.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.match(types._catch)) {
        var clause = this.startNode();
        this.next();
        this.expect(types.parenL);
        clause.param = this.parseBindingAtom();
        this.checkLVal(clause.param, true, /* @__PURE__ */ Object.create(null), "catch clause");
        this.expect(types.parenR);
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.guardedHandlers = empty;
      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }
      return this.finishNode(node, "TryStatement");
    };
    pp$1.parseVarStatement = function(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    pp$1.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.state.labels.push(loopLabel);
      node.body = this.parseStatement(false);
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    pp$1.parseWithStatement = function(node) {
      if (this.state.strict)
        this.raise(this.state.start, "'with' in strict mode");
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement(false);
      return this.finishNode(node, "WithStatement");
    };
    pp$1.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    pp$1.parseLabeledStatement = function(node, maybeName, expr) {
      for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var _label = _ref;
        if (_label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;
      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var label = this.state.labels[i];
        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }
      this.state.labels.push({ name: maybeName, kind, statementStart: this.state.start });
      node.body = this.parseStatement(true);
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    pp$1.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    pp$1.parseBlock = function(allowDirectives) {
      var node = this.startNode();
      this.expect(types.braceL);
      this.parseBlockBody(node, allowDirectives, false, types.braceR);
      return this.finishNode(node, "BlockStatement");
    };
    pp$1.isValidDirective = function(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    };
    pp$1.parseBlockBody = function(node, allowDirectives, topLevel, end) {
      node.body = [];
      node.directives = [];
      var parsedNonDirective = false;
      var oldStrict = void 0;
      var octalPosition = void 0;
      while (!this.eat(end)) {
        if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
          octalPosition = this.state.octalPosition;
        }
        var stmt = this.parseStatement(true, topLevel);
        if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) {
          var directive = this.stmtToDirective(stmt);
          node.directives.push(directive);
          if (oldStrict === void 0 && directive.value.value === "use strict") {
            oldStrict = this.state.strict;
            this.setStrict(true);
            if (octalPosition) {
              this.raise(octalPosition, "Octal literal in strict mode");
            }
          }
          continue;
        }
        parsedNonDirective = true;
        node.body.push(stmt);
      }
      if (oldStrict === false) {
        this.setStrict(false);
      }
    };
    pp$1.parseFor = function(node, init) {
      node.init = init;
      this.expect(types.semi);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.parseStatement(false);
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    pp$1.parseForIn = function(node, init, forAwait) {
      var type3 = void 0;
      if (forAwait) {
        this.eatContextual("of");
        type3 = "ForAwaitStatement";
      } else {
        type3 = this.match(types._in) ? "ForInStatement" : "ForOfStatement";
        this.next();
      }
      node.left = init;
      node.right = this.parseExpression();
      this.expect(types.parenR);
      node.body = this.parseStatement(false);
      this.state.labels.pop();
      return this.finishNode(node, type3);
    };
    pp$1.parseVar = function(node, isFor, kind) {
      node.declarations = [];
      node.kind = kind.keyword;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarHead(decl);
        if (this.eat(types.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) {
          this.unexpected();
        } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
          this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma))
          break;
      }
      return node;
    };
    pp$1.parseVarHead = function(decl) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, true, void 0, "variable declaration");
    };
    pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync, optionalId) {
      var oldInMethod = this.state.inMethod;
      this.state.inMethod = false;
      this.initFunction(node, isAsync);
      if (this.match(types.star)) {
        if (node.async && !this.hasPlugin("asyncGenerators")) {
          this.unexpected();
        } else {
          node.generator = true;
          this.next();
        }
      }
      if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {
        this.unexpected();
      }
      if (this.match(types.name) || this.match(types._yield)) {
        node.id = this.parseBindingIdentifier();
      }
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody);
      this.state.inMethod = oldInMethod;
      return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$1.parseFunctionParams = function(node) {
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR);
    };
    pp$1.parseClass = function(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      this.parseClassBody(node);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$1.isClassProperty = function() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    };
    pp$1.isClassMethod = function() {
      return this.match(types.parenL);
    };
    pp$1.isNonstaticConstructor = function(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    };
    pp$1.parseClassBody = function(node) {
      var oldStrict = this.state.strict;
      this.state.strict = true;
      var hadConstructorCall = false;
      var hadConstructor = false;
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (this.eat(types.semi)) {
          if (decorators.length > 0) {
            this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon");
          }
          continue;
        }
        if (this.match(types.at)) {
          decorators.push(this.parseDecorator());
          continue;
        }
        var method = this.startNode();
        if (decorators.length) {
          method.decorators = decorators;
          decorators = [];
        }
        method.static = false;
        if (this.match(types.name) && this.state.value === "static") {
          var key = this.parseIdentifier(true);
          if (this.isClassMethod()) {
            method.kind = "method";
            method.computed = false;
            method.key = key;
            this.parseClassMethod(classBody, method, false, false);
            continue;
          } else if (this.isClassProperty()) {
            method.computed = false;
            method.key = key;
            classBody.body.push(this.parseClassProperty(method));
            continue;
          }
          method.static = true;
        }
        if (this.eat(types.star)) {
          method.kind = "method";
          this.parsePropertyName(method);
          if (this.isNonstaticConstructor(method)) {
            this.raise(method.key.start, "Constructor can't be a generator");
          }
          if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) {
            this.raise(method.key.start, "Classes may not have static property named prototype");
          }
          this.parseClassMethod(classBody, method, true, false);
        } else {
          var isSimple = this.match(types.name);
          var _key = this.parsePropertyName(method);
          if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) {
            this.raise(method.key.start, "Classes may not have static property named prototype");
          }
          if (this.isClassMethod()) {
            if (this.isNonstaticConstructor(method)) {
              if (hadConstructor) {
                this.raise(_key.start, "Duplicate constructor in the same class");
              } else if (method.decorators) {
                this.raise(method.start, "You can't attach decorators to a class constructor");
              }
              hadConstructor = true;
              method.kind = "constructor";
            } else {
              method.kind = "method";
            }
            this.parseClassMethod(classBody, method, false, false);
          } else if (this.isClassProperty()) {
            if (this.isNonstaticConstructor(method)) {
              this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'");
            }
            classBody.body.push(this.parseClassProperty(method));
          } else if (isSimple && _key.name === "async" && !this.isLineTerminator()) {
            var isGenerator = this.hasPlugin("asyncGenerators") && this.eat(types.star);
            method.kind = "method";
            this.parsePropertyName(method);
            if (this.isNonstaticConstructor(method)) {
              this.raise(method.key.start, "Constructor can't be an async function");
            }
            this.parseClassMethod(classBody, method, isGenerator, true);
          } else if (isSimple && (_key.name === "get" || _key.name === "set") && !(this.isLineTerminator() && this.match(types.star))) {
            method.kind = _key.name;
            this.parsePropertyName(method);
            if (this.isNonstaticConstructor(method)) {
              this.raise(method.key.start, "Constructor can't have get/set modifier");
            }
            this.parseClassMethod(classBody, method, false, false);
            this.checkGetterSetterParamCount(method);
          } else if (this.hasPlugin("classConstructorCall") && isSimple && _key.name === "call" && this.match(types.name) && this.state.value === "constructor") {
            if (hadConstructorCall) {
              this.raise(method.start, "Duplicate constructor call in the same class");
            } else if (method.decorators) {
              this.raise(method.start, "You can't attach decorators to a class constructor");
            }
            hadConstructorCall = true;
            method.kind = "constructorCall";
            this.parsePropertyName(method);
            this.parseClassMethod(classBody, method, false, false);
          } else if (this.isLineTerminator()) {
            if (this.isNonstaticConstructor(method)) {
              this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'");
            }
            classBody.body.push(this.parseClassProperty(method));
          } else {
            this.unexpected();
          }
        }
      }
      if (decorators.length) {
        this.raise(this.state.start, "You have trailing decorators with no method");
      }
      node.body = this.finishNode(classBody, "ClassBody");
      this.state.strict = oldStrict;
    };
    pp$1.parseClassProperty = function(node) {
      this.state.inClassProperty = true;
      if (this.match(types.eq)) {
        if (!this.hasPlugin("classProperties"))
          this.unexpected();
        this.next();
        node.value = this.parseMaybeAssign();
      } else {
        node.value = null;
      }
      this.semicolon();
      this.state.inClassProperty = false;
      return this.finishNode(node, "ClassProperty");
    };
    pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
      this.parseMethod(method, isGenerator, isAsync);
      classBody.body.push(this.finishNode(method, "ClassMethod"));
    };
    pp$1.parseClassId = function(node, isStatement, optionalId) {
      if (this.match(types.name)) {
        node.id = this.parseIdentifier();
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected();
        }
      }
    };
    pp$1.parseClassSuper = function(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };
    pp$1.parseExport = function(node) {
      this.next();
      if (this.match(types.star)) {
        var specifier = this.startNode();
        this.next();
        if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
          specifier.exported = this.parseIdentifier();
          node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
          this.parseExportSpecifiersMaybe(node);
          this.parseExportFrom(node, true);
        } else {
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
      } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
        var _specifier = this.startNode();
        _specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
        if (this.match(types.comma) && this.lookahead().type === types.star) {
          this.expect(types.comma);
          var _specifier2 = this.startNode();
          this.expect(types.star);
          this.expectContextual("as");
          _specifier2.exported = this.parseIdentifier();
          node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
        } else {
          this.parseExportSpecifiersMaybe(node);
        }
        this.parseExportFrom(node, true);
      } else if (this.eat(types._default)) {
        var expr = this.startNode();
        var needsSemi = false;
        if (this.eat(types._function)) {
          expr = this.parseFunction(expr, true, false, false, true);
        } else if (this.match(types._class)) {
          expr = this.parseClass(expr, true, true);
        } else {
          needsSemi = true;
          expr = this.parseMaybeAssign();
        }
        node.declaration = expr;
        if (needsSemi)
          this.semicolon();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      } else if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
      } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers();
        this.parseExportFrom(node);
      }
      this.checkExport(node, true);
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$1.parseExportDeclaration = function() {
      return this.parseStatement(true);
    };
    pp$1.isExportDefaultSpecifier = function() {
      if (this.match(types.name)) {
        return this.state.value !== "async";
      }
      if (!this.match(types._default)) {
        return false;
      }
      var lookahead = this.lookahead();
      return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
    };
    pp$1.parseExportSpecifiersMaybe = function(node) {
      if (this.eat(types.comma)) {
        node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
      }
    };
    pp$1.parseExportFrom = function(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
        this.checkExport(node);
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }
      this.semicolon();
    };
    pp$1.shouldParseExportDeclaration = function() {
      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async");
    };
    pp$1.checkExport = function(node, checkNames, isDefault) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");
        } else if (node.specifiers && node.specifiers.length) {
          for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var specifier = _ref2;
            this.checkDuplicateExports(specifier, specifier.exported.name);
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            this.checkDuplicateExports(node, node.declaration.id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
              var _ref3;
              if (_isArray3) {
                if (_i3 >= _iterator3.length)
                  break;
                _ref3 = _iterator3[_i3++];
              } else {
                _i3 = _iterator3.next();
                if (_i3.done)
                  break;
                _ref3 = _i3.value;
              }
              var declaration = _ref3;
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }
      if (this.state.decorators.length) {
        var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
        if (!node.declaration || !isClass) {
          this.raise(node.start, "You can only use decorators on an export when exporting a class");
        }
        this.takeDecorators(node.declaration);
      }
    };
    pp$1.checkDeclaration = function(node) {
      if (node.type === "ObjectPattern") {
        for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ; ) {
          var _ref4;
          if (_isArray4) {
            if (_i4 >= _iterator4.length)
              break;
            _ref4 = _iterator4[_i4++];
          } else {
            _i4 = _iterator4.next();
            if (_i4.done)
              break;
            _ref4 = _i4.value;
          }
          var prop = _ref4;
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ; ) {
          var _ref5;
          if (_isArray5) {
            if (_i5 >= _iterator5.length)
              break;
            _ref5 = _iterator5[_i5++];
          } else {
            _i5 = _iterator5.next();
            if (_i5.done)
              break;
            _ref5 = _i5.value;
          }
          var elem = _ref5;
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement" || node.type === "RestProperty") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      }
    };
    pp$1.checkDuplicateExports = function(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raiseDuplicateExportError(node, name);
      }
      this.state.exportedIdentifiers.push(name);
    };
    pp$1.raiseDuplicateExportError = function(node, name) {
      this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
    };
    pp$1.parseExportSpecifiers = function() {
      var nodes = [];
      var first = true;
      var needsFrom = void 0;
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR))
            break;
        }
        var isDefault = this.match(types._default);
        if (isDefault && !needsFrom)
          needsFrom = true;
        var node = this.startNode();
        node.local = this.parseIdentifier(isDefault);
        node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      if (needsFrom && !this.isContextual("from")) {
        this.unexpected();
      }
      return nodes;
    };
    pp$1.parseImport = function(node) {
      this.eat(types._import);
      if (this.match(types.string)) {
        node.specifiers = [];
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = [];
        this.parseImportSpecifiers(node);
        this.expectContextual("from");
        node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    pp$1.parseImportSpecifiers = function(node) {
      var first = true;
      if (this.match(types.name)) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
        if (!this.eat(types.comma))
          return;
      }
      if (this.match(types.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        specifier.local = this.parseIdentifier();
        this.checkLVal(specifier.local, true, void 0, "import namespace specifier");
        node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
        return;
      }
      this.expect(types.braceL);
      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            this.unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
          }
          this.expect(types.comma);
          if (this.eat(types.braceR))
            break;
        }
        this.parseImportSpecifier(node);
      }
    };
    pp$1.parseImportSpecifier = function(node) {
      var specifier = this.startNode();
      specifier.imported = this.parseIdentifier(true);
      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
        specifier.local = specifier.imported.__clone();
      }
      this.checkLVal(specifier.local, true, void 0, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };
    pp$1.parseImportSpecifierDefault = function(id, startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      node.local = id;
      this.checkLVal(node.local, true, void 0, "default import specifier");
      return this.finishNode(node, "ImportDefaultSpecifier");
    };
    var pp$2 = Parser2.prototype;
    pp$2.toAssignable = function(node, isBinding, contextDescription) {
      if (node) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
              var _ref;
              if (_isArray) {
                if (_i >= _iterator.length)
                  break;
                _ref = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done)
                  break;
                _ref = _i.value;
              }
              var prop = _ref;
              if (prop.type === "ObjectMethod") {
                if (prop.kind === "get" || prop.kind === "set") {
                  this.raise(prop.key.start, "Object pattern can't contain getter or setter");
                } else {
                  this.raise(prop.key.start, "Object pattern can't contain methods");
                }
              } else {
                this.toAssignable(prop, isBinding, "object destructuring pattern");
              }
            }
            break;
          case "ObjectProperty":
            this.toAssignable(node.value, isBinding, contextDescription);
            break;
          case "SpreadProperty":
            node.type = "RestProperty";
            var arg = node.argument;
            this.toAssignable(arg, isBinding, contextDescription);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, isBinding, contextDescription);
            break;
          case "AssignmentExpression":
            if (node.operator === "=") {
              node.type = "AssignmentPattern";
              delete node.operator;
            } else {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            break;
          case "MemberExpression":
            if (!isBinding)
              break;
          default: {
            var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
            this.raise(node.start, message);
          }
        }
      }
      return node;
    };
    pp$2.toAssignableList = function(exprList, isBinding, contextDescription) {
      var end = exprList.length;
      if (end) {
        var last2 = exprList[end - 1];
        if (last2 && last2.type === "RestElement") {
          --end;
        } else if (last2 && last2.type === "SpreadElement") {
          last2.type = "RestElement";
          var arg = last2.argument;
          this.toAssignable(arg, isBinding, contextDescription);
          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
            this.unexpected(arg.start);
          }
          --end;
        }
      }
      for (var i = 0; i < end; i++) {
        var elt = exprList[i];
        if (elt)
          this.toAssignable(elt, isBinding, contextDescription);
      }
      return exprList;
    };
    pp$2.toReferencedList = function(exprList) {
      return exprList;
    };
    pp$2.parseSpread = function(refShorthandDefaultPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
      return this.finishNode(node, "SpreadElement");
    };
    pp$2.parseRest = function() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingIdentifier();
      return this.finishNode(node, "RestElement");
    };
    pp$2.shouldAllowYieldIdentifier = function() {
      return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;
    };
    pp$2.parseBindingIdentifier = function() {
      return this.parseIdentifier(this.shouldAllowYieldIdentifier());
    };
    pp$2.parseBindingAtom = function() {
      switch (this.state.type) {
        case types._yield:
          if (this.state.strict || this.state.inGenerator)
            this.unexpected();
        case types.name:
          return this.parseIdentifier(true);
        case types.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, true);
          return this.finishNode(node, "ArrayPattern");
        case types.braceL:
          return this.parseObj(true);
        default:
          this.unexpected();
      }
    };
    pp$2.parseBindingList = function(close, allowEmpty) {
      var elts = [];
      var first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }
        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRest()));
          this.expect(close);
          break;
        } else {
          var decorators = [];
          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }
          var left = this.parseMaybeDefault();
          if (decorators.length) {
            left.decorators = decorators;
          }
          this.parseAssignableListItemTypes(left);
          elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
        }
      }
      return elts;
    };
    pp$2.parseAssignableListItemTypes = function(param) {
      return param;
    };
    pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
      startLoc = startLoc || this.state.startLoc;
      startPos = startPos || this.state.start;
      left = left || this.parseBindingAtom();
      if (!this.eat(types.eq))
        return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    pp$2.checkLVal = function(expr, isBinding, checkClashes, contextDescription) {
      switch (expr.type) {
        case "Identifier":
          this.checkReservedWord(expr.name, expr.start, false, true);
          if (checkClashes) {
            var key = "_" + expr.name;
            if (checkClashes[key]) {
              this.raise(expr.start, "Argument name clash in strict mode");
            } else {
              checkClashes[key] = true;
            }
          }
          break;
        case "MemberExpression":
          if (isBinding)
            this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
          break;
        case "ObjectPattern":
          for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var prop = _ref2;
            if (prop.type === "ObjectProperty")
              prop = prop.value;
            this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
          }
          break;
        case "ArrayPattern":
          for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
            var _ref3;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref3 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref3 = _i3.value;
            }
            var elem = _ref3;
            if (elem)
              this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
          }
          break;
        case "AssignmentPattern":
          this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
          break;
        case "RestProperty":
          this.checkLVal(expr.argument, isBinding, checkClashes, "rest property");
          break;
        case "RestElement":
          this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
          break;
        default: {
          var message = (isBinding ? "Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : "expression");
          this.raise(expr.start, message);
        }
      }
    };
    var pp$3 = Parser2.prototype;
    pp$3.checkPropClash = function(prop, propHash) {
      if (prop.computed || prop.kind)
        return;
      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : String(key.value);
      if (name === "__proto__") {
        if (propHash.proto)
          this.raise(key.start, "Redefinition of __proto__ property");
        propHash.proto = true;
      }
    };
    pp$3.getExpression = function() {
      this.nextToken();
      var expr = this.parseExpression();
      if (!this.match(types.eof)) {
        this.unexpected();
      }
      return expr;
    };
    pp$3.parseExpression = function(noIn, refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
      if (this.match(types.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
        }
        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    pp$3.parseMaybeAssign = function(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      if (this.match(types._yield) && this.state.inGenerator) {
        var _left = this.parseYield();
        if (afterLeftParse)
          _left = afterLeftParse.call(this, _left, startPos, startLoc);
        return _left;
      }
      var failOnShorthandAssign = void 0;
      if (refShorthandDefaultPos) {
        failOnShorthandAssign = false;
      } else {
        refShorthandDefaultPos = { start: 0 };
        failOnShorthandAssign = true;
      }
      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }
      var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
      if (afterLeftParse)
        left = afterLeftParse.call(this, left, startPos, startLoc);
      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.state.value;
        node.left = this.match(types.eq) ? this.toAssignable(left, void 0, "assignment expression") : left;
        refShorthandDefaultPos.start = 0;
        this.checkLVal(left, void 0, void 0, "assignment expression");
        if (left.extra && left.extra.parenthesized) {
          var errorMsg = void 0;
          if (left.type === "ObjectPattern") {
            errorMsg = "`({a}) = 0` use `({a} = 0)`";
          } else if (left.type === "ArrayPattern") {
            errorMsg = "`([a]) = 0` use `([a] = 0)`";
          }
          if (errorMsg) {
            this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
          }
        }
        this.next();
        node.right = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "AssignmentExpression");
      } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
        this.unexpected(refShorthandDefaultPos.start);
      }
      return left;
    };
    pp$3.parseMaybeConditional = function(noIn, refShorthandDefaultPos, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start)
        return expr;
      return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    };
    pp$3.parseConditional = function(expr, noIn, startPos, startLoc) {
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign(noIn);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    pp$3.parseExprOps = function(noIn, refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeUnary(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        return expr;
      } else {
        return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
      }
    };
    pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      var prec = this.state.type.binop;
      if (prec != null && (!noIn || !this.match(types._in))) {
        if (prec > minPrec) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
            this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
          }
          var op = this.state.type;
          this.next();
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
          this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? "LogicalExpression" : "BinaryExpression");
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
      }
      return left;
    };
    pp$3.parseMaybeUnary = function(refShorthandDefaultPos) {
      if (this.state.type.prefix) {
        var node = this.startNode();
        var update = this.match(types.incDec);
        node.operator = this.state.value;
        node.prefix = true;
        this.next();
        var argType = this.state.type;
        node.argument = this.parseMaybeUnary();
        this.addExtra(node, "parenthesizedArgument", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));
        if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
          this.unexpected(refShorthandDefaultPos.start);
        }
        if (update) {
          this.checkLVal(node.argument, void 0, void 0, "prefix operation");
        } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
          this.raise(node.start, "Deleting local variable in strict mode");
        }
        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refShorthandDefaultPos);
      if (refShorthandDefaultPos && refShorthandDefaultPos.start)
        return expr;
      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node = this.startNodeAt(startPos, startLoc);
        _node.operator = this.state.value;
        _node.prefix = false;
        _node.argument = expr;
        this.checkLVal(expr, void 0, void 0, "postfix operation");
        this.next();
        expr = this.finishNode(_node, "UpdateExpression");
      }
      return expr;
    };
    pp$3.parseExprSubscripts = function(refShorthandDefaultPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refShorthandDefaultPos);
      if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
        return expr;
      }
      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
        return expr;
      }
      return this.parseSubscripts(expr, startPos, startLoc);
    };
    pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
      for (; ; ) {
        if (!noCalls && this.eat(types.doubleColon)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.callee = this.parseNoCallExpr();
          return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
        } else if (this.eat(types.dot)) {
          var _node2 = this.startNodeAt(startPos, startLoc);
          _node2.object = base;
          _node2.property = this.parseIdentifier(true);
          _node2.computed = false;
          base = this.finishNode(_node2, "MemberExpression");
        } else if (this.eat(types.bracketL)) {
          var _node3 = this.startNodeAt(startPos, startLoc);
          _node3.object = base;
          _node3.property = this.parseExpression();
          _node3.computed = true;
          this.expect(types.bracketR);
          base = this.finishNode(_node3, "MemberExpression");
        } else if (!noCalls && this.match(types.parenL)) {
          var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
          this.next();
          var _node4 = this.startNodeAt(startPos, startLoc);
          _node4.callee = base;
          _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
          if (_node4.callee.type === "Import" && _node4.arguments.length !== 1) {
            this.raise(_node4.start, "import() requires exactly one argument");
          }
          base = this.finishNode(_node4, "CallExpression");
          if (possibleAsync && this.shouldParseAsyncArrow()) {
            return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
          } else {
            this.toReferencedList(_node4.arguments);
          }
        } else if (this.match(types.backQuote)) {
          var _node5 = this.startNodeAt(startPos, startLoc);
          _node5.tag = base;
          _node5.quasi = this.parseTemplate(true);
          base = this.finishNode(_node5, "TaggedTemplateExpression");
        } else {
          return base;
        }
      }
    };
    pp$3.parseCallExpressionArguments = function(close, possibleAsyncArrow) {
      var elts = [];
      var innerParenStart = void 0;
      var first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(close))
            break;
        }
        if (this.match(types.parenL) && !innerParenStart) {
          innerParenStart = this.state.start;
        }
        elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : void 0, possibleAsyncArrow ? { start: 0 } : void 0));
      }
      if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
        this.unexpected();
      }
      return elts;
    };
    pp$3.shouldParseAsyncArrow = function() {
      return this.match(types.arrow);
    };
    pp$3.parseAsyncArrowFromCallExpression = function(node, call) {
      this.expect(types.arrow);
      return this.parseArrowExpression(node, call.arguments, true);
    };
    pp$3.parseNoCallExpr = function() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    };
    pp$3.parseExprAtom = function(refShorthandDefaultPos) {
      var canBeArrow = this.state.potentialArrowAt === this.state.start;
      var node = void 0;
      switch (this.state.type) {
        case types._super:
          if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {
            this.raise(this.state.start, "'super' outside of function or class");
          }
          node = this.startNode();
          this.next();
          if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
            this.unexpected();
          }
          if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
            this.raise(node.start, "super() outside of class constructor");
          }
          return this.finishNode(node, "Super");
        case types._import:
          if (!this.hasPlugin("dynamicImport"))
            this.unexpected();
          node = this.startNode();
          this.next();
          if (!this.match(types.parenL)) {
            this.unexpected(null, types.parenL);
          }
          return this.finishNode(node, "Import");
        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types._yield:
          if (this.state.inGenerator)
            this.unexpected();
        case types.name:
          node = this.startNode();
          var allowAwait = this.state.value === "await" && this.state.inAsync;
          var allowYield = this.shouldAllowYieldIdentifier();
          var id = this.parseIdentifier(allowAwait || allowYield);
          if (id.name === "await") {
            if (this.state.inAsync || this.inModule) {
              return this.parseAwait(node);
            }
          } else if (id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
            this.next();
            return this.parseFunction(node, false, false, true);
          } else if (canBeArrow && id.name === "async" && this.match(types.name)) {
            var params = [this.parseIdentifier()];
            this.expect(types.arrow);
            return this.parseArrowExpression(node, params, true);
          }
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            return this.parseArrowExpression(node, [id]);
          }
          return id;
        case types._do:
          if (this.hasPlugin("doExpressions")) {
            var _node6 = this.startNode();
            this.next();
            var oldInFunction = this.state.inFunction;
            var oldLabels = this.state.labels;
            this.state.labels = [];
            this.state.inFunction = false;
            _node6.body = this.parseBlock(false, true);
            this.state.inFunction = oldInFunction;
            this.state.labels = oldLabels;
            return this.finishNode(_node6, "DoExpression");
          }
        case types.regexp:
          var value = this.state.value;
          node = this.parseLiteral(value.value, "RegExpLiteral");
          node.pattern = value.pattern;
          node.flags = value.flags;
          return node;
        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");
        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");
        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");
        case types._true:
        case types._false:
          node = this.startNode();
          node.value = this.match(types._true);
          this.next();
          return this.finishNode(node, "BooleanLiteral");
        case types.parenL:
          return this.parseParenAndDistinguishExpression(null, null, canBeArrow);
        case types.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);
          this.toReferencedList(node.elements);
          return this.finishNode(node, "ArrayExpression");
        case types.braceL:
          return this.parseObj(false, refShorthandDefaultPos);
        case types._function:
          return this.parseFunctionExpression();
        case types.at:
          this.parseDecorators();
        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);
        case types._new:
          return this.parseNew();
        case types.backQuote:
          return this.parseTemplate(false);
        case types.doubleColon:
          node = this.startNode();
          this.next();
          node.object = null;
          var callee = node.callee = this.parseNoCallExpr();
          if (callee.type === "MemberExpression") {
            return this.finishNode(node, "BindExpression");
          } else {
            this.raise(callee.start, "Binding should be performed on object property.");
          }
        default:
          this.unexpected();
      }
    };
    pp$3.parseFunctionExpression = function() {
      var node = this.startNode();
      var meta = this.parseIdentifier(true);
      if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin("functionSent")) {
        return this.parseMetaProperty(node, meta, "sent");
      } else {
        return this.parseFunction(node, false);
      }
    };
    pp$3.parseMetaProperty = function(node, meta, propertyName) {
      node.meta = meta;
      node.property = this.parseIdentifier(true);
      if (node.property.name !== propertyName) {
        this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
      }
      return this.finishNode(node, "MetaProperty");
    };
    pp$3.parseLiteral = function(value, type3, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type3);
    };
    pp$3.parseParenExpression = function() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    };
    pp$3.parseParenAndDistinguishExpression = function(startPos, startLoc, canBeArrow) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var val = void 0;
      this.expect(types.parenL);
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refShorthandDefaultPos = { start: 0 };
      var refNeedsArrowPos = { start: 0 };
      var first = true;
      var spreadStart = void 0;
      var optionalCommaStart = void 0;
      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);
          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }
        if (this.match(types.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
        }
      }
      var innerEndPos = this.state.start;
      var innerEndLoc = this.state.startLoc;
      this.expect(types.parenR);
      var arrowNode = this.startNodeAt(startPos, startLoc);
      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var param = _ref;
          if (param.extra && param.extra.parenthesized)
            this.unexpected(param.extra.parenStart);
        }
        return this.parseArrowExpression(arrowNode, exprList);
      }
      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }
      if (optionalCommaStart)
        this.unexpected(optionalCommaStart);
      if (spreadStart)
        this.unexpected(spreadStart);
      if (refShorthandDefaultPos.start)
        this.unexpected(refShorthandDefaultPos.start);
      if (refNeedsArrowPos.start)
        this.unexpected(refNeedsArrowPos.start);
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.toReferencedList(val.expressions);
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
      this.addExtra(val, "parenthesized", true);
      this.addExtra(val, "parenStart", startPos);
      return val;
    };
    pp$3.shouldParseArrow = function() {
      return !this.canInsertSemicolon();
    };
    pp$3.parseArrow = function(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    };
    pp$3.parseParenItem = function(node) {
      return node;
    };
    pp$3.parseNew = function() {
      var node = this.startNode();
      var meta = this.parseIdentifier(true);
      if (this.eat(types.dot)) {
        var metaProp = this.parseMetaProperty(node, meta, "target");
        if (!this.state.inFunction) {
          this.raise(metaProp.property.start, "new.target can only be used in functions");
        }
        return metaProp;
      }
      node.callee = this.parseNoCallExpr();
      if (this.eat(types.parenL)) {
        node.arguments = this.parseExprList(types.parenR);
        this.toReferencedList(node.arguments);
      } else {
        node.arguments = [];
      }
      return this.finishNode(node, "NewExpression");
    };
    pp$3.parseTemplateElement = function(isTagged) {
      var elem = this.startNode();
      if (this.state.value === null) {
        if (!isTagged || !this.hasPlugin("templateInvalidEscapes")) {
          this.raise(this.state.invalidTemplateEscapePosition, "Invalid escape sequence in template");
        } else {
          this.state.invalidTemplateEscapePosition = null;
        }
      }
      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, "TemplateElement");
    };
    pp$3.parseTemplate = function(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];
      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    pp$3.parseObj = function(isPattern, refShorthandDefaultPos) {
      var decorators = [];
      var propHash = /* @__PURE__ */ Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();
      var firstRestLocation = null;
      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR))
            break;
        }
        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
        var prop = this.startNode(), isGenerator = false, isAsync = false, startPos = void 0, startLoc = void 0;
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        if (this.hasPlugin("objectRestSpread") && this.match(types.ellipsis)) {
          prop = this.parseSpread(isPattern ? { start: 0 } : void 0);
          prop.type = isPattern ? "RestProperty" : "SpreadProperty";
          if (isPattern)
            this.toAssignable(prop.argument, true, "object pattern");
          node.properties.push(prop);
          if (isPattern) {
            var position = this.state.start;
            if (firstRestLocation !== null) {
              this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
            } else if (this.eat(types.braceR)) {
              break;
            } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {
              continue;
            } else {
              firstRestLocation = position;
              continue;
            }
          } else {
            continue;
          }
        }
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refShorthandDefaultPos) {
          startPos = this.state.start;
          startLoc = this.state.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types.star);
        }
        if (!isPattern && this.isContextual("async")) {
          if (isGenerator)
            this.unexpected();
          var asyncId = this.parseIdentifier();
          if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
            prop.key = asyncId;
            prop.computed = false;
          } else {
            isAsync = true;
            if (this.hasPlugin("asyncGenerators"))
              isGenerator = this.eat(types.star);
            this.parsePropertyName(prop);
          }
        } else {
          this.parsePropertyName(prop);
        }
        this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
        this.checkPropClash(prop, propHash);
        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }
        node.properties.push(prop);
      }
      if (firstRestLocation !== null) {
        this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring");
      }
      if (decorators.length) {
        this.raise(this.state.start, "You have trailing decorators with no property");
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$3.isGetterOrSetterMethod = function(prop, isPattern) {
      return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || this.state.type.keyword);
    };
    pp$3.checkGetterSetterParamCount = function(method) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.params.length !== paramCount) {
        var start = method.start;
        if (method.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
    };
    pp$3.parseObjectMethod = function(prop, isGenerator, isAsync, isPattern) {
      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern)
          this.unexpected();
        prop.kind = "method";
        prop.method = true;
        this.parseMethod(prop, isGenerator, isAsync);
        return this.finishNode(prop, "ObjectMethod");
      }
      if (this.isGetterOrSetterMethod(prop, isPattern)) {
        if (isGenerator || isAsync)
          this.unexpected();
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        this.parseMethod(prop);
        this.checkGetterSetterParamCount(prop);
        return this.finishNode(prop, "ObjectMethod");
      }
    };
    pp$3.parseObjectProperty = function(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
        return this.finishNode(prop, "ObjectProperty");
      }
      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, true);
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types.eq) && refShorthandDefaultPos) {
          if (!refShorthandDefaultPos.start) {
            refShorthandDefaultPos.start = this.state.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }
        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    };
    pp$3.parseObjPropValue = function(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);
      if (!node)
        this.unexpected();
      return node;
    };
    pp$3.parsePropertyName = function(prop) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
      } else {
        prop.computed = false;
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
        this.state.inPropertyName = oldInPropertyName;
      }
      return prop.key;
    };
    pp$3.initFunction = function(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.expression = false;
      node.async = !!isAsync;
    };
    pp$3.parseMethod = function(node, isGenerator, isAsync) {
      var oldInMethod = this.state.inMethod;
      this.state.inMethod = node.kind || true;
      this.initFunction(node, isAsync);
      this.expect(types.parenL);
      node.params = this.parseBindingList(types.parenR);
      node.generator = !!isGenerator;
      this.parseFunctionBody(node);
      this.state.inMethod = oldInMethod;
      return node;
    };
    pp$3.parseArrowExpression = function(node, params, isAsync) {
      this.initFunction(node, isAsync);
      node.params = this.toAssignableList(params, true, "arrow function parameters");
      this.parseFunctionBody(node, true);
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    pp$3.isStrictBody = function(node, isExpression) {
      if (!isExpression && node.body.directives.length) {
        for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var directive = _ref2;
          if (directive.value.value === "use strict") {
            return true;
          }
        }
      }
      return false;
    };
    pp$3.parseFunctionBody = function(node, allowExpression) {
      var isExpression = allowExpression && !this.match(types.braceL);
      var oldInAsync = this.state.inAsync;
      this.state.inAsync = node.async;
      if (isExpression) {
        node.body = this.parseMaybeAssign();
        node.expression = true;
      } else {
        var oldInFunc = this.state.inFunction;
        var oldInGen = this.state.inGenerator;
        var oldLabels = this.state.labels;
        this.state.inFunction = true;
        this.state.inGenerator = node.generator;
        this.state.labels = [];
        node.body = this.parseBlock(true);
        node.expression = false;
        this.state.inFunction = oldInFunc;
        this.state.inGenerator = oldInGen;
        this.state.labels = oldLabels;
      }
      this.state.inAsync = oldInAsync;
      var isStrict = this.isStrictBody(node, isExpression);
      var checkLVal = this.state.strict || allowExpression || isStrict;
      if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
        this.raise(node.id.start, "Binding yield in strict mode");
      }
      if (checkLVal) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        var oldStrict = this.state.strict;
        if (isStrict)
          this.state.strict = true;
        if (node.id) {
          this.checkLVal(node.id, true, void 0, "function name");
        }
        for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var param = _ref3;
          if (isStrict && param.type !== "Identifier") {
            this.raise(param.start, "Non-simple parameter in strict mode");
          }
          this.checkLVal(param, true, nameHash, "function parameter list");
        }
        this.state.strict = oldStrict;
      }
    };
    pp$3.parseExprList = function(close, allowEmpty, refShorthandDefaultPos) {
      var elts = [];
      var first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(close))
            break;
        }
        elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
      }
      return elts;
    };
    pp$3.parseExprListItem = function(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {
      var elt = void 0;
      if (allowEmpty && this.match(types.comma)) {
        elt = null;
      } else if (this.match(types.ellipsis)) {
        elt = this.parseSpread(refShorthandDefaultPos);
      } else {
        elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
      }
      return elt;
    };
    pp$3.parseIdentifier = function(liberal) {
      var node = this.startNode();
      if (!liberal) {
        this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);
      }
      if (this.match(types.name)) {
        node.name = this.state.value;
      } else if (this.state.type.keyword) {
        node.name = this.state.type.keyword;
      } else {
        this.unexpected();
      }
      if (!liberal && node.name === "await" && this.state.inAsync) {
        this.raise(node.start, "invalid use of await inside of an async function");
      }
      node.loc.identifierName = node.name;
      this.next();
      return this.finishNode(node, "Identifier");
    };
    pp$3.checkReservedWord = function(word, startLoc, checkKeywords, isBinding) {
      if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {
        this.raise(startLoc, word + " is a reserved word");
      }
      if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {
        this.raise(startLoc, word + " is a reserved word in strict mode");
      }
    };
    pp$3.parseAwait = function(node) {
      if (!this.state.inAsync) {
        this.unexpected();
      }
      if (this.match(types.star)) {
        this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
      }
      node.argument = this.parseMaybeUnary();
      return this.finishNode(node, "AwaitExpression");
    };
    pp$3.parseYield = function() {
      var node = this.startNode();
      this.next();
      if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign();
      }
      return this.finishNode(node, "YieldExpression");
    };
    var pp$4 = Parser2.prototype;
    var commentKeys = ["leadingComments", "trailingComments", "innerComments"];
    var Node17 = function() {
      function Node18(pos, loc, filename) {
        classCallCheck(this, Node18);
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (filename)
          this.loc.filename = filename;
      }
      __name(Node18, "Node");
      Node18.prototype.__clone = /* @__PURE__ */ __name(function __clone() {
        var node2 = new Node18();
        for (var key in this) {
          if (commentKeys.indexOf(key) < 0) {
            node2[key] = this[key];
          }
        }
        return node2;
      }, "__clone");
      return Node18;
    }();
    pp$4.startNode = function() {
      return new Node17(this.state.start, this.state.startLoc, this.filename);
    };
    pp$4.startNodeAt = function(pos, loc) {
      return new Node17(pos, loc, this.filename);
    };
    function finishNodeAt(node, type3, pos, loc) {
      node.type = type3;
      node.end = pos;
      node.loc.end = loc;
      this.processComment(node);
      return node;
    }
    __name(finishNodeAt, "finishNodeAt");
    pp$4.finishNode = function(node, type3) {
      return finishNodeAt.call(this, node, type3, this.state.lastTokEnd, this.state.lastTokEndLoc);
    };
    pp$4.finishNodeAt = function(node, type3, pos, loc) {
      return finishNodeAt.call(this, node, type3, pos, loc);
    };
    var pp$5 = Parser2.prototype;
    pp$5.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      throw err;
    };
    function last(stack) {
      return stack[stack.length - 1];
    }
    __name(last, "last");
    var pp$6 = Parser2.prototype;
    pp$6.addComment = function(comment) {
      if (this.filename)
        comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    };
    pp$6.processComment = function(node) {
      if (node.type === "Program" && node.body.length > 0)
        return;
      var stack = this.state.commentStack;
      var firstChild = void 0, lastChild = void 0, trailingComments = void 0, i = void 0, j = void 0;
      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else {
        var lastInStack = last(stack);
        if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          lastInStack.trailingComments = null;
        }
      }
      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }
      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }
      if (!lastChild && firstChild)
        lastChild = firstChild;
      if (firstChild && this.state.leadingComments.length > 0) {
        var lastComment = last(this.state.leadingComments);
        if (firstChild.type === "ObjectProperty") {
          if (lastComment.start >= node.start) {
            if (this.state.commentPreviousNode) {
              for (j = 0; j < this.state.leadingComments.length; j++) {
                if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                  this.state.leadingComments.splice(j, 1);
                  j--;
                }
              }
              if (this.state.leadingComments.length > 0) {
                firstChild.trailingComments = this.state.leadingComments;
                this.state.leadingComments = [];
              }
            }
          }
        } else if (node.type === "CallExpression" && node.arguments && node.arguments.length) {
          var lastArg = last(node.arguments);
          if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {
            if (this.state.commentPreviousNode) {
              if (this.state.leadingComments.length > 0) {
                lastArg.trailingComments = this.state.leadingComments;
                this.state.leadingComments = [];
              }
            }
          }
        }
      }
      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            lastChild.leadingComments = null;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }
          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }
          node.leadingComments = this.state.leadingComments.slice(0, i);
          if (node.leadingComments.length === 0) {
            node.leadingComments = null;
          }
          trailingComments = this.state.leadingComments.slice(i);
          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }
      this.state.commentPreviousNode = node;
      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          node.trailingComments = trailingComments;
        }
      }
      stack.push(node);
    };
    var pp$7 = Parser2.prototype;
    pp$7.estreeParseRegExpLiteral = function(_ref) {
      var pattern = _ref.pattern, flags = _ref.flags;
      var regex = null;
      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {
      }
      var node = this.estreeParseLiteral(regex);
      node.regex = { pattern, flags };
      return node;
    };
    pp$7.estreeParseLiteral = function(value) {
      return this.parseLiteral(value, "Literal");
    };
    pp$7.directiveToStmt = function(directive) {
      var directiveLiteral = directive.value;
      var stmt = this.startNodeAt(directive.start, directive.loc.start);
      var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
      expression.value = directiveLiteral.value;
      expression.raw = directiveLiteral.extra.raw;
      stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
      return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
    };
    function isSimpleProperty(node) {
      return node && node.type === "Property" && node.kind === "init" && node.method === false;
    }
    __name(isSimpleProperty, "isSimpleProperty");
    var estreePlugin = /* @__PURE__ */ __name(function(instance) {
      instance.extend("checkDeclaration", function(inner) {
        return function(node) {
          if (isSimpleProperty(node)) {
            this.checkDeclaration(node.value);
          } else {
            inner.call(this, node);
          }
        };
      });
      instance.extend("checkGetterSetterParamCount", function() {
        return function(prop) {
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.start;
            if (prop.kind === "get") {
              this.raise(start, "getter should have no params");
            } else {
              this.raise(start, "setter should have exactly one param");
            }
          }
        };
      });
      instance.extend("checkLVal", function(inner) {
        return function(expr, isBinding, checkClashes) {
          var _this = this;
          switch (expr.type) {
            case "ObjectPattern":
              expr.properties.forEach(function(prop) {
                _this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern");
              });
              break;
            default:
              for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
                args[_key - 3] = arguments[_key];
              }
              inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args));
          }
        };
      });
      instance.extend("checkPropClash", function() {
        return function(prop, propHash) {
          if (prop.computed || !isSimpleProperty(prop))
            return;
          var key = prop.key;
          var name = key.type === "Identifier" ? key.name : String(key.value);
          if (name === "__proto__") {
            if (propHash.proto)
              this.raise(key.start, "Redefinition of __proto__ property");
            propHash.proto = true;
          }
        };
      });
      instance.extend("isStrictBody", function() {
        return function(node, isExpression) {
          if (!isExpression && node.body.body.length > 0) {
            for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
              var _ref2;
              if (_isArray) {
                if (_i >= _iterator.length)
                  break;
                _ref2 = _iterator[_i++];
              } else {
                _i = _iterator.next();
                if (_i.done)
                  break;
                _ref2 = _i.value;
              }
              var directive = _ref2;
              if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
                if (directive.expression.value === "use strict")
                  return true;
              } else {
                break;
              }
            }
          }
          return false;
        };
      });
      instance.extend("isValidDirective", function() {
        return function(stmt) {
          return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
        };
      });
      instance.extend("stmtToDirective", function(inner) {
        return function(stmt) {
          var directive = inner.call(this, stmt);
          var value = stmt.expression.value;
          directive.value.value = value;
          return directive;
        };
      });
      instance.extend("parseBlockBody", function(inner) {
        return function(node) {
          var _this2 = this;
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          inner.call.apply(inner, [this, node].concat(args));
          node.directives.reverse().forEach(function(directive) {
            node.body.unshift(_this2.directiveToStmt(directive));
          });
          delete node.directives;
        };
      });
      instance.extend("parseClassMethod", function() {
        return function(classBody, method, isGenerator, isAsync) {
          this.parseMethod(method, isGenerator, isAsync);
          if (method.typeParameters) {
            method.value.typeParameters = method.typeParameters;
            delete method.typeParameters;
          }
          classBody.body.push(this.finishNode(method, "MethodDefinition"));
        };
      });
      instance.extend("parseExprAtom", function(inner) {
        return function() {
          switch (this.state.type) {
            case types.regexp:
              return this.estreeParseRegExpLiteral(this.state.value);
            case types.num:
            case types.string:
              return this.estreeParseLiteral(this.state.value);
            case types._null:
              return this.estreeParseLiteral(null);
            case types._true:
              return this.estreeParseLiteral(true);
            case types._false:
              return this.estreeParseLiteral(false);
            default:
              for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              return inner.call.apply(inner, [this].concat(args));
          }
        };
      });
      instance.extend("parseLiteral", function(inner) {
        return function() {
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          var node = inner.call.apply(inner, [this].concat(args));
          node.raw = node.extra.raw;
          delete node.extra;
          return node;
        };
      });
      instance.extend("parseMethod", function(inner) {
        return function(node) {
          var funcNode = this.startNode();
          funcNode.kind = node.kind;
          for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
            args[_key5 - 1] = arguments[_key5];
          }
          funcNode = inner.call.apply(inner, [this, funcNode].concat(args));
          delete funcNode.kind;
          node.value = this.finishNode(funcNode, "FunctionExpression");
          return node;
        };
      });
      instance.extend("parseObjectMethod", function(inner) {
        return function() {
          for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          var node = inner.call.apply(inner, [this].concat(args));
          if (node) {
            if (node.kind === "method")
              node.kind = "init";
            node.type = "Property";
          }
          return node;
        };
      });
      instance.extend("parseObjectProperty", function(inner) {
        return function() {
          for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          var node = inner.call.apply(inner, [this].concat(args));
          if (node) {
            node.kind = "init";
            node.type = "Property";
          }
          return node;
        };
      });
      instance.extend("toAssignable", function(inner) {
        return function(node, isBinding) {
          for (var _len8 = arguments.length, args = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
            args[_key8 - 2] = arguments[_key8];
          }
          if (isSimpleProperty(node)) {
            this.toAssignable.apply(this, [node.value, isBinding].concat(args));
            return node;
          } else if (node.type === "ObjectExpression") {
            node.type = "ObjectPattern";
            for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
              var _ref3;
              if (_isArray2) {
                if (_i2 >= _iterator2.length)
                  break;
                _ref3 = _iterator2[_i2++];
              } else {
                _i2 = _iterator2.next();
                if (_i2.done)
                  break;
                _ref3 = _i2.value;
              }
              var prop = _ref3;
              if (prop.kind === "get" || prop.kind === "set") {
                this.raise(prop.key.start, "Object pattern can't contain getter or setter");
              } else if (prop.method) {
                this.raise(prop.key.start, "Object pattern can't contain methods");
              } else {
                this.toAssignable(prop, isBinding, "object destructuring pattern");
              }
            }
            return node;
          }
          return inner.call.apply(inner, [this, node, isBinding].concat(args));
        };
      });
    }, "estreePlugin");
    var primitiveTypes = ["any", "mixed", "empty", "bool", "boolean", "number", "string", "void", "null"];
    var pp$8 = Parser2.prototype;
    pp$8.flowParseTypeInitialiser = function(tok) {
      var oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || types.colon);
      var type3 = this.flowParseType();
      this.state.inType = oldInType;
      return type3;
    };
    pp$8.flowParsePredicate = function() {
      var node = this.startNode();
      var moduloLoc = this.state.startLoc;
      var moduloPos = this.state.start;
      this.expect(types.modulo);
      var checksLoc = this.state.startLoc;
      this.expectContextual("checks");
      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
        this.raise(moduloPos, "Spaces between \xB4%\xB4 and \xB4checks\xB4 are not allowed here.");
      }
      if (this.eat(types.parenL)) {
        node.expression = this.parseExpression();
        this.expect(types.parenR);
        return this.finishNode(node, "DeclaredPredicate");
      } else {
        return this.finishNode(node, "InferredPredicate");
      }
    };
    pp$8.flowParseTypeAndPredicateInitialiser = function() {
      var oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(types.colon);
      var type3 = null;
      var predicate = null;
      if (this.match(types.modulo)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type3 = this.flowParseType();
        this.state.inType = oldInType;
        if (this.match(types.modulo)) {
          predicate = this.flowParsePredicate();
        }
      }
      return [type3, predicate];
    };
    pp$8.flowParseDeclareClass = function(node) {
      this.next();
      this.flowParseInterfaceish(node, true);
      return this.finishNode(node, "DeclareClass");
    };
    pp$8.flowParseDeclareFunction = function(node) {
      this.next();
      var id = node.id = this.parseIdentifier();
      var typeNode = this.startNode();
      var typeContainer = this.startNode();
      if (this.isRelational("<")) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }
      this.expect(types.parenL);
      var tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      this.expect(types.parenR);
      var predicate = null;
      var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();
      typeNode.returnType = _flowParseTypeAndPred[0];
      predicate = _flowParseTypeAndPred[1];
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      typeContainer.predicate = predicate;
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.finishNode(id, id.type);
      this.semicolon();
      return this.finishNode(node, "DeclareFunction");
    };
    pp$8.flowParseDeclare = function(node) {
      if (this.match(types._class)) {
        return this.flowParseDeclareClass(node);
      } else if (this.match(types._function)) {
        return this.flowParseDeclareFunction(node);
      } else if (this.match(types._var)) {
        return this.flowParseDeclareVariable(node);
      } else if (this.isContextual("module")) {
        if (this.lookahead().type === types.dot) {
          return this.flowParseDeclareModuleExports(node);
        } else {
          return this.flowParseDeclareModule(node);
        }
      } else if (this.isContextual("type")) {
        return this.flowParseDeclareTypeAlias(node);
      } else if (this.isContextual("opaque")) {
        return this.flowParseDeclareOpaqueType(node);
      } else if (this.isContextual("interface")) {
        return this.flowParseDeclareInterface(node);
      } else if (this.match(types._export)) {
        return this.flowParseDeclareExportDeclaration(node);
      } else {
        this.unexpected();
      }
    };
    pp$8.flowParseDeclareExportDeclaration = function(node) {
      this.expect(types._export);
      if (this.isContextual("opaque")) {
        node.declaration = this.flowParseDeclare(this.startNode());
        node.default = false;
        return this.finishNode(node, "DeclareExportDeclaration");
      }
      throw this.unexpected();
    };
    pp$8.flowParseDeclareVariable = function(node) {
      this.next();
      node.id = this.flowParseTypeAnnotatableIdentifier();
      this.semicolon();
      return this.finishNode(node, "DeclareVariable");
    };
    pp$8.flowParseDeclareModule = function(node) {
      this.next();
      if (this.match(types.string)) {
        node.id = this.parseExprAtom();
      } else {
        node.id = this.parseIdentifier();
      }
      var bodyNode = node.body = this.startNode();
      var body = bodyNode.body = [];
      this.expect(types.braceL);
      while (!this.match(types.braceR)) {
        var _bodyNode = this.startNode();
        if (this.match(types._import)) {
          var lookahead = this.lookahead();
          if (lookahead.value !== "type" && lookahead.value !== "typeof") {
            this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`");
          }
          this.parseImport(_bodyNode);
        } else {
          this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");
          _bodyNode = this.flowParseDeclare(_bodyNode, true);
        }
        body.push(_bodyNode);
      }
      this.expect(types.braceR);
      this.finishNode(bodyNode, "BlockStatement");
      return this.finishNode(node, "DeclareModule");
    };
    pp$8.flowParseDeclareModuleExports = function(node) {
      this.expectContextual("module");
      this.expect(types.dot);
      this.expectContextual("exports");
      node.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node, "DeclareModuleExports");
    };
    pp$8.flowParseDeclareTypeAlias = function(node) {
      this.next();
      this.flowParseTypeAlias(node);
      return this.finishNode(node, "DeclareTypeAlias");
    };
    pp$8.flowParseDeclareOpaqueType = function(node) {
      this.next();
      this.flowParseOpaqueType(node, true);
      return this.finishNode(node, "DeclareOpaqueType");
    };
    pp$8.flowParseDeclareInterface = function(node) {
      this.next();
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "DeclareInterface");
    };
    pp$8.flowParseInterfaceish = function(node) {
      node.id = this.parseIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.extends = [];
      node.mixins = [];
      if (this.eat(types._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(types.comma));
      }
      if (this.isContextual("mixins")) {
        this.next();
        do {
          node.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(types.comma));
      }
      node.body = this.flowParseObjectType(true, false, false);
    };
    pp$8.flowParseInterfaceExtends = function() {
      var node = this.startNode();
      node.id = this.flowParseQualifiedTypeIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node.typeParameters = null;
      }
      return this.finishNode(node, "InterfaceExtends");
    };
    pp$8.flowParseInterface = function(node) {
      this.flowParseInterfaceish(node, false);
      return this.finishNode(node, "InterfaceDeclaration");
    };
    pp$8.flowParseRestrictedIdentifier = function(liberal) {
      if (primitiveTypes.indexOf(this.state.value) > -1) {
        this.raise(this.state.start, "Cannot overwrite primitive type " + this.state.value);
      }
      return this.parseIdentifier(liberal);
    };
    pp$8.flowParseTypeAlias = function(node) {
      node.id = this.flowParseRestrictedIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.right = this.flowParseTypeInitialiser(types.eq);
      this.semicolon();
      return this.finishNode(node, "TypeAlias");
    };
    pp$8.flowParseOpaqueType = function(node, declare) {
      this.expectContextual("type");
      node.id = this.flowParseRestrictedIdentifier();
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }
      node.supertype = null;
      if (this.match(types.colon)) {
        node.supertype = this.flowParseTypeInitialiser(types.colon);
      }
      node.impltype = null;
      if (!declare) {
        node.impltype = this.flowParseTypeInitialiser(types.eq);
      }
      this.semicolon();
      return this.finishNode(node, "OpaqueType");
    };
    pp$8.flowParseTypeParameter = function() {
      var node = this.startNode();
      var variance = this.flowParseVariance();
      var ident = this.flowParseTypeAnnotatableIdentifier();
      node.name = ident.name;
      node.variance = variance;
      node.bound = ident.typeAnnotation;
      if (this.match(types.eq)) {
        this.eat(types.eq);
        node.default = this.flowParseType();
      }
      return this.finishNode(node, "TypeParameter");
    };
    pp$8.flowParseTypeParameterDeclaration = function() {
      var oldInType = this.state.inType;
      var node = this.startNode();
      node.params = [];
      this.state.inType = true;
      if (this.isRelational("<") || this.match(types.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }
      do {
        node.params.push(this.flowParseTypeParameter());
        if (!this.isRelational(">")) {
          this.expect(types.comma);
        }
      } while (!this.isRelational(">"));
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterDeclaration");
    };
    pp$8.flowParseTypeParameterInstantiation = function() {
      var node = this.startNode();
      var oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");
      while (!this.isRelational(">")) {
        node.params.push(this.flowParseType());
        if (!this.isRelational(">")) {
          this.expect(types.comma);
        }
      }
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    };
    pp$8.flowParseObjectPropertyKey = function() {
      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    };
    pp$8.flowParseObjectTypeIndexer = function(node, isStatic, variance) {
      node.static = isStatic;
      this.expect(types.bracketL);
      if (this.lookahead().type === types.colon) {
        node.id = this.flowParseObjectPropertyKey();
        node.key = this.flowParseTypeInitialiser();
      } else {
        node.id = null;
        node.key = this.flowParseType();
      }
      this.expect(types.bracketR);
      node.value = this.flowParseTypeInitialiser();
      node.variance = variance;
      this.flowObjectTypeSemicolon();
      return this.finishNode(node, "ObjectTypeIndexer");
    };
    pp$8.flowParseObjectTypeMethodish = function(node) {
      node.params = [];
      node.rest = null;
      node.typeParameters = null;
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.expect(types.parenL);
      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        node.params.push(this.flowParseFunctionTypeParam());
        if (!this.match(types.parenR)) {
          this.expect(types.comma);
        }
      }
      if (this.eat(types.ellipsis)) {
        node.rest = this.flowParseFunctionTypeParam();
      }
      this.expect(types.parenR);
      node.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node, "FunctionTypeAnnotation");
    };
    pp$8.flowParseObjectTypeMethod = function(startPos, startLoc, isStatic, key) {
      var node = this.startNodeAt(startPos, startLoc);
      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
      node.static = isStatic;
      node.key = key;
      node.optional = false;
      this.flowObjectTypeSemicolon();
      return this.finishNode(node, "ObjectTypeProperty");
    };
    pp$8.flowParseObjectTypeCallProperty = function(node, isStatic) {
      var valueNode = this.startNode();
      node.static = isStatic;
      node.value = this.flowParseObjectTypeMethodish(valueNode);
      this.flowObjectTypeSemicolon();
      return this.finishNode(node, "ObjectTypeCallProperty");
    };
    pp$8.flowParseObjectType = function(allowStatic, allowExact, allowSpread) {
      var oldInType = this.state.inType;
      this.state.inType = true;
      var nodeStart = this.startNode();
      var node = void 0;
      var propertyKey = void 0;
      var isStatic = false;
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      var endDelim = void 0;
      var exact = void 0;
      if (allowExact && this.match(types.braceBarL)) {
        this.expect(types.braceBarL);
        endDelim = types.braceBarR;
        exact = true;
      } else {
        this.expect(types.braceL);
        endDelim = types.braceR;
        exact = false;
      }
      nodeStart.exact = exact;
      while (!this.match(endDelim)) {
        var optional = false;
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        node = this.startNode();
        if (allowStatic && this.isContextual("static") && this.lookahead().type !== types.colon) {
          this.next();
          isStatic = true;
        }
        var variancePos = this.state.start;
        var variance = this.flowParseVariance();
        if (this.match(types.bracketL)) {
          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
        } else if (this.match(types.parenL) || this.isRelational("<")) {
          if (variance) {
            this.unexpected(variancePos);
          }
          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
        } else {
          if (this.match(types.ellipsis)) {
            if (!allowSpread) {
              this.unexpected(null, "Spread operator cannot appear in class or interface definitions");
            }
            if (variance) {
              this.unexpected(variance.start, "Spread properties cannot have variance");
            }
            this.expect(types.ellipsis);
            node.argument = this.flowParseType();
            this.flowObjectTypeSemicolon();
            nodeStart.properties.push(this.finishNode(node, "ObjectTypeSpreadProperty"));
          } else {
            propertyKey = this.flowParseObjectPropertyKey();
            if (this.isRelational("<") || this.match(types.parenL)) {
              if (variance) {
                this.unexpected(variance.start);
              }
              nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
            } else {
              if (this.eat(types.question)) {
                optional = true;
              }
              node.key = propertyKey;
              node.value = this.flowParseTypeInitialiser();
              node.optional = optional;
              node.static = isStatic;
              node.variance = variance;
              this.flowObjectTypeSemicolon();
              nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
            }
          }
        }
        isStatic = false;
      }
      this.expect(endDelim);
      var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    };
    pp$8.flowObjectTypeSemicolon = function() {
      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
        this.unexpected();
      }
    };
    pp$8.flowParseQualifiedTypeIdentifier = function(startPos, startLoc, id) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var node = id || this.parseIdentifier();
      while (this.eat(types.dot)) {
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.qualification = node;
        node2.id = this.parseIdentifier();
        node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }
      return node;
    };
    pp$8.flowParseGenericType = function(startPos, startLoc, id) {
      var node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = null;
      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      }
      return this.finishNode(node, "GenericTypeAnnotation");
    };
    pp$8.flowParseTypeofType = function() {
      var node = this.startNode();
      this.expect(types._typeof);
      node.argument = this.flowParsePrimaryType();
      return this.finishNode(node, "TypeofTypeAnnotation");
    };
    pp$8.flowParseTupleType = function() {
      var node = this.startNode();
      node.types = [];
      this.expect(types.bracketL);
      while (this.state.pos < this.input.length && !this.match(types.bracketR)) {
        node.types.push(this.flowParseType());
        if (this.match(types.bracketR))
          break;
        this.expect(types.comma);
      }
      this.expect(types.bracketR);
      return this.finishNode(node, "TupleTypeAnnotation");
    };
    pp$8.flowParseFunctionTypeParam = function() {
      var name = null;
      var optional = false;
      var typeAnnotation = null;
      var node = this.startNode();
      var lh = this.lookahead();
      if (lh.type === types.colon || lh.type === types.question) {
        name = this.parseIdentifier();
        if (this.eat(types.question)) {
          optional = true;
        }
        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }
      node.name = name;
      node.optional = optional;
      node.typeAnnotation = typeAnnotation;
      return this.finishNode(node, "FunctionTypeParam");
    };
    pp$8.reinterpretTypeAsFunctionTypeParam = function(type3) {
      var node = this.startNodeAt(type3.start, type3.loc.start);
      node.name = null;
      node.optional = false;
      node.typeAnnotation = type3;
      return this.finishNode(node, "FunctionTypeParam");
    };
    pp$8.flowParseFunctionTypeParams = function() {
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var ret = { params, rest: null };
      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        ret.params.push(this.flowParseFunctionTypeParam());
        if (!this.match(types.parenR)) {
          this.expect(types.comma);
        }
      }
      if (this.eat(types.ellipsis)) {
        ret.rest = this.flowParseFunctionTypeParam();
      }
      return ret;
    };
    pp$8.flowIdentToTypeAnnotation = function(startPos, startLoc, node, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");
        case "void":
          return this.finishNode(node, "VoidTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(node, "StringTypeAnnotation");
        default:
          return this.flowParseGenericType(startPos, startLoc, id);
      }
    };
    pp$8.flowParsePrimaryType = function() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var node = this.startNode();
      var tmp = void 0;
      var type3 = void 0;
      var isGroupedType = false;
      var oldNoAnonFunctionType = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case types.name:
          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
        case types.braceL:
          return this.flowParseObjectType(false, false, true);
        case types.braceBarL:
          return this.flowParseObjectType(false, true, true);
        case types.bracketL:
          return this.flowParseTupleType();
        case types.relational:
          if (this.state.value === "<") {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(types.parenL);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            this.expect(types.parenR);
            this.expect(types.arrow);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          }
          break;
        case types.parenL:
          this.next();
          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
            if (this.match(types.name)) {
              var token = this.lookahead().type;
              isGroupedType = token !== types.question && token !== types.colon;
            } else {
              isGroupedType = true;
            }
          }
          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type3 = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
              this.expect(types.parenR);
              return type3;
            } else {
              this.eat(types.comma);
            }
          }
          if (type3) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type3)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }
          node.params = tmp.params;
          node.rest = tmp.rest;
          this.expect(types.parenR);
          this.expect(types.arrow);
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case types._true:
        case types._false:
          node.value = this.match(types._true);
          this.next();
          return this.finishNode(node, "BooleanLiteralTypeAnnotation");
        case types.plusMin:
          if (this.state.value === "-") {
            this.next();
            if (!this.match(types.num))
              this.unexpected(null, "Unexpected token, expected number");
            return this.parseLiteral(-this.state.value, "NumericLiteralTypeAnnotation", node.start, node.loc.start);
          }
          this.unexpected();
        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteralTypeAnnotation");
        case types._null:
          node.value = this.match(types._null);
          this.next();
          return this.finishNode(node, "NullLiteralTypeAnnotation");
        case types._this:
          node.value = this.match(types._this);
          this.next();
          return this.finishNode(node, "ThisTypeAnnotation");
        case types.star:
          this.next();
          return this.finishNode(node, "ExistentialTypeParam");
        default:
          if (this.state.type.keyword === "typeof") {
            return this.flowParseTypeofType();
          }
      }
      this.unexpected();
    };
    pp$8.flowParsePostfixType = function() {
      var startPos = this.state.start, startLoc = this.state.startLoc;
      var type3 = this.flowParsePrimaryType();
      while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.elementType = type3;
        this.expect(types.bracketL);
        this.expect(types.bracketR);
        type3 = this.finishNode(node, "ArrayTypeAnnotation");
      }
      return type3;
    };
    pp$8.flowParsePrefixType = function() {
      var node = this.startNode();
      if (this.eat(types.question)) {
        node.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    };
    pp$8.flowParseAnonFunctionWithoutParens = function() {
      var param = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
        var node = this.startNodeAt(param.start, param.loc.start);
        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node.rest = null;
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      return param;
    };
    pp$8.flowParseIntersectionType = function() {
      var node = this.startNode();
      this.eat(types.bitwiseAND);
      var type3 = this.flowParseAnonFunctionWithoutParens();
      node.types = [type3];
      while (this.eat(types.bitwiseAND)) {
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      }
      return node.types.length === 1 ? type3 : this.finishNode(node, "IntersectionTypeAnnotation");
    };
    pp$8.flowParseUnionType = function() {
      var node = this.startNode();
      this.eat(types.bitwiseOR);
      var type3 = this.flowParseIntersectionType();
      node.types = [type3];
      while (this.eat(types.bitwiseOR)) {
        node.types.push(this.flowParseIntersectionType());
      }
      return node.types.length === 1 ? type3 : this.finishNode(node, "UnionTypeAnnotation");
    };
    pp$8.flowParseType = function() {
      var oldInType = this.state.inType;
      this.state.inType = true;
      var type3 = this.flowParseUnionType();
      this.state.inType = oldInType;
      return type3;
    };
    pp$8.flowParseTypeAnnotation = function() {
      var node = this.startNode();
      node.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node, "TypeAnnotation");
    };
    pp$8.flowParseTypeAndPredicateAnnotation = function() {
      var node = this.startNode();
      var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();
      node.typeAnnotation = _flowParseTypeAndPred2[0];
      node.predicate = _flowParseTypeAndPred2[1];
      return this.finishNode(node, "TypeAnnotation");
    };
    pp$8.flowParseTypeAnnotatableIdentifier = function() {
      var ident = this.flowParseRestrictedIdentifier();
      if (this.match(types.colon)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(ident, ident.type);
      }
      return ident;
    };
    pp$8.typeCastToParameter = function(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
    };
    pp$8.flowParseVariance = function() {
      var variance = null;
      if (this.match(types.plusMin)) {
        if (this.state.value === "+") {
          variance = "plus";
        } else if (this.state.value === "-") {
          variance = "minus";
        }
        this.next();
      }
      return variance;
    };
    var flowPlugin = /* @__PURE__ */ __name(function(instance) {
      instance.extend("parseFunctionBody", function(inner) {
        return function(node, allowExpression) {
          if (this.match(types.colon) && !allowExpression) {
            node.returnType = this.flowParseTypeAndPredicateAnnotation();
          }
          return inner.call(this, node, allowExpression);
        };
      });
      instance.extend("parseStatement", function(inner) {
        return function(declaration, topLevel) {
          if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
            var node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          } else {
            return inner.call(this, declaration, topLevel);
          }
        };
      });
      instance.extend("parseExpressionStatement", function(inner) {
        return function(node, expr) {
          if (expr.type === "Identifier") {
            if (expr.name === "declare") {
              if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
                return this.flowParseDeclare(node);
              }
            } else if (this.match(types.name)) {
              if (expr.name === "interface") {
                return this.flowParseInterface(node);
              } else if (expr.name === "type") {
                return this.flowParseTypeAlias(node);
              } else if (expr.name === "opaque") {
                return this.flowParseOpaqueType(node, false);
              }
            }
          }
          return inner.call(this, node, expr);
        };
      });
      instance.extend("shouldParseExportDeclaration", function(inner) {
        return function() {
          return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || inner.call(this);
        };
      });
      instance.extend("isExportDefaultSpecifier", function(inner) {
        return function() {
          if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque")) {
            return false;
          }
          return inner.call(this);
        };
      });
      instance.extend("parseConditional", function(inner) {
        return function(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
          if (refNeedsArrowPos && this.match(types.question)) {
            var state = this.state.clone();
            try {
              return inner.call(this, expr, noIn, startPos, startLoc);
            } catch (err) {
              if (err instanceof SyntaxError) {
                this.state = state;
                refNeedsArrowPos.start = err.pos || this.state.start;
                return expr;
              } else {
                throw err;
              }
            }
          }
          return inner.call(this, expr, noIn, startPos, startLoc);
        };
      });
      instance.extend("parseParenItem", function(inner) {
        return function(node, startPos, startLoc) {
          node = inner.call(this, node, startPos, startLoc);
          if (this.eat(types.question)) {
            node.optional = true;
          }
          if (this.match(types.colon)) {
            var typeCastNode = this.startNodeAt(startPos, startLoc);
            typeCastNode.expression = node;
            typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(typeCastNode, "TypeCastExpression");
          }
          return node;
        };
      });
      instance.extend("parseExport", function(inner) {
        return function(node) {
          node = inner.call(this, node);
          if (node.type === "ExportNamedDeclaration") {
            node.exportKind = node.exportKind || "value";
          }
          return node;
        };
      });
      instance.extend("parseExportDeclaration", function(inner) {
        return function(node) {
          if (this.isContextual("type")) {
            node.exportKind = "type";
            var declarationNode = this.startNode();
            this.next();
            if (this.match(types.braceL)) {
              node.specifiers = this.parseExportSpecifiers();
              this.parseExportFrom(node);
              return null;
            } else {
              return this.flowParseTypeAlias(declarationNode);
            }
          } else if (this.isContextual("opaque")) {
            node.exportKind = "type";
            var _declarationNode = this.startNode();
            this.next();
            return this.flowParseOpaqueType(_declarationNode, false);
          } else if (this.isContextual("interface")) {
            node.exportKind = "type";
            var _declarationNode2 = this.startNode();
            this.next();
            return this.flowParseInterface(_declarationNode2);
          } else {
            return inner.call(this, node);
          }
        };
      });
      instance.extend("parseClassId", function(inner) {
        return function(node) {
          inner.apply(this, arguments);
          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
        };
      });
      instance.extend("isKeyword", function(inner) {
        return function(name) {
          if (this.state.inType && name === "void") {
            return false;
          } else {
            return inner.call(this, name);
          }
        };
      });
      instance.extend("readToken", function(inner) {
        return function(code) {
          if (this.state.inType && (code === 62 || code === 60)) {
            return this.finishOp(types.relational, 1);
          } else {
            return inner.call(this, code);
          }
        };
      });
      instance.extend("jsx_readToken", function(inner) {
        return function() {
          if (!this.state.inType)
            return inner.call(this);
        };
      });
      instance.extend("toAssignable", function(inner) {
        return function(node, isBinding, contextDescription) {
          if (node.type === "TypeCastExpression") {
            return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
          } else {
            return inner.call(this, node, isBinding, contextDescription);
          }
        };
      });
      instance.extend("toAssignableList", function(inner) {
        return function(exprList, isBinding, contextDescription) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];
            if (expr && expr.type === "TypeCastExpression") {
              exprList[i] = this.typeCastToParameter(expr);
            }
          }
          return inner.call(this, exprList, isBinding, contextDescription);
        };
      });
      instance.extend("toReferencedList", function() {
        return function(exprList) {
          for (var i = 0; i < exprList.length; i++) {
            var expr = exprList[i];
            if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
              this.raise(expr.start, "Unexpected type cast");
            }
          }
          return exprList;
        };
      });
      instance.extend("parseExprListItem", function(inner) {
        return function() {
          var container = this.startNode();
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var node = inner.call.apply(inner, [this].concat(args));
          if (this.match(types.colon)) {
            container._exprListItem = true;
            container.expression = node;
            container.typeAnnotation = this.flowParseTypeAnnotation();
            return this.finishNode(container, "TypeCastExpression");
          } else {
            return node;
          }
        };
      });
      instance.extend("checkLVal", function(inner) {
        return function(node) {
          if (node.type !== "TypeCastExpression") {
            return inner.apply(this, arguments);
          }
        };
      });
      instance.extend("parseClassProperty", function(inner) {
        return function(node) {
          delete node.variancePos;
          if (this.match(types.colon)) {
            node.typeAnnotation = this.flowParseTypeAnnotation();
          }
          return inner.call(this, node);
        };
      });
      instance.extend("isClassMethod", function(inner) {
        return function() {
          return this.isRelational("<") || inner.call(this);
        };
      });
      instance.extend("isClassProperty", function(inner) {
        return function() {
          return this.match(types.colon) || inner.call(this);
        };
      });
      instance.extend("isNonstaticConstructor", function(inner) {
        return function(method) {
          return !this.match(types.colon) && inner.call(this, method);
        };
      });
      instance.extend("parseClassMethod", function(inner) {
        return function(classBody, method) {
          if (method.variance) {
            this.unexpected(method.variancePos);
          }
          delete method.variance;
          delete method.variancePos;
          if (this.isRelational("<")) {
            method.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }
          inner.call.apply(inner, [this, classBody, method].concat(args));
        };
      });
      instance.extend("parseClassSuper", function(inner) {
        return function(node, isStatement) {
          inner.call(this, node, isStatement);
          if (node.superClass && this.isRelational("<")) {
            node.superTypeParameters = this.flowParseTypeParameterInstantiation();
          }
          if (this.isContextual("implements")) {
            this.next();
            var implemented = node.implements = [];
            do {
              var _node = this.startNode();
              _node.id = this.parseIdentifier();
              if (this.isRelational("<")) {
                _node.typeParameters = this.flowParseTypeParameterInstantiation();
              } else {
                _node.typeParameters = null;
              }
              implemented.push(this.finishNode(_node, "ClassImplements"));
            } while (this.eat(types.comma));
          }
        };
      });
      instance.extend("parsePropertyName", function(inner) {
        return function(node) {
          var variancePos = this.state.start;
          var variance = this.flowParseVariance();
          var key = inner.call(this, node);
          node.variance = variance;
          node.variancePos = variancePos;
          return key;
        };
      });
      instance.extend("parseObjPropValue", function(inner) {
        return function(prop) {
          if (prop.variance) {
            this.unexpected(prop.variancePos);
          }
          delete prop.variance;
          delete prop.variancePos;
          var typeParameters = void 0;
          if (this.isRelational("<")) {
            typeParameters = this.flowParseTypeParameterDeclaration();
            if (!this.match(types.parenL))
              this.unexpected();
          }
          inner.apply(this, arguments);
          if (typeParameters) {
            (prop.value || prop).typeParameters = typeParameters;
          }
        };
      });
      instance.extend("parseAssignableListItemTypes", function() {
        return function(param) {
          if (this.eat(types.question)) {
            param.optional = true;
          }
          if (this.match(types.colon)) {
            param.typeAnnotation = this.flowParseTypeAnnotation();
          }
          this.finishNode(param, param.type);
          return param;
        };
      });
      instance.extend("parseMaybeDefault", function(inner) {
        return function() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          var node = inner.apply(this, args);
          if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
            this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
          }
          return node;
        };
      });
      instance.extend("parseImportSpecifiers", function(inner) {
        return function(node) {
          node.importKind = "value";
          var kind = null;
          if (this.match(types._typeof)) {
            kind = "typeof";
          } else if (this.isContextual("type")) {
            kind = "type";
          }
          if (kind) {
            var lh = this.lookahead();
            if (lh.type === types.name && lh.value !== "from" || lh.type === types.braceL || lh.type === types.star) {
              this.next();
              node.importKind = kind;
            }
          }
          inner.call(this, node);
        };
      });
      instance.extend("parseImportSpecifier", function() {
        return function(node) {
          var specifier = this.startNode();
          var firstIdentLoc = this.state.start;
          var firstIdent = this.parseIdentifier(true);
          var specifierTypeKind = null;
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
          var isBinding = false;
          if (this.isContextual("as")) {
            var as_ident = this.parseIdentifier(true);
            if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
              specifier.imported = as_ident;
              specifier.importKind = specifierTypeKind;
              specifier.local = as_ident.__clone();
            } else {
              specifier.imported = firstIdent;
              specifier.importKind = null;
              specifier.local = this.parseIdentifier();
            }
          } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
            if (this.eatContextual("as")) {
              specifier.local = this.parseIdentifier();
            } else {
              isBinding = true;
              specifier.local = specifier.imported.__clone();
            }
          } else {
            isBinding = true;
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = specifier.imported.__clone();
          }
          if ((node.importKind === "type" || node.importKind === "typeof") && (specifier.importKind === "type" || specifier.importKind === "typeof")) {
            this.raise(firstIdentLoc, "`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`");
          }
          if (isBinding)
            this.checkReservedWord(specifier.local.name, specifier.start, true, true);
          this.checkLVal(specifier.local, true, void 0, "import specifier");
          node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
        };
      });
      instance.extend("parseFunctionParams", function(inner) {
        return function(node) {
          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
          }
          inner.call(this, node);
        };
      });
      instance.extend("parseVarHead", function(inner) {
        return function(decl) {
          inner.call(this, decl);
          if (this.match(types.colon)) {
            decl.id.typeAnnotation = this.flowParseTypeAnnotation();
            this.finishNode(decl.id, decl.id.type);
          }
        };
      });
      instance.extend("parseAsyncArrowFromCallExpression", function(inner) {
        return function(node, call) {
          if (this.match(types.colon)) {
            var oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            node.returnType = this.flowParseTypeAnnotation();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
          }
          return inner.call(this, node, call);
        };
      });
      instance.extend("shouldParseAsyncArrow", function(inner) {
        return function() {
          return this.match(types.colon) || inner.call(this);
        };
      });
      instance.extend("parseMaybeAssign", function(inner) {
        return function() {
          var jsxError = null;
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          if (types.jsxTagStart && this.match(types.jsxTagStart)) {
            var state = this.state.clone();
            try {
              return inner.apply(this, args);
            } catch (err) {
              if (err instanceof SyntaxError) {
                this.state = state;
                this.state.context.length -= 2;
                jsxError = err;
              } else {
                throw err;
              }
            }
          }
          if (jsxError != null || this.isRelational("<")) {
            var arrowExpression = void 0;
            var typeParameters = void 0;
            try {
              typeParameters = this.flowParseTypeParameterDeclaration();
              arrowExpression = inner.apply(this, args);
              arrowExpression.typeParameters = typeParameters;
              arrowExpression.start = typeParameters.start;
              arrowExpression.loc.start = typeParameters.loc.start;
            } catch (err) {
              throw jsxError || err;
            }
            if (arrowExpression.type === "ArrowFunctionExpression") {
              return arrowExpression;
            } else if (jsxError != null) {
              throw jsxError;
            } else {
              this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
            }
          }
          return inner.apply(this, args);
        };
      });
      instance.extend("parseArrow", function(inner) {
        return function(node) {
          if (this.match(types.colon)) {
            var state = this.state.clone();
            try {
              var oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true;
              var returnType = this.flowParseTypeAndPredicateAnnotation();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.canInsertSemicolon())
                this.unexpected();
              if (!this.match(types.arrow))
                this.unexpected();
              node.returnType = returnType;
            } catch (err) {
              if (err instanceof SyntaxError) {
                this.state = state;
              } else {
                throw err;
              }
            }
          }
          return inner.call(this, node);
        };
      });
      instance.extend("shouldParseArrow", function(inner) {
        return function() {
          return this.match(types.colon) || inner.call(this);
        };
      });
    }, "flowPlugin");
    var fromCodePoint2 = String.fromCodePoint;
    if (!fromCodePoint2) {
      stringFromCharCode = String.fromCharCode;
      floor = Math.floor;
      fromCodePoint2 = /* @__PURE__ */ __name(function fromCodePoint3() {
        var MAX_SIZE = 16384;
        var codeUnits = [];
        var highSurrogate = void 0;
        var lowSurrogate = void 0;
        var index = -1;
        var length = arguments.length;
        if (!length) {
          return "";
        }
        var result = "";
        while (++index < length) {
          var codePoint = Number(arguments[index]);
          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) != codePoint) {
            throw RangeError("Invalid code point: " + codePoint);
          }
          if (codePoint <= 65535) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 65536;
            highSurrogate = (codePoint >> 10) + 55296;
            lowSurrogate = codePoint % 1024 + 56320;
            codeUnits.push(highSurrogate, lowSurrogate);
          }
          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }
        return result;
      }, "fromCodePoint");
    }
    var stringFromCharCode;
    var floor;
    var fromCodePoint$1 = fromCodePoint2;
    var XHTMLEntities = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var HEX_NUMBER = /^[\da-fA-F]+$/;
    var DECIMAL_NUMBER = /^\d+$/;
    types$1.j_oTag = new TokContext("<tag", false);
    types$1.j_cTag = new TokContext("</tag", false);
    types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
    types.jsxName = new TokenType("jsxName");
    types.jsxText = new TokenType("jsxText", { beforeExpr: true });
    types.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true });
    types.jsxTagEnd = new TokenType("jsxTagEnd");
    types.jsxTagStart.updateContext = function() {
      this.state.context.push(types$1.j_expr);
      this.state.context.push(types$1.j_oTag);
      this.state.exprAllowed = false;
    };
    types.jsxTagEnd.updateContext = function(prevType) {
      var out = this.state.context.pop();
      if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
        this.state.context.pop();
        this.state.exprAllowed = this.curContext() === types$1.j_expr;
      } else {
        this.state.exprAllowed = true;
      }
    };
    var pp$9 = Parser2.prototype;
    pp$9.jsxReadToken = function() {
      var out = "";
      var chunkStart = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.input.length) {
          this.raise(this.state.start, "Unterminated JSX contents");
        }
        var ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.exprAllowed) {
                ++this.state.pos;
                return this.finishToken(types.jsxTagStart);
              }
              return this.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.state.pos);
            return this.finishToken(types.jsxText, out);
          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }
        }
      }
    };
    pp$9.jsxReadNewLine = function(normalizeCRLF) {
      var ch = this.input.charCodeAt(this.state.pos);
      var out = void 0;
      ++this.state.pos;
      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }
      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    };
    pp$9.jsxReadString = function(quote) {
      var out = "";
      var chunkStart = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.input.length) {
          this.raise(this.state.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote)
          break;
        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++);
      return this.finishToken(types.string, out);
    };
    pp$9.jsxReadEntity = function() {
      var str = "";
      var count = 0;
      var entity = void 0;
      var ch = this.input[this.state.pos];
      var startPos = ++this.state.pos;
      while (this.state.pos < this.input.length && count++ < 10) {
        ch = this.input[this.state.pos++];
        if (ch === ";") {
          if (str[0] === "#") {
            if (str[1] === "x") {
              str = str.substr(2);
              if (HEX_NUMBER.test(str))
                entity = fromCodePoint$1(parseInt(str, 16));
            } else {
              str = str.substr(1);
              if (DECIMAL_NUMBER.test(str))
                entity = fromCodePoint$1(parseInt(str, 10));
            }
          } else {
            entity = XHTMLEntities[str];
          }
          break;
        }
        str += ch;
      }
      if (!entity) {
        this.state.pos = startPos;
        return "&";
      }
      return entity;
    };
    pp$9.jsxReadWord = function() {
      var ch = void 0;
      var start = this.state.pos;
      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar(ch) || ch === 45);
      return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
    };
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
    }
    __name(getQualifiedJSXName, "getQualifiedJSXName");
    pp$9.jsxParseIdentifier = function() {
      var node = this.startNode();
      if (this.match(types.jsxName)) {
        node.name = this.state.value;
      } else if (this.state.type.keyword) {
        node.name = this.state.type.keyword;
      } else {
        this.unexpected();
      }
      this.next();
      return this.finishNode(node, "JSXIdentifier");
    };
    pp$9.jsxParseNamespacedName = function() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var name = this.jsxParseIdentifier();
      if (!this.eat(types.colon))
        return name;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsxParseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    };
    pp$9.jsxParseElementName = function() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var node = this.jsxParseNamespacedName();
      while (this.eat(types.dot)) {
        var newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsxParseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }
      return node;
    };
    pp$9.jsxParseAttributeValue = function() {
      var node = void 0;
      switch (this.state.type) {
        case types.braceL:
          node = this.jsxParseExpressionContainer();
          if (node.expression.type === "JSXEmptyExpression") {
            this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
          } else {
            return node;
          }
        case types.jsxTagStart:
        case types.string:
          node = this.parseExprAtom();
          node.extra = null;
          return node;
        default:
          this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
      }
    };
    pp$9.jsxParseEmptyExpression = function() {
      var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    };
    pp$9.jsxParseSpreadChild = function() {
      var node = this.startNode();
      this.expect(types.braceL);
      this.expect(types.ellipsis);
      node.expression = this.parseExpression();
      this.expect(types.braceR);
      return this.finishNode(node, "JSXSpreadChild");
    };
    pp$9.jsxParseExpressionContainer = function() {
      var node = this.startNode();
      this.next();
      if (this.match(types.braceR)) {
        node.expression = this.jsxParseEmptyExpression();
      } else {
        node.expression = this.parseExpression();
      }
      this.expect(types.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    };
    pp$9.jsxParseAttribute = function() {
      var node = this.startNode();
      if (this.eat(types.braceL)) {
        this.expect(types.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(types.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }
      node.name = this.jsxParseNamespacedName();
      node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    };
    pp$9.jsxParseOpeningElementAt = function(startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      node.name = this.jsxParseElementName();
      while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
        node.attributes.push(this.jsxParseAttribute());
      }
      node.selfClosing = this.eat(types.slash);
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningElement");
    };
    pp$9.jsxParseClosingElementAt = function(startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      node.name = this.jsxParseElementName();
      this.expect(types.jsxTagEnd);
      return this.finishNode(node, "JSXClosingElement");
    };
    pp$9.jsxParseElementAt = function(startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      var children = [];
      var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
      var closingElement = null;
      if (!openingElement.selfClosing) {
        contents:
          for (; ; ) {
            switch (this.state.type) {
              case types.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(types.slash)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;
              case types.jsxText:
                children.push(this.parseExprAtom());
                break;
              case types.braceL:
                if (this.lookahead().type === types.ellipsis) {
                  children.push(this.jsxParseSpreadChild());
                } else {
                  children.push(this.jsxParseExpressionContainer());
                }
                break;
              default:
                this.unexpected();
            }
          }
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
        }
      }
      node.openingElement = openingElement;
      node.closingElement = closingElement;
      node.children = children;
      if (this.match(types.relational) && this.state.value === "<") {
        this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      }
      return this.finishNode(node, "JSXElement");
    };
    pp$9.jsxParseElement = function() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startPos, startLoc);
    };
    var jsxPlugin = /* @__PURE__ */ __name(function(instance) {
      instance.extend("parseExprAtom", function(inner) {
        return function(refShortHandDefaultPos) {
          if (this.match(types.jsxText)) {
            var node = this.parseLiteral(this.state.value, "JSXText");
            node.extra = null;
            return node;
          } else if (this.match(types.jsxTagStart)) {
            return this.jsxParseElement();
          } else {
            return inner.call(this, refShortHandDefaultPos);
          }
        };
      });
      instance.extend("readToken", function(inner) {
        return function(code) {
          if (this.state.inPropertyName)
            return inner.call(this, code);
          var context = this.curContext();
          if (context === types$1.j_expr) {
            return this.jsxReadToken();
          }
          if (context === types$1.j_oTag || context === types$1.j_cTag) {
            if (isIdentifierStart(code)) {
              return this.jsxReadWord();
            }
            if (code === 62) {
              ++this.state.pos;
              return this.finishToken(types.jsxTagEnd);
            }
            if ((code === 34 || code === 39) && context === types$1.j_oTag) {
              return this.jsxReadString(code);
            }
          }
          if (code === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }
          return inner.call(this, code);
        };
      });
      instance.extend("updateContext", function(inner) {
        return function(prevType) {
          if (this.match(types.braceL)) {
            var curContext = this.curContext();
            if (curContext === types$1.j_oTag) {
              this.state.context.push(types$1.braceExpression);
            } else if (curContext === types$1.j_expr) {
              this.state.context.push(types$1.templateQuasi);
            } else {
              inner.call(this, prevType);
            }
            this.state.exprAllowed = true;
          } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
            this.state.context.length -= 2;
            this.state.context.push(types$1.j_cTag);
            this.state.exprAllowed = false;
          } else {
            return inner.call(this, prevType);
          }
        };
      });
    }, "jsxPlugin");
    plugins.estree = estreePlugin;
    plugins.flow = flowPlugin;
    plugins.jsx = jsxPlugin;
    function parse2(input, options2) {
      return new Parser2(options2, input).parse();
    }
    __name(parse2, "parse");
    function parseExpression(input, options2) {
      var parser = new Parser2(options2, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    __name(parseExpression, "parseExpression");
    exports2.parse = parse2;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = types;
  }
});

// node_modules/babel-traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "node_modules/babel-traverse/lib/path/replacement.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.replaceWithMultiple = replaceWithMultiple;
    exports2.replaceWithSourceString = replaceWithSourceString;
    exports2.replaceWith = replaceWith;
    exports2._replaceWith = _replaceWith;
    exports2.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports2.replaceInline = replaceInline;
    var _babelCodeFrame = require_lib5();
    var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);
    var _index = require_lib7();
    var _index2 = _interopRequireDefault(_index);
    var _index3 = require_path();
    var _index4 = _interopRequireDefault(_index3);
    var _babylon = require_lib6();
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var hoistVariablesVisitor = {
      Function: /* @__PURE__ */ __name(function Function2(path2) {
        path2.skip();
      }, "Function"),
      VariableDeclaration: /* @__PURE__ */ __name(function VariableDeclaration(path2) {
        if (path2.node.kind !== "var")
          return;
        var bindings = path2.getBindingIdentifiers();
        for (var key in bindings) {
          path2.scope.push({ id: bindings[key] });
        }
        var exprs = [];
        for (var _iterator = path2.node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var declar = _ref;
          if (declar.init) {
            exprs.push(t5.expressionStatement(t5.assignmentExpression("=", declar.id, declar.init)));
          }
        }
        path2.replaceWithMultiple(exprs);
      }, "VariableDeclaration")
    };
    function replaceWithMultiple(nodes) {
      this.resync();
      nodes = this._verifyNodeList(nodes);
      t5.inheritLeadingComments(nodes[0], this.node);
      t5.inheritTrailingComments(nodes[nodes.length - 1], this.node);
      this.node = this.container[this.key] = null;
      this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
    }
    __name(replaceWithMultiple, "replaceWithMultiple");
    function replaceWithSourceString(replacement) {
      this.resync();
      try {
        replacement = "(" + replacement + ")";
        replacement = (0, _babylon.parse)(replacement);
      } catch (err) {
        var loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.";
          err.message += "\n" + (0, _babelCodeFrame2.default)(replacement, loc.line, loc.column + 1);
        }
        throw err;
      }
      replacement = replacement.program.body[0].expression;
      _index2.default.removeProperties(replacement);
      return this.replaceWith(replacement);
    }
    __name(replaceWithSourceString, "replaceWithSourceString");
    function replaceWith(replacement) {
      this.resync();
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      if (replacement instanceof _index4.default) {
        replacement = replacement.node;
      }
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return;
      }
      if (this.isProgram() && !t5.isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      if (this.isNodeType("Statement") && t5.isExpression(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = t5.expressionStatement(replacement);
        }
      }
      if (this.isNodeType("Expression") && t5.isStatement(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      var oldNode = this.node;
      if (oldNode) {
        t5.inheritsComments(replacement, oldNode);
        t5.removeComments(oldNode);
      }
      this._replaceWith(replacement);
      this.type = replacement.type;
      this.setScope();
      this.requeue();
    }
    __name(replaceWith, "replaceWith");
    function _replaceWith(node) {
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        t5.validate(this.parent, this.key, [node]);
      } else {
        t5.validate(this.parent, this.key, node);
      }
      this.debug(function() {
        return "Replace with " + (node && node.type);
      });
      this.node = this.container[this.key] = node;
    }
    __name(_replaceWith, "_replaceWith");
    function replaceExpressionWithStatements(nodes) {
      this.resync();
      var toSequenceExpression = t5.toSequenceExpression(nodes, this.scope);
      if (t5.isSequenceExpression(toSequenceExpression)) {
        var exprs = toSequenceExpression.expressions;
        if (exprs.length >= 2 && this.parentPath.isExpressionStatement()) {
          this._maybePopFromStatements(exprs);
        }
        if (exprs.length === 1) {
          this.replaceWith(exprs[0]);
        } else {
          this.replaceWith(toSequenceExpression);
        }
      } else if (toSequenceExpression) {
        this.replaceWith(toSequenceExpression);
      } else {
        var container = t5.functionExpression(null, [], t5.blockStatement(nodes));
        container.shadow = true;
        this.replaceWith(t5.callExpression(container, []));
        this.traverse(hoistVariablesVisitor);
        var completionRecords = this.get("callee").getCompletionRecords();
        for (var _iterator2 = completionRecords, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var path2 = _ref2;
          if (!path2.isExpressionStatement())
            continue;
          var loop = path2.findParent(function(path3) {
            return path3.isLoop();
          });
          if (loop) {
            var uid = loop.getData("expressionReplacementReturnUid");
            if (!uid) {
              var callee = this.get("callee");
              uid = callee.scope.generateDeclaredUidIdentifier("ret");
              callee.get("body").pushContainer("body", t5.returnStatement(uid));
              loop.setData("expressionReplacementReturnUid", uid);
            } else {
              uid = t5.identifier(uid.name);
            }
            path2.get("expression").replaceWith(t5.assignmentExpression("=", uid, path2.node.expression));
          } else {
            path2.replaceWith(t5.returnStatement(path2.node.expression));
          }
        }
        return this.node;
      }
    }
    __name(replaceExpressionWithStatements, "replaceExpressionWithStatements");
    function replaceInline(nodes) {
      this.resync();
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = this._verifyNodeList(nodes);
          this._containerInsertAfter(nodes);
          return this.remove();
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
    __name(replaceInline, "replaceInline");
  }
});

// node_modules/babel-traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "node_modules/babel-traverse/lib/path/evaluation.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _typeof2 = require_typeof();
    var _typeof3 = _interopRequireDefault(_typeof2);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _map = require_map2();
    var _map2 = _interopRequireDefault(_map);
    exports2.evaluateTruthy = evaluateTruthy;
    exports2.evaluate = evaluate;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var VALID_CALLEES = ["String", "Number", "Math"];
    var INVALID_METHODS = ["random"];
    function evaluateTruthy() {
      var res = this.evaluate();
      if (res.confident)
        return !!res.value;
    }
    __name(evaluateTruthy, "evaluateTruthy");
    function evaluate() {
      var confident = true;
      var deoptPath = void 0;
      var seen = new _map2.default();
      function deopt(path2) {
        if (!confident)
          return;
        deoptPath = path2;
        confident = false;
      }
      __name(deopt, "deopt");
      var value = evaluate2(this);
      if (!confident)
        value = void 0;
      return {
        confident,
        deopt: deoptPath,
        value
      };
      function evaluate2(path2) {
        var node = path2.node;
        if (seen.has(node)) {
          var existing = seen.get(node);
          if (existing.resolved) {
            return existing.value;
          } else {
            deopt(path2);
            return;
          }
        } else {
          var item = { resolved: false };
          seen.set(node, item);
          var val = _evaluate(path2);
          if (confident) {
            item.resolved = true;
            item.value = val;
          }
          return val;
        }
      }
      __name(evaluate2, "evaluate");
      function _evaluate(path2) {
        if (!confident)
          return;
        var node = path2.node;
        if (path2.isSequenceExpression()) {
          var exprs = path2.get("expressions");
          return evaluate2(exprs[exprs.length - 1]);
        }
        if (path2.isStringLiteral() || path2.isNumericLiteral() || path2.isBooleanLiteral()) {
          return node.value;
        }
        if (path2.isNullLiteral()) {
          return null;
        }
        if (path2.isTemplateLiteral()) {
          var str = "";
          var i = 0;
          var _exprs = path2.get("expressions");
          for (var _iterator = node.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
            var _ref;
            if (_isArray) {
              if (_i >= _iterator.length)
                break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done)
                break;
              _ref = _i.value;
            }
            var elem = _ref;
            if (!confident)
              break;
            str += elem.value.cooked;
            var expr = _exprs[i++];
            if (expr)
              str += String(evaluate2(expr));
          }
          if (!confident)
            return;
          return str;
        }
        if (path2.isConditionalExpression()) {
          var testResult = evaluate2(path2.get("test"));
          if (!confident)
            return;
          if (testResult) {
            return evaluate2(path2.get("consequent"));
          } else {
            return evaluate2(path2.get("alternate"));
          }
        }
        if (path2.isExpressionWrapper()) {
          return evaluate2(path2.get("expression"));
        }
        if (path2.isMemberExpression() && !path2.parentPath.isCallExpression({ callee: node })) {
          var property = path2.get("property");
          var object = path2.get("object");
          if (object.isLiteral() && property.isIdentifier()) {
            var _value = object.node.value;
            var type3 = typeof _value === "undefined" ? "undefined" : (0, _typeof3.default)(_value);
            if (type3 === "number" || type3 === "string") {
              return _value[property.node.name];
            }
          }
        }
        if (path2.isReferencedIdentifier()) {
          var binding = path2.scope.getBinding(node.name);
          if (binding && binding.constantViolations.length > 0) {
            return deopt(binding.path);
          }
          if (binding && path2.node.start < binding.path.node.end) {
            return deopt(binding.path);
          }
          if (binding && binding.hasValue) {
            return binding.value;
          } else {
            if (node.name === "undefined") {
              return binding ? deopt(binding.path) : void 0;
            } else if (node.name === "Infinity") {
              return binding ? deopt(binding.path) : Infinity;
            } else if (node.name === "NaN") {
              return binding ? deopt(binding.path) : NaN;
            }
            var resolved = path2.resolve();
            if (resolved === path2) {
              return deopt(path2);
            } else {
              return evaluate2(resolved);
            }
          }
        }
        if (path2.isUnaryExpression({ prefix: true })) {
          if (node.operator === "void") {
            return void 0;
          }
          var argument = path2.get("argument");
          if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
            return "function";
          }
          var arg = evaluate2(argument);
          if (!confident)
            return;
          switch (node.operator) {
            case "!":
              return !arg;
            case "+":
              return +arg;
            case "-":
              return -arg;
            case "~":
              return ~arg;
            case "typeof":
              return typeof arg === "undefined" ? "undefined" : (0, _typeof3.default)(arg);
          }
        }
        if (path2.isArrayExpression()) {
          var arr = [];
          var elems = path2.get("elements");
          for (var _iterator2 = elems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
            var _ref2;
            if (_isArray2) {
              if (_i2 >= _iterator2.length)
                break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done)
                break;
              _ref2 = _i2.value;
            }
            var _elem = _ref2;
            _elem = _elem.evaluate();
            if (_elem.confident) {
              arr.push(_elem.value);
            } else {
              return deopt(_elem);
            }
          }
          return arr;
        }
        if (path2.isObjectExpression()) {
          var obj = {};
          var props = path2.get("properties");
          for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
            var _ref3;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref3 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref3 = _i3.value;
            }
            var prop = _ref3;
            if (prop.isObjectMethod() || prop.isSpreadProperty()) {
              return deopt(prop);
            }
            var keyPath = prop.get("key");
            var key = keyPath;
            if (prop.node.computed) {
              key = key.evaluate();
              if (!key.confident) {
                return deopt(keyPath);
              }
              key = key.value;
            } else if (key.isIdentifier()) {
              key = key.node.name;
            } else {
              key = key.node.value;
            }
            var valuePath = prop.get("value");
            var _value2 = valuePath.evaluate();
            if (!_value2.confident) {
              return deopt(valuePath);
            }
            _value2 = _value2.value;
            obj[key] = _value2;
          }
          return obj;
        }
        if (path2.isLogicalExpression()) {
          var wasConfident = confident;
          var left = evaluate2(path2.get("left"));
          var leftConfident = confident;
          confident = wasConfident;
          var right = evaluate2(path2.get("right"));
          var rightConfident = confident;
          confident = leftConfident && rightConfident;
          switch (node.operator) {
            case "||":
              if (left && leftConfident) {
                confident = true;
                return left;
              }
              if (!confident)
                return;
              return left || right;
            case "&&":
              if (!left && leftConfident || !right && rightConfident) {
                confident = true;
              }
              if (!confident)
                return;
              return left && right;
          }
        }
        if (path2.isBinaryExpression()) {
          var _left = evaluate2(path2.get("left"));
          if (!confident)
            return;
          var _right = evaluate2(path2.get("right"));
          if (!confident)
            return;
          switch (node.operator) {
            case "-":
              return _left - _right;
            case "+":
              return _left + _right;
            case "/":
              return _left / _right;
            case "*":
              return _left * _right;
            case "%":
              return _left % _right;
            case "**":
              return Math.pow(_left, _right);
            case "<":
              return _left < _right;
            case ">":
              return _left > _right;
            case "<=":
              return _left <= _right;
            case ">=":
              return _left >= _right;
            case "==":
              return _left == _right;
            case "!=":
              return _left != _right;
            case "===":
              return _left === _right;
            case "!==":
              return _left !== _right;
            case "|":
              return _left | _right;
            case "&":
              return _left & _right;
            case "^":
              return _left ^ _right;
            case "<<":
              return _left << _right;
            case ">>":
              return _left >> _right;
            case ">>>":
              return _left >>> _right;
          }
        }
        if (path2.isCallExpression()) {
          var callee = path2.get("callee");
          var context = void 0;
          var func = void 0;
          if (callee.isIdentifier() && !path2.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
            func = global[node.callee.name];
          }
          if (callee.isMemberExpression()) {
            var _object = callee.get("object");
            var _property = callee.get("property");
            if (_object.isIdentifier() && _property.isIdentifier() && VALID_CALLEES.indexOf(_object.node.name) >= 0 && INVALID_METHODS.indexOf(_property.node.name) < 0) {
              context = global[_object.node.name];
              func = context[_property.node.name];
            }
            if (_object.isLiteral() && _property.isIdentifier()) {
              var _type = (0, _typeof3.default)(_object.node.value);
              if (_type === "string" || _type === "number") {
                context = _object.node.value;
                func = context[_property.node.name];
              }
            }
          }
          if (func) {
            var args = path2.get("arguments").map(evaluate2);
            if (!confident)
              return;
            return func.apply(context, args);
          }
        }
        deopt(path2);
      }
      __name(_evaluate, "_evaluate");
    }
    __name(evaluate, "evaluate");
  }
});

// node_modules/babel-traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "node_modules/babel-traverse/lib/path/conversion.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.toComputedKey = toComputedKey;
    exports2.ensureBlock = ensureBlock;
    exports2.arrowFunctionToShadowed = arrowFunctionToShadowed;
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function toComputedKey() {
      var node = this.node;
      var key = void 0;
      if (this.isMemberExpression()) {
        key = node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!node.computed) {
        if (t5.isIdentifier(key))
          key = t5.stringLiteral(key.name);
      }
      return key;
    }
    __name(toComputedKey, "toComputedKey");
    function ensureBlock() {
      return t5.ensureBlock(this.node);
    }
    __name(ensureBlock, "ensureBlock");
    function arrowFunctionToShadowed() {
      if (!this.isArrowFunctionExpression())
        return;
      this.ensureBlock();
      var node = this.node;
      node.expression = false;
      node.type = "FunctionExpression";
      node.shadow = node.shadow || true;
    }
    __name(arrowFunctionToShadowed, "arrowFunctionToShadowed");
  }
});

// node_modules/babel-traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "node_modules/babel-traverse/lib/path/introspection.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.is = void 0;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.matchesPattern = matchesPattern;
    exports2.has = has;
    exports2.isStatic = isStatic;
    exports2.isnt = isnt;
    exports2.equals = equals;
    exports2.isNodeType = isNodeType;
    exports2.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports2.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports2.isCompletionRecord = isCompletionRecord;
    exports2.isStatementOrBlock = isStatementOrBlock;
    exports2.referencesImport = referencesImport;
    exports2.getSource = getSource;
    exports2.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    exports2._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports2._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
    exports2.resolve = resolve2;
    exports2._resolve = _resolve;
    var _includes = require_includes();
    var _includes2 = _interopRequireDefault(_includes);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function matchesPattern(pattern, allowPartial) {
      if (!this.isMemberExpression())
        return false;
      var parts = pattern.split(".");
      var search = [this.node];
      var i = 0;
      function matches(name) {
        var part = parts[i];
        return part === "*" || name === part;
      }
      __name(matches, "matches");
      while (search.length) {
        var node = search.shift();
        if (allowPartial && i === parts.length) {
          return true;
        }
        if (t5.isIdentifier(node)) {
          if (!matches(node.name))
            return false;
        } else if (t5.isLiteral(node)) {
          if (!matches(node.value))
            return false;
        } else if (t5.isMemberExpression(node)) {
          if (node.computed && !t5.isLiteral(node.property)) {
            return false;
          } else {
            search.unshift(node.property);
            search.unshift(node.object);
            continue;
          }
        } else if (t5.isThisExpression(node)) {
          if (!matches("this"))
            return false;
        } else {
          return false;
        }
        if (++i > parts.length) {
          return false;
        }
      }
      return i === parts.length;
    }
    __name(matchesPattern, "matchesPattern");
    function has(key) {
      var val = this.node && this.node[key];
      if (val && Array.isArray(val)) {
        return !!val.length;
      } else {
        return !!val;
      }
    }
    __name(has, "has");
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    __name(isStatic, "isStatic");
    var is2 = exports2.is = has;
    function isnt(key) {
      return !this.has(key);
    }
    __name(isnt, "isnt");
    function equals(key, value) {
      return this.node[key] === value;
    }
    __name(equals, "equals");
    function isNodeType(type3) {
      return t5.isType(this.type, type3);
    }
    __name(isNodeType, "isNodeType");
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    __name(canHaveVariableDeclarationOrExpression, "canHaveVariableDeclarationOrExpression");
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return t5.isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return t5.isExpression(replacement);
      }
      return false;
    }
    __name(canSwapBetweenExpressionAndStatement, "canSwapBetweenExpressionAndStatement");
    function isCompletionRecord(allowInsideFunction) {
      var path2 = this;
      var first = true;
      do {
        var container = path2.container;
        if (path2.isFunction() && !first) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path2.key !== container.length - 1) {
          return false;
        }
      } while ((path2 = path2.parentPath) && !path2.isProgram());
      return true;
    }
    __name(isCompletionRecord, "isCompletionRecord");
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || t5.isBlockStatement(this.container)) {
        return false;
      } else {
        return (0, _includes2.default)(t5.STATEMENT_OR_BLOCK_KEYS, this.key);
      }
    }
    __name(isStatementOrBlock, "isStatementOrBlock");
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier())
        return false;
      var binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module")
        return false;
      var path2 = binding.path;
      var parent = path2.parentPath;
      if (!parent.isImportDeclaration())
        return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName)
          return true;
      } else {
        return false;
      }
      if (path2.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path2.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path2.isImportSpecifier() && path2.node.imported.name === importName) {
        return true;
      }
      return false;
    }
    __name(referencesImport, "referencesImport");
    function getSource() {
      var node = this.node;
      if (node.end) {
        return this.hub.file.code.slice(node.start, node.end);
      } else {
        return "";
      }
    }
    __name(getSource, "getSource");
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    __name(willIMaybeExecuteBefore, "willIMaybeExecuteBefore");
    function _guessExecutionStatusRelativeTo(target) {
      var targetFuncParent = target.scope.getFunctionParent();
      var selfFuncParent = this.scope.getFunctionParent();
      if (targetFuncParent.node !== selfFuncParent.node) {
        var status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);
        if (status) {
          return status;
        } else {
          target = targetFuncParent.path;
        }
      }
      var targetPaths = target.getAncestry();
      if (targetPaths.indexOf(this) >= 0)
        return "after";
      var selfPaths = this.getAncestry();
      var commonPath = void 0;
      var targetIndex = void 0;
      var selfIndex = void 0;
      for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {
        var selfPath = selfPaths[selfIndex];
        targetIndex = targetPaths.indexOf(selfPath);
        if (targetIndex >= 0) {
          commonPath = selfPath;
          break;
        }
      }
      if (!commonPath) {
        return "before";
      }
      var targetRelationship = targetPaths[targetIndex - 1];
      var selfRelationship = selfPaths[selfIndex - 1];
      if (!targetRelationship || !selfRelationship) {
        return "before";
      }
      if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {
        return targetRelationship.key > selfRelationship.key ? "before" : "after";
      }
      var targetKeyPosition = t5.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);
      var selfKeyPosition = t5.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);
      return targetKeyPosition > selfKeyPosition ? "before" : "after";
    }
    __name(_guessExecutionStatusRelativeTo, "_guessExecutionStatusRelativeTo");
    function _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {
      var targetFuncPath = targetFuncParent.path;
      if (!targetFuncPath.isFunctionDeclaration())
        return;
      var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);
      if (!binding.references)
        return "before";
      var referencePaths = binding.referencePaths;
      for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var path2 = _ref;
        if (path2.key !== "callee" || !path2.parentPath.isCallExpression()) {
          return;
        }
      }
      var allStatus = void 0;
      for (var _iterator2 = referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var _path = _ref2;
        var childOfFunction = !!_path.find(function(path3) {
          return path3.node === targetFuncPath.node;
        });
        if (childOfFunction)
          continue;
        var status = this._guessExecutionStatusRelativeTo(_path);
        if (allStatus) {
          if (allStatus !== status)
            return;
        } else {
          allStatus = status;
        }
      }
      return allStatus;
    }
    __name(_guessExecutionStatusRelativeToDifferentFunctions, "_guessExecutionStatusRelativeToDifferentFunctions");
    function resolve2(dangerous, resolved) {
      return this._resolve(dangerous, resolved) || this;
    }
    __name(resolve2, "resolve");
    function _resolve(dangerous, resolved) {
      if (resolved && resolved.indexOf(this) >= 0)
        return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding)
          return;
        if (!binding.constant)
          return;
        if (binding.kind === "module")
          return;
        if (binding.path !== this) {
          var ret = binding.path.resolve(dangerous, resolved);
          if (this.find(function(parent) {
            return parent.node === ret.node;
          }))
            return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        var targetKey = this.toComputedKey();
        if (!t5.isLiteral(targetKey))
          return;
        var targetName = targetKey.value;
        var target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          var props = target.get("properties");
          for (var _iterator3 = props, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
            var _ref3;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref3 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref3 = _i3.value;
            }
            var prop = _ref3;
            if (!prop.isProperty())
              continue;
            var key = prop.get("key");
            var match = prop.isnt("computed") && key.isIdentifier({ name: targetName });
            match = match || key.isLiteral({ value: targetName });
            if (match)
              return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          var elems = target.get("elements");
          var elem = elems[targetName];
          if (elem)
            return elem.resolve(dangerous, resolved);
        }
      }
    }
    __name(_resolve, "_resolve");
  }
});

// node_modules/babel-traverse/lib/path/context.js
var require_context = __commonJS({
  "node_modules/babel-traverse/lib/path/context.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.call = call;
    exports2._call = _call;
    exports2.isBlacklisted = isBlacklisted;
    exports2.visit = visit;
    exports2.skip = skip;
    exports2.skipKey = skipKey;
    exports2.stop = stop;
    exports2.setScope = setScope;
    exports2.setContext = setContext;
    exports2.resync = resync;
    exports2._resyncParent = _resyncParent;
    exports2._resyncKey = _resyncKey;
    exports2._resyncList = _resyncList;
    exports2._resyncRemoved = _resyncRemoved;
    exports2.popContext = popContext;
    exports2.pushContext = pushContext;
    exports2.setup = setup;
    exports2.setKey = setKey;
    exports2.requeue = requeue;
    exports2._getQueueContexts = _getQueueContexts;
    var _index = require_lib7();
    var _index2 = _interopRequireDefault(_index);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function call(key) {
      var opts = this.opts;
      this.debug(function() {
        return key;
      });
      if (this.node) {
        if (this._call(opts[key]))
          return true;
      }
      if (this.node) {
        return this._call(opts[this.node.type] && opts[this.node.type][key]);
      }
      return false;
    }
    __name(call, "call");
    function _call(fns) {
      if (!fns)
        return false;
      for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var fn = _ref;
        if (!fn)
          continue;
        var node = this.node;
        if (!node)
          return true;
        var ret = fn.call(this.state, this, this.state);
        if (ret)
          throw new Error("Unexpected return value from visitor method " + fn);
        if (this.node !== node)
          return true;
        if (this.shouldStop || this.shouldSkip || this.removed)
          return true;
      }
      return false;
    }
    __name(_call, "_call");
    function isBlacklisted() {
      var blacklist = this.opts.blacklist;
      return blacklist && blacklist.indexOf(this.node.type) > -1;
    }
    __name(isBlacklisted, "isBlacklisted");
    function visit() {
      if (!this.node) {
        return false;
      }
      if (this.isBlacklisted()) {
        return false;
      }
      if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
        return false;
      }
      if (this.call("enter") || this.shouldSkip) {
        this.debug(function() {
          return "Skip...";
        });
        return this.shouldStop;
      }
      this.debug(function() {
        return "Recursing into...";
      });
      _index2.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      this.call("exit");
      return this.shouldStop;
    }
    __name(visit, "visit");
    function skip() {
      this.shouldSkip = true;
    }
    __name(skip, "skip");
    function skipKey(key) {
      this.skipKeys[key] = true;
    }
    __name(skipKey, "skipKey");
    function stop() {
      this.shouldStop = true;
      this.shouldSkip = true;
    }
    __name(stop, "stop");
    function setScope() {
      if (this.opts && this.opts.noScope)
        return;
      var target = this.context && this.context.scope;
      if (!target) {
        var path2 = this.parentPath;
        while (path2 && !target) {
          if (path2.opts && path2.opts.noScope)
            return;
          target = path2.scope;
          path2 = path2.parentPath;
        }
      }
      this.scope = this.getScope(target);
      if (this.scope)
        this.scope.init();
    }
    __name(setScope, "setScope");
    function setContext(context) {
      this.shouldSkip = false;
      this.shouldStop = false;
      this.removed = false;
      this.skipKeys = {};
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      this.setScope();
      return this;
    }
    __name(setContext, "setContext");
    function resync() {
      if (this.removed)
        return;
      this._resyncParent();
      this._resyncList();
      this._resyncKey();
    }
    __name(resync, "resync");
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    __name(_resyncParent, "_resyncParent");
    function _resyncKey() {
      if (!this.container)
        return;
      if (this.node === this.container[this.key])
        return;
      if (Array.isArray(this.container)) {
        for (var i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            return this.setKey(i);
          }
        }
      } else {
        for (var key in this.container) {
          if (this.container[key] === this.node) {
            return this.setKey(key);
          }
        }
      }
      this.key = null;
    }
    __name(_resyncKey, "_resyncKey");
    function _resyncList() {
      if (!this.parent || !this.inList)
        return;
      var newContainer = this.parent[this.listKey];
      if (this.container === newContainer)
        return;
      this.container = newContainer || null;
    }
    __name(_resyncList, "_resyncList");
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        this._markRemoved();
      }
    }
    __name(_resyncRemoved, "_resyncRemoved");
    function popContext() {
      this.contexts.pop();
      this.setContext(this.contexts[this.contexts.length - 1]);
    }
    __name(popContext, "popContext");
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    __name(pushContext, "pushContext");
    function setup(parentPath, container, listKey, key) {
      this.inList = !!listKey;
      this.listKey = listKey;
      this.parentKey = listKey || key;
      this.container = container;
      this.parentPath = parentPath || this.parentPath;
      this.setKey(key);
    }
    __name(setup, "setup");
    function setKey(key) {
      this.key = key;
      this.node = this.container[this.key];
      this.type = this.node && this.node.type;
    }
    __name(setKey, "setKey");
    function requeue() {
      var pathToQueue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
      if (pathToQueue.removed)
        return;
      var contexts = this.contexts;
      for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var context = _ref2;
        context.maybeQueue(pathToQueue);
      }
    }
    __name(requeue, "requeue");
    function _getQueueContexts() {
      var path2 = this;
      var contexts = this.contexts;
      while (!contexts.length) {
        path2 = path2.parentPath;
        contexts = path2.contexts;
      }
      return contexts;
    }
    __name(_getQueueContexts, "_getQueueContexts");
  }
});

// node_modules/babel-traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "node_modules/babel-traverse/lib/path/lib/removal-hooks.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var hooks = exports2.hooks = [function(self2, parent) {
      var removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && (self2.key === "consequent" || self2.key === "alternate") || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
  }
});

// node_modules/babel-traverse/lib/path/removal.js
var require_removal = __commonJS({
  "node_modules/babel-traverse/lib/path/removal.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.remove = remove;
    exports2._callRemovalHooks = _callRemovalHooks;
    exports2._remove = _remove;
    exports2._markRemoved = _markRemoved;
    exports2._assertUnremoved = _assertUnremoved;
    var _removalHooks = require_removal_hooks();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function remove() {
      this._assertUnremoved();
      this.resync();
      if (this._callRemovalHooks()) {
        this._markRemoved();
        return;
      }
      this.shareCommentsWithSiblings();
      this._remove();
      this._markRemoved();
    }
    __name(remove, "remove");
    function _callRemovalHooks() {
      for (var _iterator = _removalHooks.hooks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var fn = _ref;
        if (fn(this, this.parentPath))
          return true;
      }
    }
    __name(_callRemovalHooks, "_callRemovalHooks");
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        this.updateSiblingKeys(this.key, -1);
      } else {
        this._replaceWith(null);
      }
    }
    __name(_remove, "_remove");
    function _markRemoved() {
      this.shouldSkip = true;
      this.removed = true;
      this.node = null;
    }
    __name(_markRemoved, "_markRemoved");
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
    __name(_assertUnremoved, "_assertUnremoved");
  }
});

// node_modules/babel-traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "node_modules/babel-traverse/lib/path/lib/hoister.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var referenceVisitor = {
      ReferencedIdentifier: /* @__PURE__ */ __name(function ReferencedIdentifier(path2, state) {
        if (path2.isJSXIdentifier() && _babelTypes.react.isCompatTag(path2.node.name) && !path2.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path2.node.name === "this") {
          var scope = path2.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression())
              break;
          } while (scope = scope.parent);
          if (scope)
            state.breakOnScopePaths.push(scope.path);
        }
        var binding = path2.scope.getBinding(path2.node.name);
        if (!binding)
          return;
        if (binding !== state.scope.getBinding(path2.node.name))
          return;
        state.bindings[path2.node.name] = binding;
      }, "ReferencedIdentifier")
    };
    var PathHoister = function() {
      function PathHoister2(path2, scope) {
        (0, _classCallCheck3.default)(this, PathHoister2);
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.scopes = [];
        this.scope = scope;
        this.path = path2;
        this.attachAfter = false;
      }
      __name(PathHoister2, "PathHoister");
      PathHoister2.prototype.isCompatibleScope = /* @__PURE__ */ __name(function isCompatibleScope(scope) {
        for (var key in this.bindings) {
          var binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      }, "isCompatibleScope");
      PathHoister2.prototype.getCompatibleScopes = /* @__PURE__ */ __name(function getCompatibleScopes() {
        var scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
            break;
          }
        } while (scope = scope.parent);
      }, "getCompatibleScopes");
      PathHoister2.prototype.getAttachmentPath = /* @__PURE__ */ __name(function getAttachmentPath() {
        var path2 = this._getAttachmentPath();
        if (!path2)
          return;
        var targetScope = path2.scope;
        if (targetScope.path === path2) {
          targetScope = path2.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (var name in this.bindings) {
            if (!targetScope.hasOwnBinding(name))
              continue;
            var binding = this.bindings[name];
            if (binding.kind === "param")
              continue;
            if (this.getAttachmentParentForPath(binding.path).key > path2.key) {
              this.attachAfter = true;
              path2 = binding.path;
              for (var _iterator = binding.constantViolations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
                var _ref;
                if (_isArray) {
                  if (_i >= _iterator.length)
                    break;
                  _ref = _iterator[_i++];
                } else {
                  _i = _iterator.next();
                  if (_i.done)
                    break;
                  _ref = _i.value;
                }
                var violationPath = _ref;
                if (this.getAttachmentParentForPath(violationPath).key > path2.key) {
                  path2 = violationPath;
                }
              }
            }
          }
        }
        if (path2.parentPath.isExportDeclaration()) {
          path2 = path2.parentPath;
        }
        return path2;
      }, "getAttachmentPath");
      PathHoister2.prototype._getAttachmentPath = /* @__PURE__ */ __name(function _getAttachmentPath() {
        var scopes = this.scopes;
        var scope = scopes.pop();
        if (!scope)
          return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope)
              return;
            return scope.path.get("body").get("body")[0];
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }, "_getAttachmentPath");
      PathHoister2.prototype.getNextScopeAttachmentParent = /* @__PURE__ */ __name(function getNextScopeAttachmentParent() {
        var scope = this.scopes.pop();
        if (scope)
          return this.getAttachmentParentForPath(scope.path);
      }, "getNextScopeAttachmentParent");
      PathHoister2.prototype.getAttachmentParentForPath = /* @__PURE__ */ __name(function getAttachmentParentForPath(path2) {
        do {
          if (!path2.parentPath || Array.isArray(path2.container) && path2.isStatement() || path2.isVariableDeclarator() && path2.parentPath.node !== null && path2.parentPath.node.declarations.length > 1)
            return path2;
        } while (path2 = path2.parentPath);
      }, "getAttachmentParentForPath");
      PathHoister2.prototype.hasOwnParamBindings = /* @__PURE__ */ __name(function hasOwnParamBindings(scope) {
        for (var name in this.bindings) {
          if (!scope.hasOwnBinding(name))
            continue;
          var binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant)
            return true;
        }
        return false;
      }, "hasOwnParamBindings");
      PathHoister2.prototype.run = /* @__PURE__ */ __name(function run() {
        var node = this.path.node;
        if (node._hoisted)
          return;
        node._hoisted = true;
        this.path.traverse(referenceVisitor, this);
        this.getCompatibleScopes();
        var attachTo = this.getAttachmentPath();
        if (!attachTo)
          return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent())
          return;
        var uid = attachTo.scope.generateUidIdentifier("ref");
        var declarator = t5.variableDeclarator(uid, this.path.node);
        var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t5.variableDeclaration("var", [declarator])]);
        var parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = t5.JSXExpressionContainer(uid);
        }
        this.path.replaceWith(uid);
      }, "run");
      return PathHoister2;
    }();
    exports2.default = PathHoister;
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/path/modification.js
var require_modification = __commonJS({
  "node_modules/babel-traverse/lib/path/modification.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _typeof2 = require_typeof();
    var _typeof3 = _interopRequireDefault(_typeof2);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.insertBefore = insertBefore;
    exports2._containerInsert = _containerInsert;
    exports2._containerInsertBefore = _containerInsertBefore;
    exports2._containerInsertAfter = _containerInsertAfter;
    exports2._maybePopFromStatements = _maybePopFromStatements;
    exports2.insertAfter = insertAfter;
    exports2.updateSiblingKeys = updateSiblingKeys;
    exports2._verifyNodeList = _verifyNodeList;
    exports2.unshiftContainer = unshiftContainer;
    exports2.pushContainer = pushContainer;
    exports2.hoist = hoist;
    var _cache = require_cache();
    var _hoister = require_hoister();
    var _hoister2 = _interopRequireDefault(_hoister);
    var _index = require_path();
    var _index2 = _interopRequireDefault(_index);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function insertBefore(nodes) {
      this._assertUnremoved();
      nodes = this._verifyNodeList(nodes);
      if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
        return this.parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
        if (this.node)
          nodes.push(this.node);
        this.replaceExpressionWithStatements(nodes);
      } else {
        this._maybePopFromStatements(nodes);
        if (Array.isArray(this.container)) {
          return this._containerInsertBefore(nodes);
        } else if (this.isStatementOrBlock()) {
          if (this.node)
            nodes.push(this.node);
          this._replaceWith(t5.blockStatement(nodes));
        } else {
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
      }
      return [this];
    }
    __name(insertBefore, "insertBefore");
    function _containerInsert(from, nodes) {
      this.updateSiblingKeys(from, nodes.length);
      var paths = [];
      for (var i = 0; i < nodes.length; i++) {
        var to = from + i;
        var node = nodes[i];
        this.container.splice(to, 0, node);
        if (this.context) {
          var path2 = this.context.create(this.parent, this.container, to, this.listKey);
          if (this.context.queue)
            path2.pushContext(this.context);
          paths.push(path2);
        } else {
          paths.push(_index2.default.get({
            parentPath: this.parentPath,
            parent: this.parent,
            container: this.container,
            listKey: this.listKey,
            key: to
          }));
        }
      }
      var contexts = this._getQueueContexts();
      for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var _path = _ref;
        _path.setScope();
        _path.debug(function() {
          return "Inserted.";
        });
        for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var context = _ref2;
          context.maybeQueue(_path, true);
        }
      }
      return paths;
    }
    __name(_containerInsert, "_containerInsert");
    function _containerInsertBefore(nodes) {
      return this._containerInsert(this.key, nodes);
    }
    __name(_containerInsertBefore, "_containerInsertBefore");
    function _containerInsertAfter(nodes) {
      return this._containerInsert(this.key + 1, nodes);
    }
    __name(_containerInsertAfter, "_containerInsertAfter");
    function _maybePopFromStatements(nodes) {
      var last = nodes[nodes.length - 1];
      var isIdentifier = t5.isIdentifier(last) || t5.isExpressionStatement(last) && t5.isIdentifier(last.expression);
      if (isIdentifier && !this.isCompletionRecord()) {
        nodes.pop();
      }
    }
    __name(_maybePopFromStatements, "_maybePopFromStatements");
    function insertAfter(nodes) {
      this._assertUnremoved();
      nodes = this._verifyNodeList(nodes);
      if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
        return this.parentPath.insertAfter(nodes);
      } else if (this.isNodeType("Expression") || this.parentPath.isForStatement() && this.key === "init") {
        if (this.node) {
          var temp = this.scope.generateDeclaredUidIdentifier();
          nodes.unshift(t5.expressionStatement(t5.assignmentExpression("=", temp, this.node)));
          nodes.push(t5.expressionStatement(temp));
        }
        this.replaceExpressionWithStatements(nodes);
      } else {
        this._maybePopFromStatements(nodes);
        if (Array.isArray(this.container)) {
          return this._containerInsertAfter(nodes);
        } else if (this.isStatementOrBlock()) {
          if (this.node)
            nodes.unshift(this.node);
          this._replaceWith(t5.blockStatement(nodes));
        } else {
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }
      }
      return [this];
    }
    __name(insertAfter, "insertAfter");
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent)
        return;
      var paths = _cache.path.get(this.parent);
      for (var i = 0; i < paths.length; i++) {
        var path2 = paths[i];
        if (path2.key >= fromIndex) {
          path2.key += incrementBy;
        }
      }
    }
    __name(updateSiblingKeys, "updateSiblingKeys");
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (nodes.constructor !== Array) {
        nodes = [nodes];
      }
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var msg = void 0;
        if (!node) {
          msg = "has falsy node";
        } else if ((typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node)) !== "object") {
          msg = "contains a non-object node";
        } else if (!node.type) {
          msg = "without a type";
        } else if (node instanceof _index2.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          var type3 = Array.isArray(node) ? "array" : typeof node === "undefined" ? "undefined" : (0, _typeof3.default)(node);
          throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type3);
        }
      }
      return nodes;
    }
    __name(_verifyNodeList, "_verifyNodeList");
    function unshiftContainer(listKey, nodes) {
      this._assertUnremoved();
      nodes = this._verifyNodeList(nodes);
      var path2 = _index2.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      });
      return path2.insertBefore(nodes);
    }
    __name(unshiftContainer, "unshiftContainer");
    function pushContainer(listKey, nodes) {
      this._assertUnremoved();
      nodes = this._verifyNodeList(nodes);
      var container = this.node[listKey];
      var path2 = _index2.default.get({
        parentPath: this,
        parent: this.node,
        container,
        listKey,
        key: container.length
      });
      return path2.replaceWithMultiple(nodes);
    }
    __name(pushContainer, "pushContainer");
    function hoist() {
      var scope = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.scope;
      var hoister = new _hoister2.default(this, scope);
      return hoister.run();
    }
    __name(hoist, "hoist");
  }
});

// node_modules/babel-traverse/lib/path/family.js
var require_family = __commonJS({
  "node_modules/babel-traverse/lib/path/family.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _create = require_create2();
    var _create2 = _interopRequireDefault(_create);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.getStatementParent = getStatementParent;
    exports2.getOpposite = getOpposite;
    exports2.getCompletionRecords = getCompletionRecords;
    exports2.getSibling = getSibling;
    exports2.getPrevSibling = getPrevSibling;
    exports2.getNextSibling = getNextSibling;
    exports2.getAllNextSiblings = getAllNextSiblings;
    exports2.getAllPrevSiblings = getAllPrevSiblings;
    exports2.get = get;
    exports2._getKey = _getKey;
    exports2._getPattern = _getPattern;
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports2.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports2.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    var _index = require_path();
    var _index2 = _interopRequireDefault(_index);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function getStatementParent() {
      var path2 = this;
      do {
        if (!path2.parentPath || Array.isArray(path2.container) && path2.isStatement()) {
          break;
        } else {
          path2 = path2.parentPath;
        }
      } while (path2);
      if (path2 && (path2.isProgram() || path2.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path2;
    }
    __name(getStatementParent, "getStatementParent");
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
    }
    __name(getOpposite, "getOpposite");
    function getCompletionRecords() {
      var paths = [];
      var add = /* @__PURE__ */ __name(function add2(path2) {
        if (path2)
          paths = paths.concat(path2.getCompletionRecords());
      }, "add");
      if (this.isIfStatement()) {
        add(this.get("consequent"));
        add(this.get("alternate"));
      } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
        add(this.get("body"));
      } else if (this.isProgram() || this.isBlockStatement()) {
        add(this.get("body").pop());
      } else if (this.isFunction()) {
        return this.get("body").getCompletionRecords();
      } else if (this.isTryStatement()) {
        add(this.get("block"));
        add(this.get("handler"));
        add(this.get("finalizer"));
      } else {
        paths.push(this);
      }
      return paths;
    }
    __name(getCompletionRecords, "getCompletionRecords");
    function getSibling(key) {
      return _index2.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      });
    }
    __name(getSibling, "getSibling");
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    __name(getPrevSibling, "getPrevSibling");
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    __name(getNextSibling, "getNextSibling");
    function getAllNextSiblings() {
      var _key = this.key;
      var sibling = this.getSibling(++_key);
      var siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    __name(getAllNextSiblings, "getAllNextSiblings");
    function getAllPrevSiblings() {
      var _key = this.key;
      var sibling = this.getSibling(--_key);
      var siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    __name(getAllPrevSiblings, "getAllPrevSiblings");
    function get(key, context) {
      if (context === true)
        context = this.context;
      var parts = key.split(".");
      if (parts.length === 1) {
        return this._getKey(key, context);
      } else {
        return this._getPattern(parts, context);
      }
    }
    __name(get, "get");
    function _getKey(key, context) {
      var _this = this;
      var node = this.node;
      var container = node[key];
      if (Array.isArray(container)) {
        return container.map(function(_, i) {
          return _index2.default.get({
            listKey: key,
            parentPath: _this,
            parent: node,
            container,
            key: i
          }).setContext(context);
        });
      } else {
        return _index2.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key
        }).setContext(context);
      }
    }
    __name(_getKey, "_getKey");
    function _getPattern(parts, context) {
      var path2 = this;
      for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var part = _ref;
        if (part === ".") {
          path2 = path2.parentPath;
        } else {
          if (Array.isArray(path2)) {
            path2 = path2[part];
          } else {
            path2 = path2.get(part, context);
          }
        }
      }
      return path2;
    }
    __name(_getPattern, "_getPattern");
    function getBindingIdentifiers(duplicates) {
      return t5.getBindingIdentifiers(this.node, duplicates);
    }
    __name(getBindingIdentifiers, "getBindingIdentifiers");
    function getOuterBindingIdentifiers(duplicates) {
      return t5.getOuterBindingIdentifiers(this.node, duplicates);
    }
    __name(getOuterBindingIdentifiers, "getOuterBindingIdentifiers");
    function getBindingIdentifierPaths() {
      var duplicates = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var outerOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var path2 = this;
      var search = [].concat(path2);
      var ids = (0, _create2.default)(null);
      while (search.length) {
        var id = search.shift();
        if (!id)
          continue;
        if (!id.node)
          continue;
        var keys = t5.getBindingIdentifiers.keys[id.node.type];
        if (id.isIdentifier()) {
          if (duplicates) {
            var _ids = ids[id.node.name] = ids[id.node.name] || [];
            _ids.push(id);
          } else {
            ids[id.node.name] = id;
          }
          continue;
        }
        if (id.isExportDeclaration()) {
          var declaration = id.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var child = id.get(key);
            if (Array.isArray(child) || child.node) {
              search = search.concat(child);
            }
          }
        }
      }
      return ids;
    }
    __name(getBindingIdentifierPaths, "getBindingIdentifierPaths");
    function getOuterBindingIdentifierPaths(duplicates) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
    __name(getOuterBindingIdentifierPaths, "getOuterBindingIdentifierPaths");
  }
});

// node_modules/babel-traverse/lib/path/comments.js
var require_comments = __commonJS({
  "node_modules/babel-traverse/lib/path/comments.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.shareCommentsWithSiblings = shareCommentsWithSiblings;
    exports2.addComment = addComment;
    exports2.addComments = addComments;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string")
        return;
      var node = this.node;
      if (!node)
        return;
      var trailing = node.trailingComments;
      var leading = node.leadingComments;
      if (!trailing && !leading)
        return;
      var prev = this.getSibling(this.key - 1);
      var next = this.getSibling(this.key + 1);
      if (!prev.node)
        prev = next;
      if (!next.node)
        next = prev;
      prev.addComments("trailing", leading);
      next.addComments("leading", trailing);
    }
    __name(shareCommentsWithSiblings, "shareCommentsWithSiblings");
    function addComment(type3, content, line2) {
      this.addComments(type3, [{
        type: line2 ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
    __name(addComment, "addComment");
    function addComments(type3, comments) {
      if (!comments)
        return;
      var node = this.node;
      if (!node)
        return;
      var key = type3 + "Comments";
      if (node[key]) {
        node[key] = node[key].concat(comments);
      } else {
        node[key] = comments;
      }
    }
    __name(addComments, "addComments");
  }
});

// node_modules/babel-traverse/lib/path/index.js
var require_path = __commonJS({
  "node_modules/babel-traverse/lib/path/index.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _virtualTypes = require_virtual_types();
    var virtualTypes = _interopRequireWildcard(_virtualTypes);
    var _debug2 = require_src2();
    var _debug3 = _interopRequireDefault(_debug2);
    var _invariant = require_invariant();
    var _invariant2 = _interopRequireDefault(_invariant);
    var _index = require_lib7();
    var _index2 = _interopRequireDefault(_index);
    var _assign = require_assign();
    var _assign2 = _interopRequireDefault(_assign);
    var _scope = require_scope();
    var _scope2 = _interopRequireDefault(_scope);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    var _cache = require_cache();
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _debug = (0, _debug3.default)("babel");
    var NodePath = function() {
      function NodePath2(hub, parent) {
        (0, _classCallCheck3.default)(this, NodePath2);
        this.parent = parent;
        this.hub = hub;
        this.contexts = [];
        this.data = {};
        this.shouldSkip = false;
        this.shouldStop = false;
        this.removed = false;
        this.state = null;
        this.opts = null;
        this.skipKeys = null;
        this.parentPath = null;
        this.context = null;
        this.container = null;
        this.listKey = null;
        this.inList = false;
        this.parentKey = null;
        this.key = null;
        this.node = null;
        this.scope = null;
        this.type = null;
        this.typeAnnotation = null;
      }
      __name(NodePath2, "NodePath");
      NodePath2.get = /* @__PURE__ */ __name(function get(_ref) {
        var hub = _ref.hub, parentPath = _ref.parentPath, parent = _ref.parent, container = _ref.container, listKey = _ref.listKey, key = _ref.key;
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        (0, _invariant2.default)(parent, "To get a node path the parent needs to exist");
        var targetNode = container[key];
        var paths = _cache.path.get(parent) || [];
        if (!_cache.path.has(parent)) {
          _cache.path.set(parent, paths);
        }
        var path2 = void 0;
        for (var i = 0; i < paths.length; i++) {
          var pathCheck = paths[i];
          if (pathCheck.node === targetNode) {
            path2 = pathCheck;
            break;
          }
        }
        if (!path2) {
          path2 = new NodePath2(hub, parent);
          paths.push(path2);
        }
        path2.setup(parentPath, container, listKey, key);
        return path2;
      }, "get");
      NodePath2.prototype.getScope = /* @__PURE__ */ __name(function getScope(scope) {
        var ourScope = scope;
        if (this.isScope()) {
          ourScope = new _scope2.default(this, scope);
        }
        return ourScope;
      }, "getScope");
      NodePath2.prototype.setData = /* @__PURE__ */ __name(function setData(key, val) {
        return this.data[key] = val;
      }, "setData");
      NodePath2.prototype.getData = /* @__PURE__ */ __name(function getData(key, def) {
        var val = this.data[key];
        if (!val && def)
          val = this.data[key] = def;
        return val;
      }, "getData");
      NodePath2.prototype.buildCodeFrameError = /* @__PURE__ */ __name(function buildCodeFrameError(msg) {
        var Error2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : SyntaxError;
        return this.hub.file.buildCodeFrameError(this.node, msg, Error2);
      }, "buildCodeFrameError");
      NodePath2.prototype.traverse = /* @__PURE__ */ __name(function traverse2(visitor3, state) {
        (0, _index2.default)(this.node, visitor3, this.scope, state, this);
      }, "traverse");
      NodePath2.prototype.mark = /* @__PURE__ */ __name(function mark(type4, message) {
        this.hub.file.metadata.marked.push({
          type: type4,
          message,
          loc: this.node.loc
        });
      }, "mark");
      NodePath2.prototype.set = /* @__PURE__ */ __name(function set(key, node) {
        t5.validate(this.node, key, node);
        this.node[key] = node;
      }, "set");
      NodePath2.prototype.getPathLocation = /* @__PURE__ */ __name(function getPathLocation() {
        var parts = [];
        var path2 = this;
        do {
          var key = path2.key;
          if (path2.inList)
            key = path2.listKey + "[" + key + "]";
          parts.unshift(key);
        } while (path2 = path2.parentPath);
        return parts.join(".");
      }, "getPathLocation");
      NodePath2.prototype.debug = /* @__PURE__ */ __name(function debug(buildMessage) {
        if (!_debug.enabled)
          return;
        _debug(this.getPathLocation() + " " + this.type + ": " + buildMessage());
      }, "debug");
      return NodePath2;
    }();
    exports2.default = NodePath;
    (0, _assign2.default)(NodePath.prototype, require_ancestry());
    (0, _assign2.default)(NodePath.prototype, require_inference());
    (0, _assign2.default)(NodePath.prototype, require_replacement());
    (0, _assign2.default)(NodePath.prototype, require_evaluation());
    (0, _assign2.default)(NodePath.prototype, require_conversion());
    (0, _assign2.default)(NodePath.prototype, require_introspection());
    (0, _assign2.default)(NodePath.prototype, require_context());
    (0, _assign2.default)(NodePath.prototype, require_removal());
    (0, _assign2.default)(NodePath.prototype, require_modification());
    (0, _assign2.default)(NodePath.prototype, require_family());
    (0, _assign2.default)(NodePath.prototype, require_comments());
    var _loop2 = /* @__PURE__ */ __name(function _loop22() {
      if (_isArray) {
        if (_i >= _iterator.length)
          return "break";
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          return "break";
        _ref2 = _i.value;
      }
      var type4 = _ref2;
      var typeKey = "is" + type4;
      NodePath.prototype[typeKey] = function(opts) {
        return t5[typeKey](this.node, opts);
      };
      NodePath.prototype["assert" + type4] = function(opts) {
        if (!this[typeKey](opts)) {
          throw new TypeError("Expected node path of type " + type4);
        }
      };
    }, "_loop2");
    for (_iterator = t5.TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
      _ret2 = _loop2();
      if (_ret2 === "break")
        break;
    }
    var _ref2;
    var _ret2;
    var _iterator;
    var _isArray;
    var _i;
    var _loop = /* @__PURE__ */ __name(function _loop3(type4) {
      if (type4[0] === "_")
        return "continue";
      if (t5.TYPES.indexOf(type4) < 0)
        t5.TYPES.push(type4);
      var virtualType = virtualTypes[type4];
      NodePath.prototype["is" + type4] = function(opts) {
        return virtualType.checkPath(this, opts);
      };
    }, "_loop");
    for (type3 in virtualTypes) {
      _ret = _loop(type3);
      if (_ret === "continue")
        continue;
    }
    var _ret;
    var type3;
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/hub.js
var require_hub = __commonJS({
  "node_modules/babel-traverse/lib/hub.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var Hub = /* @__PURE__ */ __name(function Hub2(file, options2) {
      (0, _classCallCheck3.default)(this, Hub2);
      this.file = file;
      this.options = options2;
    }, "Hub");
    exports2.default = Hub;
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/context.js
var require_context2 = __commonJS({
  "node_modules/babel-traverse/lib/context.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _classCallCheck2 = require_classCallCheck();
    var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
    var _path2 = require_path();
    var _path3 = _interopRequireDefault(_path2);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var testing = process.env.NODE_ENV === "test";
    var TraversalContext = function() {
      function TraversalContext2(scope, opts, state, parentPath) {
        (0, _classCallCheck3.default)(this, TraversalContext2);
        this.queue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      __name(TraversalContext2, "TraversalContext");
      TraversalContext2.prototype.shouldVisit = /* @__PURE__ */ __name(function shouldVisit(node) {
        var opts = this.opts;
        if (opts.enter || opts.exit)
          return true;
        if (opts[node.type])
          return true;
        var keys = t5.VISITOR_KEYS[node.type];
        if (!keys || !keys.length)
          return false;
        for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var key = _ref;
          if (node[key])
            return true;
        }
        return false;
      }, "shouldVisit");
      TraversalContext2.prototype.create = /* @__PURE__ */ __name(function create(node, obj, key, listKey) {
        return _path3.default.get({
          parentPath: this.parentPath,
          parent: node,
          container: obj,
          key,
          listKey
        });
      }, "create");
      TraversalContext2.prototype.maybeQueue = /* @__PURE__ */ __name(function maybeQueue(path2, notPriority) {
        if (this.trap) {
          throw new Error("Infinite cycle detected");
        }
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path2);
          } else {
            this.priorityQueue.push(path2);
          }
        }
      }, "maybeQueue");
      TraversalContext2.prototype.visitMultiple = /* @__PURE__ */ __name(function visitMultiple(container, parent, listKey) {
        if (container.length === 0)
          return false;
        var queue = [];
        for (var key = 0; key < container.length; key++) {
          var node = container[key];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }
        return this.visitQueue(queue);
      }, "visitMultiple");
      TraversalContext2.prototype.visitSingle = /* @__PURE__ */ __name(function visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }, "visitSingle");
      TraversalContext2.prototype.visitQueue = /* @__PURE__ */ __name(function visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        var visited = [];
        var stop = false;
        for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
          var _ref2;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref2 = _i2.value;
          }
          var path2 = _ref2;
          path2.resync();
          if (path2.contexts.length === 0 || path2.contexts[path2.contexts.length - 1] !== this) {
            path2.pushContext(this);
          }
          if (path2.key === null)
            continue;
          if (testing && queue.length >= 1e4) {
            this.trap = true;
          }
          if (visited.indexOf(path2.node) >= 0)
            continue;
          visited.push(path2.node);
          if (path2.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop)
              break;
          }
        }
        for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var _path = _ref3;
          _path.popContext();
        }
        this.queue = null;
        return stop;
      }, "visitQueue");
      TraversalContext2.prototype.visit = /* @__PURE__ */ __name(function visit(node, key) {
        var nodes = node[key];
        if (!nodes)
          return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }, "visit");
      return TraversalContext2;
    }();
    exports2.default = TraversalContext;
    module2.exports = exports2["default"];
  }
});

// node_modules/babel-traverse/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/babel-traverse/lib/visitors.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var _typeof2 = require_typeof();
    var _typeof3 = _interopRequireDefault(_typeof2);
    var _keys = require_keys2();
    var _keys2 = _interopRequireDefault(_keys);
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    exports2.explode = explode;
    exports2.verify = verify;
    exports2.merge = merge;
    var _virtualTypes = require_virtual_types();
    var virtualTypes = _interopRequireWildcard(_virtualTypes);
    var _babelMessages = require_lib4();
    var messages = _interopRequireWildcard(_babelMessages);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    var _clone = require_clone();
    var _clone2 = _interopRequireDefault(_clone);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function explode(visitor3) {
      if (visitor3._exploded)
        return visitor3;
      visitor3._exploded = true;
      for (var nodeType in visitor3) {
        if (shouldIgnoreKey(nodeType))
          continue;
        var parts = nodeType.split("|");
        if (parts.length === 1)
          continue;
        var fns = visitor3[nodeType];
        delete visitor3[nodeType];
        for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var part = _ref;
          visitor3[part] = fns;
        }
      }
      verify(visitor3);
      delete visitor3.__esModule;
      ensureEntranceObjects(visitor3);
      ensureCallbackArrays(visitor3);
      for (var _iterator2 = (0, _keys2.default)(visitor3), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2); ; ) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var _nodeType3 = _ref2;
        if (shouldIgnoreKey(_nodeType3))
          continue;
        var wrapper = virtualTypes[_nodeType3];
        if (!wrapper)
          continue;
        var _fns2 = visitor3[_nodeType3];
        for (var type3 in _fns2) {
          _fns2[type3] = wrapCheck(wrapper, _fns2[type3]);
        }
        delete visitor3[_nodeType3];
        if (wrapper.types) {
          for (var _iterator4 = wrapper.types, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4); ; ) {
            var _ref4;
            if (_isArray4) {
              if (_i4 >= _iterator4.length)
                break;
              _ref4 = _iterator4[_i4++];
            } else {
              _i4 = _iterator4.next();
              if (_i4.done)
                break;
              _ref4 = _i4.value;
            }
            var _type = _ref4;
            if (visitor3[_type]) {
              mergePair(visitor3[_type], _fns2);
            } else {
              visitor3[_type] = _fns2;
            }
          }
        } else {
          mergePair(visitor3, _fns2);
        }
      }
      for (var _nodeType in visitor3) {
        if (shouldIgnoreKey(_nodeType))
          continue;
        var _fns = visitor3[_nodeType];
        var aliases = t5.FLIPPED_ALIAS_KEYS[_nodeType];
        var deprecratedKey = t5.DEPRECATED_KEYS[_nodeType];
        if (deprecratedKey) {
          console.trace("Visitor defined for " + _nodeType + " but it has been renamed to " + deprecratedKey);
          aliases = [deprecratedKey];
        }
        if (!aliases)
          continue;
        delete visitor3[_nodeType];
        for (var _iterator3 = aliases, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3); ; ) {
          var _ref3;
          if (_isArray3) {
            if (_i3 >= _iterator3.length)
              break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done)
              break;
            _ref3 = _i3.value;
          }
          var alias3 = _ref3;
          var existing = visitor3[alias3];
          if (existing) {
            mergePair(existing, _fns);
          } else {
            visitor3[alias3] = (0, _clone2.default)(_fns);
          }
        }
      }
      for (var _nodeType2 in visitor3) {
        if (shouldIgnoreKey(_nodeType2))
          continue;
        ensureCallbackArrays(visitor3[_nodeType2]);
      }
      return visitor3;
    }
    __name(explode, "explode");
    function verify(visitor3) {
      if (visitor3._verified)
        return;
      if (typeof visitor3 === "function") {
        throw new Error(messages.get("traverseVerifyRootFunction"));
      }
      for (var nodeType in visitor3) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor3[nodeType]);
        }
        if (shouldIgnoreKey(nodeType))
          continue;
        if (t5.TYPES.indexOf(nodeType) < 0) {
          throw new Error(messages.get("traverseVerifyNodeType", nodeType));
        }
        var visitors = visitor3[nodeType];
        if ((typeof visitors === "undefined" ? "undefined" : (0, _typeof3.default)(visitors)) === "object") {
          for (var visitorKey in visitors) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
            } else {
              throw new Error(messages.get("traverseVerifyVisitorProperty", nodeType, visitorKey));
            }
          }
        }
      }
      visitor3._verified = true;
    }
    __name(verify, "verify");
    function validateVisitorMethods(path2, val) {
      var fns = [].concat(val);
      for (var _iterator5 = fns, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5); ; ) {
        var _ref5;
        if (_isArray5) {
          if (_i5 >= _iterator5.length)
            break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done)
            break;
          _ref5 = _i5.value;
        }
        var fn = _ref5;
        if (typeof fn !== "function") {
          throw new TypeError("Non-function found defined in " + path2 + " with type " + (typeof fn === "undefined" ? "undefined" : (0, _typeof3.default)(fn)));
        }
      }
    }
    __name(validateVisitorMethods, "validateVisitorMethods");
    function merge(visitors) {
      var states = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var wrapper = arguments[2];
      var rootVisitor = {};
      for (var i = 0; i < visitors.length; i++) {
        var visitor3 = visitors[i];
        var state = states[i];
        explode(visitor3);
        for (var type3 in visitor3) {
          var visitorType = visitor3[type3];
          if (state || wrapper) {
            visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
          }
          var nodeVisitor = rootVisitor[type3] = rootVisitor[type3] || {};
          mergePair(nodeVisitor, visitorType);
        }
      }
      return rootVisitor;
    }
    __name(merge, "merge");
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      var newVisitor = {};
      var _loop = /* @__PURE__ */ __name(function _loop2(key2) {
        var fns = oldVisitor[key2];
        if (!Array.isArray(fns))
          return "continue";
        fns = fns.map(function(fn) {
          var newFn = fn;
          if (state) {
            newFn = /* @__PURE__ */ __name(function newFn2(path2) {
              return fn.call(state, path2, state);
            }, "newFn");
          }
          if (wrapper) {
            newFn = wrapper(state.key, key2, newFn);
          }
          return newFn;
        });
        newVisitor[key2] = fns;
      }, "_loop");
      for (var key in oldVisitor) {
        var _ret = _loop(key);
        if (_ret === "continue")
          continue;
      }
      return newVisitor;
    }
    __name(wrapWithStateOrWrapper, "wrapWithStateOrWrapper");
    function ensureEntranceObjects(obj) {
      for (var key in obj) {
        if (shouldIgnoreKey(key))
          continue;
        var fns = obj[key];
        if (typeof fns === "function") {
          obj[key] = { enter: fns };
        }
      }
    }
    __name(ensureEntranceObjects, "ensureEntranceObjects");
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter))
        obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit))
        obj.exit = [obj.exit];
    }
    __name(ensureCallbackArrays, "ensureCallbackArrays");
    function wrapCheck(wrapper, fn) {
      var newFn = /* @__PURE__ */ __name(function newFn2(path2) {
        if (wrapper.checkPath(path2)) {
          return fn.apply(this, arguments);
        }
      }, "newFn");
      newFn.toString = function() {
        return fn.toString();
      };
      return newFn;
    }
    __name(wrapCheck, "wrapCheck");
    function shouldIgnoreKey(key) {
      if (key[0] === "_")
        return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip")
        return true;
      if (key === "blacklist" || key === "noScope" || key === "skipKeys")
        return true;
      return false;
    }
    __name(shouldIgnoreKey, "shouldIgnoreKey");
    function mergePair(dest, src) {
      for (var key in src) {
        dest[key] = [].concat(dest[key] || [], src[key]);
      }
    }
    __name(mergePair, "mergePair");
  }
});

// node_modules/babel-traverse/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/babel-traverse/lib/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.visitors = exports2.Hub = exports2.Scope = exports2.NodePath = void 0;
    var _getIterator2 = require_get_iterator2();
    var _getIterator3 = _interopRequireDefault(_getIterator2);
    var _path = require_path();
    Object.defineProperty(exports2, "NodePath", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _interopRequireDefault(_path).default;
      }, "get")
    });
    var _scope = require_scope();
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _interopRequireDefault(_scope).default;
      }, "get")
    });
    var _hub = require_hub();
    Object.defineProperty(exports2, "Hub", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _interopRequireDefault(_hub).default;
      }, "get")
    });
    exports2.default = traverse2;
    var _context = require_context2();
    var _context2 = _interopRequireDefault(_context);
    var _visitors = require_visitors();
    var visitors = _interopRequireWildcard(_visitors);
    var _babelMessages = require_lib4();
    var messages = _interopRequireWildcard(_babelMessages);
    var _includes = require_includes();
    var _includes2 = _interopRequireDefault(_includes);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    var _cache = require_cache();
    var cache = _interopRequireWildcard(_cache);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    exports2.visitors = visitors;
    function traverse2(parent, opts, scope, state, parentPath) {
      if (!parent)
        return;
      if (!opts)
        opts = {};
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(messages.get("traverseNeedsParent", parent.type));
        }
      }
      visitors.explode(opts);
      traverse2.node(parent, opts, scope, state, parentPath);
    }
    __name(traverse2, "traverse");
    traverse2.visitors = visitors;
    traverse2.verify = visitors.verify;
    traverse2.explode = visitors.explode;
    traverse2.NodePath = require_path();
    traverse2.Scope = require_scope();
    traverse2.Hub = require_hub();
    traverse2.cheap = function(node, enter) {
      return t5.traverseFast(node, enter);
    };
    traverse2.node = function(node, opts, scope, state, parentPath, skipKeys) {
      var keys = t5.VISITOR_KEYS[node.type];
      if (!keys)
        return;
      var context = new _context2.default(scope, opts, state, parentPath);
      for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var key = _ref;
        if (skipKeys && skipKeys[key])
          continue;
        if (context.visit(node, key))
          return;
      }
    };
    traverse2.clearNode = function(node, opts) {
      t5.removeProperties(node, opts);
      cache.path.delete(node);
    };
    traverse2.removeProperties = function(tree, opts) {
      t5.traverseFast(tree, traverse2.clearNode, opts);
      return tree;
    };
    function hasBlacklistedType(path2, state) {
      if (path2.node.type === state.type) {
        state.has = true;
        path2.stop();
      }
    }
    __name(hasBlacklistedType, "hasBlacklistedType");
    traverse2.hasType = function(tree, scope, type3, blacklistTypes) {
      if ((0, _includes2.default)(blacklistTypes, tree.type))
        return false;
      if (tree.type === type3)
        return true;
      var state = {
        has: false,
        type: type3
      };
      traverse2(tree, {
        blacklist: blacklistTypes,
        enter: hasBlacklistedType
      }, scope, state);
      return state.has;
    };
    traverse2.clearCache = function() {
      cache.clear();
    };
    traverse2.clearCache.clearPath = cache.clearPath;
    traverse2.clearCache.clearScope = cache.clearScope;
    traverse2.copyCache = function(source, destination) {
      if (cache.path.has(source)) {
        cache.path.set(destination, cache.path.get(source));
      }
    };
  }
});

// node_modules/babel-template/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/babel-template/lib/index.js"(exports2, module2) {
    "use strict";
    exports2.__esModule = true;
    var _symbol = require_symbol2();
    var _symbol2 = _interopRequireDefault(_symbol);
    exports2.default = function(code, opts) {
      var stack = void 0;
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          stack = error.stack.split("\n").slice(1).join("\n");
        }
      }
      opts = (0, _assign2.default)({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        preserveComments: false
      }, opts);
      var _getAst = /* @__PURE__ */ __name(function getAst() {
        var ast = void 0;
        try {
          ast = babylon.parse(code, opts);
          ast = _babelTraverse2.default.removeProperties(ast, { preserveComments: opts.preserveComments });
          _babelTraverse2.default.cheap(ast, function(node) {
            node[FROM_TEMPLATE] = true;
          });
        } catch (err) {
          err.stack = err.stack + "from\n" + stack;
          throw err;
        }
        _getAst = /* @__PURE__ */ __name(function getAst2() {
          return ast;
        }, "getAst");
        return ast;
      }, "getAst");
      return function() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return useTemplate(_getAst(), args);
      };
    };
    var _cloneDeep = require_cloneDeep();
    var _cloneDeep2 = _interopRequireDefault(_cloneDeep);
    var _assign = require_assign();
    var _assign2 = _interopRequireDefault(_assign);
    var _has = require_has2();
    var _has2 = _interopRequireDefault(_has);
    var _babelTraverse = require_lib7();
    var _babelTraverse2 = _interopRequireDefault(_babelTraverse);
    var _babylon = require_lib6();
    var babylon = _interopRequireWildcard(_babylon);
    var _babelTypes = require_lib();
    var t5 = _interopRequireWildcard(_babelTypes);
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var FROM_TEMPLATE = "_fromTemplate";
    var TEMPLATE_SKIP = (0, _symbol2.default)();
    function useTemplate(ast, nodes) {
      ast = (0, _cloneDeep2.default)(ast);
      var _ast = ast, program = _ast.program;
      if (nodes.length) {
        (0, _babelTraverse2.default)(ast, templateVisitor, null, nodes);
      }
      if (program.body.length > 1) {
        return program.body;
      } else {
        return program.body[0];
      }
    }
    __name(useTemplate, "useTemplate");
    var templateVisitor = {
      noScope: true,
      enter: /* @__PURE__ */ __name(function enter(path2, args) {
        var node = path2.node;
        if (node[TEMPLATE_SKIP])
          return path2.skip();
        if (t5.isExpressionStatement(node)) {
          node = node.expression;
        }
        var replacement = void 0;
        if (t5.isIdentifier(node) && node[FROM_TEMPLATE]) {
          if ((0, _has2.default)(args[0], node.name)) {
            replacement = args[0][node.name];
          } else if (node.name[0] === "$") {
            var i = +node.name.slice(1);
            if (args[i])
              replacement = args[i];
          }
        }
        if (replacement === null) {
          path2.remove();
        }
        if (replacement) {
          replacement[TEMPLATE_SKIP] = true;
          path2.replaceInline(replacement);
        }
      }, "enter"),
      exit: /* @__PURE__ */ __name(function exit(_ref) {
        var node = _ref.node;
        if (!node.loc)
          _babelTraverse2.default.clearNode(node);
      }, "exit")
    };
    module2.exports = exports2["default"];
  }
});

// src/index.js
var src_exports = {};
__export(src_exports, {
  EXPRESSION_NEEDED: () => EXPRESSION_NEEDED,
  FILTER_BLOCK: () => FILTER_BLOCK,
  GROUP_TOP_LEVEL_LOGICAL: () => GROUP_TOP_LEVEL_LOGICAL,
  INSIDE_OF_STRING: () => INSIDE_OF_STRING,
  IS_ROOT_LOGICAL_EXPRESSION: () => IS_ROOT_LOGICAL_EXPRESSION,
  NEWLINES_ONLY: () => NEWLINES_ONLY,
  OVERRIDE_QUOTE_CHAR: () => OVERRIDE_QUOTE_CHAR,
  PRESERVE_LEADING_WHITESPACE: () => PRESERVE_LEADING_WHITESPACE,
  PRESERVE_TRAILING_WHITESPACE: () => PRESERVE_TRAILING_WHITESPACE,
  STRING_NEEDS_QUOTES: () => STRING_NEEDS_QUOTES,
  countNewlines: () => countNewlines,
  createTextGroups: () => createTextGroups,
  findParentNode: () => findParentNode,
  firstValueInAncestorChain: () => firstValueInAncestorChain,
  getDeepProperty: () => getDeepProperty,
  hasAtLeastTwoNewlines: () => hasAtLeastTwoNewlines,
  hasNoNewlines: () => hasNoNewlines,
  indentWithHardline: () => indentWithHardline,
  isContractableNodeType: () => isContractableNodeType,
  isEmptySequence: () => isEmptySequence,
  isHtmlCommentEqualTo: () => isHtmlCommentEqualTo,
  isInlineElement: () => isInlineElement,
  isMelodyNode: () => isMelodyNode,
  isMultipartExpression: () => isMultipartExpression,
  isNotExpression: () => isNotExpression,
  isRootNode: () => isRootNode,
  isTwigCommentEqualTo: () => isTwigCommentEqualTo,
  isValidIdentifierName: () => isValidIdentifierName,
  isWhitespaceNode: () => isWhitespaceNode,
  isWhitespaceOnly: () => isWhitespaceOnly,
  languages: () => languages,
  normalizeHtmlComment: () => normalizeHtmlComment,
  normalizeTwigComment: () => normalizeTwigComment,
  options: () => options,
  parsers: () => parsers,
  printChildBlock: () => printChildBlock,
  printChildGroups: () => printChildGroups,
  printers: () => printers,
  quoteChar: () => quoteChar,
  registerContractableNodeType: () => registerContractableNodeType,
  removeSurroundingWhitespace: () => removeSurroundingWhitespace,
  setDeepProperty: () => setDeepProperty,
  shouldExpressionsBeWrapped: () => shouldExpressionsBeWrapped,
  someParentNode: () => someParentNode,
  stripHtmlCommentChars: () => stripHtmlCommentChars,
  stripTwigCommentChars: () => stripTwigCommentChars,
  testCurrentAndParentNodes: () => testCurrentAndParentNodes,
  testCurrentNode: () => testCurrentNode,
  walkParents: () => walkParents,
  wrapExpressionIfNeeded: () => wrapExpressionIfNeeded,
  wrapInEnvironment: () => wrapInEnvironment,
  wrapInStringInterpolation: () => wrapInStringInterpolation
});
module.exports = __toCommonJS(src_exports);

// src/util/prettier-doc-builders.js
function assertDoc(val) {
  if (typeof val === "string") {
    return;
  }
  if (Array.isArray(val)) {
    for (const doc of val) {
      assertDoc(doc);
    }
    return;
  }
  if (val && typeof val.type === "string") {
    return;
  }
  throw new Error("Value " + JSON.stringify(val) + " is not a valid document");
}
__name(assertDoc, "assertDoc");
function concat(parts) {
  if (process.env.NODE_ENV !== "production") {
    for (const part of parts) {
      assertDoc(part);
    }
  }
  return { type: "concat", parts };
}
__name(concat, "concat");
function indent(contents) {
  if (process.env.NODE_ENV !== "production") {
    assertDoc(contents);
  }
  return { type: "indent", contents };
}
__name(indent, "indent");
function group(contents, opts = {}) {
  if (process.env.NODE_ENV !== "production") {
    assertDoc(contents);
  }
  return {
    type: "group",
    id: opts.id,
    contents,
    break: Boolean(opts.shouldBreak),
    expandedStates: opts.expandedStates
  };
}
__name(group, "group");
function fill(parts) {
  if (process.env.NODE_ENV !== "production") {
    for (const part of parts) {
      assertDoc(part);
    }
  }
  return { type: "fill", parts };
}
__name(fill, "fill");
var breakParent = { type: "break-parent" };
var hardlineWithoutBreakParent = { type: "line", hard: true };
var literallineWithoutBreakParent = {
  type: "line",
  hard: true,
  literal: true
};
var line = { type: "line" };
var softline = { type: "line", soft: true };
var hardline = concat([hardlineWithoutBreakParent, breakParent]);
var literalline = concat([literallineWithoutBreakParent, breakParent]);
var cursor = { type: "cursor", placeholder: Symbol("cursor") };
function join(sep, arr) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (i !== 0) {
      res.push(sep);
    }
    res.push(arr[i]);
  }
  return concat(res);
}
__name(join, "join");

// src/util/pluginUtil.js
var import_path = __toESM(require("path"));
var import_resolve = __toESM(require_resolve());
var getPluginPathsFromOptions = /* @__PURE__ */ __name((options2) => {
  if (options2.twigMelodyPlugins && Array.isArray(options2.twigMelodyPlugins)) {
    return options2.twigMelodyPlugins.map((s) => s.trim());
  }
  return [];
}, "getPluginPathsFromOptions");
var getProjectRoot = /* @__PURE__ */ __name(() => {
  const parts = __dirname.split(import_path.default.sep);
  let index = parts.length - 1;
  let dirName = parts[index];
  while (dirName !== "node_modules" && index > 0) {
    index--;
    dirName = parts[index];
  }
  if (index === 0) {
    index = parts.length - 2;
  }
  const subPath = parts.slice(0, index);
  const joined = import_path.default.join(...subPath);
  const foundIndex = __dirname.indexOf(joined);
  return __dirname.slice(0, foundIndex) + joined;
}, "getProjectRoot");
var tryLoadPlugin = /* @__PURE__ */ __name((pluginPath) => {
  try {
    const projectRoot = getProjectRoot();
    const requirePath = import_resolve.default.sync(import_path.default.resolve(projectRoot, pluginPath));
    return eval("require")(requirePath);
  } catch (e) {
    console.error("Could not load plugin path " + pluginPath);
    return void 0;
  }
}, "tryLoadPlugin");
var loadPlugins = /* @__PURE__ */ __name((pluginPaths) => {
  const result = [];
  if (pluginPaths && Array.isArray(pluginPaths)) {
    pluginPaths.forEach((pluginPath2) => {
      const loadedPlugin = tryLoadPlugin(pluginPath2);
      if (loadedPlugin) {
        result.push(loadedPlugin);
      }
    });
  }
  return result;
}, "loadPlugins");
var getAdditionalMelodyExtensions = /* @__PURE__ */ __name((pluginPaths) => {
  let result = [];
  const loadedPlugins = loadPlugins(pluginPaths);
  loadedPlugins.forEach((loadedPlugin) => {
    result = result.concat(loadedPlugin.melodyExtensions);
  });
  return result.filter((elem) => !!elem);
}, "getAdditionalMelodyExtensions");

// src/util/publicSymbols.js
var STRING_NEEDS_QUOTES = Symbol("STRING_NEEDS_QUOTES");
var OVERRIDE_QUOTE_CHAR = Symbol("OVERRIDE_QUOTE_CHAR");
var EXPRESSION_NEEDED = Symbol("EXPRESSION_NEEDED");
var INSIDE_OF_STRING = Symbol("INSIDE_OF_STRING");
var FILTER_BLOCK = Symbol("FILTER_BLOCK");
var PRESERVE_LEADING_WHITESPACE = Symbol("PRESERVE_LEADING_WHITESPACE");
var PRESERVE_TRAILING_WHITESPACE = Symbol("PRESERVE_TRAILING_WHITESPACE");
var NEWLINES_ONLY = Symbol("NEWLINES_ONLY");
var GROUP_TOP_LEVEL_LOGICAL = Symbol("GROUP_TOP_LEVEL_LOGICAL");
var IS_ROOT_LOGICAL_EXPRESSION = Symbol("IS_ROOT_LOGICAL_EXPRESSION");

// src/util/publicFunctions.js
var import_melody_types = __toESM(require_lib2());
var INLINE_HTML_ELEMENTS = ["title", "h1", "h2", "h3", "h4", "h5", "h6", "a", "abbr", "acronym", "b", "bdo", "big", "br", "button", "cite", "code", "dd", "dfn", "em", "i", "img", "kbd", "label", "li", "mark", "q", "s", "samp", "strong", "sup", "sub", "small", "span", "time", "tt", "var"];
var CONTRACTABLE_NODE_TYPES = ["ObjectExpression", "BinaryExpression", "ConditionalExpression", "ArrayExpression"];
var registerContractableNodeType = /* @__PURE__ */ __name((nodeType) => {
  CONTRACTABLE_NODE_TYPES.push(nodeType);
}, "registerContractableNodeType");
var isContractableNodeType = /* @__PURE__ */ __name((node) => {
  for (let i = 0; i < CONTRACTABLE_NODE_TYPES.length; i++) {
    const contractableNodeType = CONTRACTABLE_NODE_TYPES[i];
    const methodName = "is" + contractableNodeType;
    if (import_melody_types.Node[methodName] && import_melody_types.Node[methodName].call(null, node)) {
      return true;
    }
  }
  if (import_melody_types.Node.isUnaryLike(node)) {
    return true;
  }
  return false;
}, "isContractableNodeType");
var isNotExpression = /* @__PURE__ */ __name((node) => import_melody_types.Node.isUnaryLike(node) && node.operator === "not", "isNotExpression");
var isMultipartExpression = /* @__PURE__ */ __name((node) => {
  return import_melody_types.Node.isBinaryExpression(node) || import_melody_types.Node.isConditionalExpression(node) || import_melody_types.Node.isUnaryLike(node);
}, "isMultipartExpression");
var walkParents = /* @__PURE__ */ __name((path2, callback, startWithSelf = false) => {
  let currentIndex = path2.stack.length - 1;
  if (!startWithSelf) {
    currentIndex -= 1;
  }
  while (currentIndex >= 0) {
    const currentElement = path2.stack[currentIndex];
    if (isMelodyNode(currentElement)) {
      const callbackResult = callback(currentElement);
      if (callbackResult === false) {
        return;
      }
    }
    currentIndex--;
  }
}, "walkParents");
var firstValueInAncestorChain = /* @__PURE__ */ __name((path2, property, defaultValue) => {
  let currentIndex = path2.stack.length - 2;
  while (currentIndex >= 0) {
    const currentElement = path2.stack[currentIndex];
    if (isMelodyNode(currentElement) && currentElement[property] !== void 0) {
      return currentElement[property];
    }
    currentIndex--;
  }
  return defaultValue;
}, "firstValueInAncestorChain");
var quoteChar = /* @__PURE__ */ __name((options2) => {
  return options2 && options2.twigSingleQuote ? "'" : '"';
}, "quoteChar");
var isValidIdentifierName = /* @__PURE__ */ __name((s) => {
  const identifierRegex = /^[A-Z][0-9A-Z_$]*$/i;
  return typeof s === "string" && identifierRegex.test(s);
}, "isValidIdentifierName");
var isMelodyNode = /* @__PURE__ */ __name((n3) => {
  const proto = n3.__proto__;
  return typeof n3 === "object" && proto.type && typeof import_melody_types.Node["is" + proto.type] === "function";
}, "isMelodyNode");
var findParentNode = /* @__PURE__ */ __name((path2) => {
  let currentIndex = path2.stack.length - 2;
  while (currentIndex >= 0) {
    const currentElement = path2.stack[currentIndex];
    if (isMelodyNode(currentElement)) {
      return currentElement;
    }
    currentIndex--;
  }
  return null;
}, "findParentNode");
var isRootNode = /* @__PURE__ */ __name((path2) => {
  return findParentNode(path2) === null;
}, "isRootNode");
var testCurrentAndParentNodes = /* @__PURE__ */ __name((path2, predicate) => testCurrentNode(path2, predicate) || someParentNode(path2, predicate), "testCurrentAndParentNodes");
var testCurrentNode = /* @__PURE__ */ __name((path2, predicate) => {
  const index = path2.stack.length - 1;
  if (index >= 0) {
    const node = path2.stack[index];
    return isMelodyNode(node) && predicate(node);
  }
  return false;
}, "testCurrentNode");
var someParentNode = /* @__PURE__ */ __name((path2, predicate) => {
  let currentIndex = path2.stack.length - 2;
  while (currentIndex >= 0) {
    const currentElement = path2.stack[currentIndex];
    if (isMelodyNode(currentElement) && predicate(currentElement)) {
      return true;
    }
    currentIndex--;
  }
  return false;
}, "someParentNode");
var shouldExpressionsBeWrapped = /* @__PURE__ */ __name((path2) => {
  let result = false;
  walkParents(path2, (node) => {
    if (node[INSIDE_OF_STRING] === true) {
      result = INSIDE_OF_STRING;
      return false;
    }
    if (node[EXPRESSION_NEEDED] === true) {
      result = EXPRESSION_NEEDED;
      return false;
    }
    if (node[EXPRESSION_NEEDED] === false || node[INSIDE_OF_STRING] === false) {
      return false;
    }
  });
  return result;
}, "shouldExpressionsBeWrapped");
var wrapExpressionIfNeeded = /* @__PURE__ */ __name((path2, fragments, node = {}) => {
  const wrapType = shouldExpressionsBeWrapped(path2);
  if (wrapType === EXPRESSION_NEEDED) {
    wrapInEnvironment(fragments, node.trimLeft, node.trimRight);
  } else if (wrapType === INSIDE_OF_STRING) {
    wrapInStringInterpolation(fragments);
  }
  return fragments;
}, "wrapExpressionIfNeeded");
var wrapInEnvironment = /* @__PURE__ */ __name((parts, trimLeft = false, trimRight = false) => {
  const leftBraces = trimLeft ? "{{-" : "{{";
  const rightBraces = trimRight ? "-}}" : "}}";
  parts.unshift(leftBraces, line);
  parts.push(line, rightBraces);
}, "wrapInEnvironment");
var wrapInStringInterpolation = /* @__PURE__ */ __name((parts) => {
  parts.unshift("#{");
  parts.push("}");
}, "wrapInStringInterpolation");
var isWhitespaceOnly = /* @__PURE__ */ __name((s) => typeof s === "string" && s.trim() === "", "isWhitespaceOnly");
var countNewlines = /* @__PURE__ */ __name((s) => {
  return (s.match(/\n/g) || "").length;
}, "countNewlines");
var hasNoNewlines = /* @__PURE__ */ __name((s) => {
  return countNewlines(s) === 0;
}, "hasNoNewlines");
var hasAtLeastTwoNewlines = /* @__PURE__ */ __name((s) => countNewlines(s) >= 2, "hasAtLeastTwoNewlines");
var splitByWhitespace = /* @__PURE__ */ __name((s) => s.split(/([\s\n]+)/gm), "splitByWhitespace");
var unifyWhitespace = /* @__PURE__ */ __name((s, replacement = " ") => splitByWhitespace(s).filter((s2) => !isWhitespaceOnly(s2)).join(replacement), "unifyWhitespace");
var normalizeWhitespace = /* @__PURE__ */ __name((whitespace) => {
  const numNewlines = countNewlines(whitespace);
  if (numNewlines > 0) {
    return numNewlines > 1 ? [hardline, hardline] : [hardline];
  }
  return [line];
}, "normalizeWhitespace");
var createTextGroups = /* @__PURE__ */ __name((s, preserveLeadingWhitespace, preserveTrailingWhitespace) => {
  const parts = splitByWhitespace(s);
  const groups = [];
  let currentGroup = [];
  const len = parts.length;
  parts.forEach((curr, index) => {
    if (curr !== "") {
      if (isWhitespaceOnly(curr)) {
        const isFirst = groups.length === 0 && currentGroup.length === 0;
        const isLast = index === len - 1 || index === len - 2 && parts[len - 1] === "";
        if (isFirst && preserveLeadingWhitespace || isLast && preserveTrailingWhitespace) {
          currentGroup.push(...normalizeWhitespace(curr));
        } else if (!isFirst && !isLast) {
          const numNewlines = countNewlines(curr);
          if (numNewlines <= 1) {
            currentGroup.push(line);
          } else {
            groups.push(currentGroup);
            currentGroup = [];
          }
        }
      } else {
        currentGroup.push(curr);
      }
    }
  });
  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }
  return groups.map((elem) => fill(elem));
}, "createTextGroups");
var isWhitespaceNode = /* @__PURE__ */ __name((node) => {
  return import_melody_types.Node.isPrintTextStatement(node) && isWhitespaceOnly(node.value.value) || import_melody_types.Node.isStringLiteral(node) && isWhitespaceOnly(node.value);
}, "isWhitespaceNode");
var isEmptySequence = /* @__PURE__ */ __name((node) => import_melody_types.Node.isSequenceExpression(node) && node.expressions.length === 0, "isEmptySequence");
var removeSurroundingWhitespace = /* @__PURE__ */ __name((children) => {
  if (!Array.isArray(children)) {
    return children;
  }
  const result = [];
  children.forEach((child, index) => {
    const isFirstOrLast = index === 0 || index === children.length - 1;
    if (isFirstOrLast && isWhitespaceNode(child)) {
      return;
    }
    result.push(child);
  });
  return result;
}, "removeSurroundingWhitespace");
var getDeepProperty = /* @__PURE__ */ __name((obj, ...properties) => {
  let result = obj;
  properties.forEach((p) => {
    result = result[p];
  });
  return result;
}, "getDeepProperty");
var setDeepProperty = /* @__PURE__ */ __name((obj, value, ...properties) => {
  let containingObject = obj;
  const len = properties.length;
  for (let i = 0; i < len - 1; i++) {
    containingObject = containingObject[properties[i]];
  }
  containingObject[properties[len - 1]] = value;
}, "setDeepProperty");
var printChildBlock = /* @__PURE__ */ __name((node, path2, print2, ...childPath) => {
  const originalChildren = getDeepProperty(node, ...childPath);
  setDeepProperty(node, removeSurroundingWhitespace(originalChildren), ...childPath);
  const childGroups = printChildGroups(node, path2, print2, ...childPath);
  return indent(group(concat([hardline, ...childGroups])));
}, "printChildBlock");
var addNewlineIfNotEmpty = /* @__PURE__ */ __name((items) => {
  if (items.length > 0) {
    items.push(hardline);
  }
}, "addNewlineIfNotEmpty");
var endsWithHtmlComment = /* @__PURE__ */ __name((s) => s.endsWith("-->"), "endsWithHtmlComment");
var stripCommentChars = /* @__PURE__ */ __name((start, end) => (s) => {
  let result = s;
  if (result.startsWith(start)) {
    result = result.slice(start.length);
  }
  if (result.endsWith(end)) {
    result = result.slice(0, 0 - end.length);
  }
  return result;
}, "stripCommentChars");
var stripHtmlCommentChars = stripCommentChars("<!--", "-->");
var stripTwigCommentChars = /* @__PURE__ */ __name((s) => {
  let result = s;
  if (result.startsWith("{#")) {
    result = result.slice(2);
  }
  if (result.startsWith("-")) {
    result = result.slice(1);
  }
  if (result.endsWith("#}")) {
    result = result.slice(0, -2);
  }
  if (result.endsWith("-")) {
    result = result.slice(0, -1);
  }
  return result;
}, "stripTwigCommentChars");
var normalizeHtmlComment = /* @__PURE__ */ __name((s) => {
  const commentText = stripHtmlCommentChars(s);
  return "<!-- " + unifyWhitespace(commentText) + " -->";
}, "normalizeHtmlComment");
var normalizeTwigComment = /* @__PURE__ */ __name((s, trimLeft, trimRight) => {
  const commentText = stripTwigCommentChars(s);
  const open = trimLeft ? "{#-" : "{#";
  const close = trimRight ? "-#}" : "#}";
  return open + " " + unifyWhitespace(commentText) + " " + close;
}, "normalizeTwigComment");
var isHtmlCommentEqualTo = /* @__PURE__ */ __name((substr) => (node) => {
  return node.constructor.name === "HtmlComment" && node.value.value && normalizeHtmlComment(node.value.value) === "<!-- " + substr + " -->";
}, "isHtmlCommentEqualTo");
var isTwigCommentEqualTo = /* @__PURE__ */ __name((substr) => (node) => {
  return node.constructor.name === "TwigComment" && node.value.value && normalizeTwigComment(node.value.value.replace(" [special]", "")) === "{# " + substr + " #}";
}, "isTwigCommentEqualTo");
var isInlineTextStatement = /* @__PURE__ */ __name((node) => {
  if (!import_melody_types.Node.isPrintTextStatement(node)) {
    return false;
  }
  const trimmedValue = typeof node.value.value === "string" && node.value.value.trim();
  return !endsWithHtmlComment(trimmedValue);
}, "isInlineTextStatement");
var isInlineElement = /* @__PURE__ */ __name((node) => {
  const isInlineHtmlElement = import_melody_types.Node.isElement(node) && INLINE_HTML_ELEMENTS.indexOf(node.name) >= 0;
  return isInlineHtmlElement || import_melody_types.Node.isPrintExpressionStatement(node) || isInlineTextStatement(node);
}, "isInlineElement");
var isCommentNode = /* @__PURE__ */ __name((node) => import_melody_types.Node.isTwigComment(node) || import_melody_types.Node.isHtmlComment(node), "isCommentNode");
var createInlineMap = /* @__PURE__ */ __name((nodes) => nodes.map((node) => isInlineElement(node)), "createInlineMap");
var textStatementsOnlyNewlines = /* @__PURE__ */ __name((nodes) => {
  nodes.forEach((node) => {
    if (import_melody_types.Node.isPrintTextStatement(node)) {
      node[NEWLINES_ONLY] = true;
    }
  });
}, "textStatementsOnlyNewlines");
var addPreserveWhitespaceInfo = /* @__PURE__ */ __name((inlineMap, nodes) => {
  nodes.forEach((node, index) => {
    const previousNodeIsComment = index > 0 && isCommentNode(nodes[index - 1]);
    const followingNodeIsComment = index < nodes.length - 1 && isCommentNode(nodes[index + 1]);
    if (import_melody_types.Node.isPrintTextStatement(node)) {
      const hasPreviousInlineElement = index > 0 && inlineMap[index - 1];
      if (hasPreviousInlineElement || previousNodeIsComment) {
        node[PRESERVE_LEADING_WHITESPACE] = true;
      }
      const hasFollowingInlineElement = index < inlineMap.length - 1 && inlineMap[index + 1];
      if (hasFollowingInlineElement || followingNodeIsComment) {
        node[PRESERVE_TRAILING_WHITESPACE] = true;
      }
    }
  });
}, "addPreserveWhitespaceInfo");
var indentWithHardline = /* @__PURE__ */ __name((contents) => indent(concat([hardline, contents])), "indentWithHardline");
var printChildGroups = /* @__PURE__ */ __name((node, path2, print2, ...childPath) => {
  const children = getDeepProperty(node, ...childPath);
  const inlineMap = createInlineMap(children);
  addPreserveWhitespaceInfo(inlineMap, children);
  textStatementsOnlyNewlines(children);
  const printedChildren = path2.map(print2, ...childPath);
  let inlineGroup = [];
  const finishedGroups = [];
  printedChildren.forEach((child, index) => {
    if (inlineMap[index]) {
      inlineGroup.push(child);
    } else {
      if (inlineGroup.length > 0) {
        finishedGroups.push(fill(inlineGroup));
        inlineGroup = [];
      }
      if (finishedGroups.length > 0 && !inlineMap[index - 1]) {
        addNewlineIfNotEmpty(finishedGroups);
      }
      finishedGroups.push(child);
    }
  });
  if (inlineGroup.length > 0) {
    finishedGroups.push(fill(inlineGroup));
  }
  return finishedGroups;
}, "printChildGroups");

// src/util/printFunctions.js
var import_melody_types2 = __toESM(require_lib2());
var noSpaceBeforeToken = {
  ",": true
};
var printSingleTwigTag = /* @__PURE__ */ __name((node, path2, print2) => {
  const opener = node.trimLeft ? "{%-" : "{%";
  const parts = [opener, " ", node.tagName];
  const printedParts = path2.map(print2, "parts");
  if (printedParts.length > 0) {
    parts.push(" ", printedParts[0]);
  }
  const indentedParts = [];
  for (let i = 1; i < node.parts.length; i++) {
    const part = node.parts[i];
    const isToken = import_melody_types2.Node.isGenericToken(part);
    const separator = isToken && noSpaceBeforeToken[part.tokenText] ? "" : line;
    indentedParts.push(separator, printedParts[i]);
  }
  if (node.parts.length > 1) {
    parts.push(indent(concat(indentedParts)));
  }
  const closing = node.trimRight ? "-%}" : "%}";
  parts.push(line, closing);
  return group(concat(parts));
}, "printSingleTwigTag");

// src/print/SequenceExpression.js
var printSequenceExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = false;
  node.expressions = removeSurroundingWhitespace(node.expressions);
  const items = printChildGroups(node, path2, print2, "expressions");
  if (isRootNode(path2)) {
    return concat([...items, hardline]);
  }
  return concat(items);
}, "printSequenceExpression");

// src/print/BinaryExpression.js
var import_melody_types15 = __toESM(require_lib2());

// src/melody-extension-core/src/operators.js
var import_melody_types3 = __toESM(require_lib2());

// src/melody-parser/src/Parser.js
var n2 = __toESM(require_lib2());

// src/melody-parser/src/TokenTypes.js
var TokenTypes_exports = {};
__export(TokenTypes_exports, {
  ASSIGNMENT: () => ASSIGNMENT,
  COLON: () => COLON,
  COMMA: () => COMMA,
  COMMENT: () => COMMENT,
  DECLARATION_START: () => DECLARATION_START,
  DOT: () => DOT,
  ELEMENT_END: () => ELEMENT_END,
  ELEMENT_START: () => ELEMENT_START,
  ENTITY: () => ENTITY,
  EOF: () => EOF,
  EOF_TOKEN: () => EOF_TOKEN,
  ERROR: () => ERROR,
  ERROR_TABLE: () => ERROR_TABLE,
  EXPRESSION_END: () => EXPRESSION_END,
  EXPRESSION_START: () => EXPRESSION_START,
  FALSE: () => FALSE,
  HTML_COMMENT: () => HTML_COMMENT,
  INTERPOLATION_END: () => INTERPOLATION_END,
  INTERPOLATION_START: () => INTERPOLATION_START,
  LBRACE: () => LBRACE,
  LBRACKET: () => LBRACKET,
  LPAREN: () => LPAREN,
  NULL: () => NULL,
  NUMBER: () => NUMBER,
  OPERATOR: () => OPERATOR,
  PIPE: () => PIPE,
  QUESTION_MARK: () => QUESTION_MARK,
  RBRACE: () => RBRACE,
  RBRACKET: () => RBRACKET,
  RPAREN: () => RPAREN,
  SLASH: () => SLASH,
  STRING: () => STRING,
  STRING_END: () => STRING_END,
  STRING_START: () => STRING_START,
  SYMBOL: () => SYMBOL,
  TAG_END: () => TAG_END,
  TAG_START: () => TAG_START,
  TEXT: () => TEXT,
  TRUE: () => TRUE,
  WHITESPACE: () => WHITESPACE
});
var EXPRESSION_START = "expressionStart";
var EXPRESSION_END = "expressionEnd";
var TAG_START = "tagStart";
var TAG_END = "tagEnd";
var INTERPOLATION_START = "interpolationStart";
var INTERPOLATION_END = "interpolationEnd";
var STRING_START = "stringStart";
var STRING_END = "stringEnd";
var DECLARATION_START = "declarationStart";
var COMMENT = "comment";
var WHITESPACE = "whitespace";
var HTML_COMMENT = "htmlComment";
var TEXT = "text";
var ENTITY = "entity";
var SYMBOL = "symbol";
var STRING = "string";
var OPERATOR = "operator";
var TRUE = "true";
var FALSE = "false";
var NULL = "null";
var LBRACE = "[";
var RBRACE = "]";
var LPAREN = "(";
var RPAREN = ")";
var LBRACKET = "{";
var RBRACKET = "}";
var COLON = ":";
var COMMA = ",";
var DOT = ".";
var PIPE = "|";
var QUESTION_MARK = "?";
var ASSIGNMENT = "=";
var ELEMENT_START = "<";
var SLASH = "/";
var ELEMENT_END = ">";
var NUMBER = "number";
var EOF = "EOF";
var ERROR = "ERROR";
var EOF_TOKEN = {
  type: EOF,
  pos: {
    index: -1,
    line: -1,
    pos: -1
  },
  end: -1,
  length: 0,
  source: null,
  text: ""
};
var ERROR_TABLE = {
  [EXPRESSION_END]: 'expression end "}}"',
  [EXPRESSION_START]: 'expression start "{{"',
  [TAG_START]: 'tag start "{%"',
  [TAG_END]: 'tag end "%}"',
  [INTERPOLATION_START]: 'interpolation start "#{"',
  [INTERPOLATION_END]: 'interpolation end "}"'
};

// src/melody-parser/src/Associativity.js
var LEFT = Symbol();
var RIGHT = Symbol();

// src/melody-parser/src/util.js
function setStartFromToken(node, { pos: { index, line: line2, column } }) {
  node.loc.start = { line: line2, column, index };
  return node;
}
__name(setStartFromToken, "setStartFromToken");
function setEndFromToken(node, { pos: { line: line2, column }, end }) {
  node.loc.end = { line: line2, column, index: end };
  return node;
}
__name(setEndFromToken, "setEndFromToken");
function setMarkFromToken(node, propertyName, { pos: { index, line: line2, column } }) {
  node[propertyName] = { line: line2, column, index };
  return node;
}
__name(setMarkFromToken, "setMarkFromToken");
function copyStart(node, {
  loc: {
    start: { line: line2, column, index }
  }
}) {
  node.loc.start.line = line2;
  node.loc.start.column = column;
  node.loc.start.index = index;
  return node;
}
__name(copyStart, "copyStart");
function copyEnd(node, end) {
  node.loc.end.line = end.loc.end.line;
  node.loc.end.column = end.loc.end.column;
  node.loc.end.index = end.loc.end.index;
  return node;
}
__name(copyEnd, "copyEnd");
function copyLoc(node, { loc: { start, end } }) {
  node.loc.start.line = start.line;
  node.loc.start.column = start.column;
  node.loc.start.index = start.index;
  node.loc.end.line = end.line;
  node.loc.end.column = end.column;
  node.loc.end.index = end.index;
  return node;
}
__name(copyLoc, "copyLoc");
function createNode(Type, token, ...args) {
  return setEndFromToken(setStartFromToken(new Type(...args), token), token);
}
__name(createNode, "createNode");
function hasTagStartTokenTrimLeft(token) {
  return token.text.endsWith("-");
}
__name(hasTagStartTokenTrimLeft, "hasTagStartTokenTrimLeft");
function hasTagEndTokenTrimRight(token) {
  return token.text.startsWith("-");
}
__name(hasTagEndTokenTrimRight, "hasTagEndTokenTrimRight");

// src/melody-parser/src/GenericTagParser.js
var n = __toESM(require_lib2());
var GenericTagParser = {
  name: "genericTwigTag",
  parse(parser) {
    const tokens = parser.tokens, tagStartToken = tokens.la(-2);
    let currentToken;
    const twigTag = new n.GenericTwigTag(tokens.la(-1).text);
    while (currentToken = tokens.la(0)) {
      if (currentToken.type === TAG_END) {
        break;
      } else {
        try {
          twigTag.parts.push(parser.matchExpression());
        } catch (e) {
          if (e.errorType === "UNEXPECTED_TOKEN") {
            twigTag.parts.push(new n.GenericToken(e.tokenType, e.tokenText));
            tokens.next();
          } else {
            throw e;
          }
        }
      }
    }
    tokens.expect(TAG_END);
    twigTag.trimLeft = hasTagStartTokenTrimLeft(tagStartToken);
    twigTag.trimRight = hasTagEndTokenTrimRight(currentToken);
    return twigTag;
  }
};

// src/melody-parser/src/GenericMultiTagParser.js
var tagMatchesOneOf = /* @__PURE__ */ __name((tokenStream, tagNames) => {
  for (let i = 0; i < tagNames.length; i++) {
    if (tokenStream.test(SYMBOL, tagNames[i])) {
      return true;
    }
  }
  return false;
}, "tagMatchesOneOf");
var createMultiTagParser = /* @__PURE__ */ __name((tagName, subTags = []) => ({
  name: "genericTwigMultiTag",
  parse(parser, token) {
    const tokens = parser.tokens, tagStartToken = tokens.la(-1);
    if (subTags.length === 0) {
      subTags.push("end" + tagName);
    }
    const twigTag = GenericTagParser.parse(parser, token);
    let currentTagName = tagName;
    const endTagName = subTags[subTags.length - 1];
    while (currentTagName !== endTagName) {
      twigTag.sections.push(parser.parse((tokenText, token2, tokens2) => {
        const hasReachedNextTag = token2.type === TAG_START && tagMatchesOneOf(tokens2, subTags);
        return hasReachedNextTag;
      }));
      tokens.next();
      const childTag = GenericTagParser.parse(parser);
      twigTag.sections.push(childTag);
      currentTagName = childTag.tagName;
    }
    setStartFromToken(twigTag, tagStartToken);
    setEndFromToken(twigTag, tokens.la(0));
    return twigTag;
  }
}), "createMultiTagParser");

// src/melody-parser/src/elementInfo.js
var voidElements = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array([7489, 60, 213, 305, 650, 1181, 1403, 1488, 1653, 1758, 1954, 2006, 2063, 2634, 2705, 3489, 3693, 3849, 3878, 4298, 4648, 4833, 5141, 5277, 5315, 5343, 5413, 0, 0, 0, 0, 0, 0, 5483, 5837, 6541, 7186, 7645, 8062, 8288, 8624, 8845, 9152, 9211, 9282, 10276, 10514, 11528, 11848, 12238, 12310, 12986, 13881, 14252, 14590, 14888, 14961, 15072, 15150, 2048, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 92, 98, 102, 109, 115, 127, 132, 139, 144, 149, 152, 166, 179, 185, 200, 207, 108, 105, 103, 32827, 198, 16582, 80, 32827, 38, 16422, 99, 117, 116, 101, 32827, 193, 16577, 114, 101, 118, 101, 59, 16642, 256, 105, 121, 120, 125, 114, 99, 32827, 194, 16578, 59, 17424, 114, 59, 49152, 55349, 56580, 114, 97, 118, 101, 32827, 192, 16576, 112, 104, 97, 59, 17297, 97, 99, 114, 59, 16640, 100, 59, 27219, 256, 103, 112, 157, 161, 111, 110, 59, 16644, 102, 59, 49152, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 24673, 105, 110, 103, 32827, 197, 16581, 256, 99, 115, 190, 195, 114, 59, 49152, 55349, 56476, 105, 103, 110, 59, 25172, 105, 108, 100, 101, 32827, 195, 16579, 109, 108, 32827, 196, 16580, 1024, 97, 99, 101, 102, 111, 114, 115, 117, 229, 251, 254, 279, 284, 290, 295, 298, 256, 99, 114, 234, 242, 107, 115, 108, 97, 115, 104, 59, 25110, 374, 246, 248, 59, 27367, 101, 100, 59, 25350, 121, 59, 17425, 384, 99, 114, 116, 261, 267, 276, 97, 117, 115, 101, 59, 25141, 110, 111, 117, 108, 108, 105, 115, 59, 24876, 97, 59, 17298, 114, 59, 49152, 55349, 56581, 112, 102, 59, 49152, 55349, 56633, 101, 118, 101, 59, 17112, 99, 242, 275, 109, 112, 101, 113, 59, 25166, 1792, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 333, 337, 342, 384, 414, 418, 437, 439, 442, 476, 533, 627, 632, 638, 99, 121, 59, 17447, 80, 89, 32827, 169, 16553, 384, 99, 112, 121, 349, 354, 378, 117, 116, 101, 59, 16646, 256, 59, 105, 359, 360, 25298, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 24901, 108, 101, 121, 115, 59, 24877, 512, 97, 101, 105, 111, 393, 398, 404, 408, 114, 111, 110, 59, 16652, 100, 105, 108, 32827, 199, 16583, 114, 99, 59, 16648, 110, 105, 110, 116, 59, 25136, 111, 116, 59, 16650, 256, 100, 110, 423, 429, 105, 108, 108, 97, 59, 16568, 116, 101, 114, 68, 111, 116, 59, 16567, 242, 383, 105, 59, 17319, 114, 99, 108, 101, 512, 68, 77, 80, 84, 455, 459, 465, 470, 111, 116, 59, 25241, 105, 110, 117, 115, 59, 25238, 108, 117, 115, 59, 25237, 105, 109, 101, 115, 59, 25239, 111, 256, 99, 115, 482, 504, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25138, 101, 67, 117, 114, 108, 121, 256, 68, 81, 515, 527, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 24605, 117, 111, 116, 101, 59, 24601, 512, 108, 110, 112, 117, 542, 552, 583, 597, 111, 110, 256, 59, 101, 549, 550, 25143, 59, 27252, 384, 103, 105, 116, 559, 566, 570, 114, 117, 101, 110, 116, 59, 25185, 110, 116, 59, 25135, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25134, 256, 102, 114, 588, 590, 59, 24834, 111, 100, 117, 99, 116, 59, 25104, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 25139, 111, 115, 115, 59, 27183, 99, 114, 59, 49152, 55349, 56478, 112, 256, 59, 67, 644, 645, 25299, 97, 112, 59, 25165, 1408, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 672, 684, 688, 692, 696, 715, 727, 737, 742, 819, 1165, 256, 59, 111, 377, 677, 116, 114, 97, 104, 100, 59, 26897, 99, 121, 59, 17410, 99, 121, 59, 17413, 99, 121, 59, 17423, 384, 103, 114, 115, 703, 708, 711, 103, 101, 114, 59, 24609, 114, 59, 24993, 104, 118, 59, 27364, 256, 97, 121, 720, 725, 114, 111, 110, 59, 16654, 59, 17428, 108, 256, 59, 116, 733, 734, 25095, 97, 59, 17300, 114, 59, 49152, 55349, 56583, 256, 97, 102, 747, 807, 256, 99, 109, 752, 802, 114, 105, 116, 105, 99, 97, 108, 512, 65, 68, 71, 84, 768, 774, 790, 796, 99, 117, 116, 101, 59, 16564, 111, 372, 779, 781, 59, 17113, 98, 108, 101, 65, 99, 117, 116, 101, 59, 17117, 114, 97, 118, 101, 59, 16480, 105, 108, 100, 101, 59, 17116, 111, 110, 100, 59, 25284, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 24902, 1136, 829, 0, 0, 0, 834, 852, 0, 1029, 102, 59, 49152, 55349, 56635, 384, 59, 68, 69, 840, 841, 845, 16552, 111, 116, 59, 24796, 113, 117, 97, 108, 59, 25168, 98, 108, 101, 768, 67, 68, 76, 82, 85, 86, 867, 882, 898, 975, 994, 1016, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 236, 569, 111, 628, 889, 0, 0, 891, 187, 841, 110, 65, 114, 114, 111, 119, 59, 25043, 256, 101, 111, 903, 932, 102, 116, 384, 65, 82, 84, 912, 918, 929, 114, 114, 111, 119, 59, 25040, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 25044, 101, 229, 714, 110, 103, 256, 76, 82, 939, 964, 101, 102, 116, 256, 65, 82, 947, 953, 114, 114, 111, 119, 59, 26616, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26618, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26617, 105, 103, 104, 116, 256, 65, 84, 984, 990, 114, 114, 111, 119, 59, 25042, 101, 101, 59, 25256, 112, 577, 1001, 0, 0, 1007, 114, 114, 111, 119, 59, 25041, 111, 119, 110, 65, 114, 114, 111, 119, 59, 25045, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25125, 110, 768, 65, 66, 76, 82, 84, 97, 1042, 1066, 1072, 1118, 1151, 892, 114, 114, 111, 119, 384, 59, 66, 85, 1053, 1054, 1058, 24979, 97, 114, 59, 26899, 112, 65, 114, 114, 111, 119, 59, 25077, 114, 101, 118, 101, 59, 17169, 101, 102, 116, 722, 1082, 0, 1094, 0, 1104, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 26960, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26974, 101, 99, 116, 111, 114, 256, 59, 66, 1113, 1114, 25021, 97, 114, 59, 26966, 105, 103, 104, 116, 468, 1127, 0, 1137, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26975, 101, 99, 116, 111, 114, 256, 59, 66, 1146, 1147, 25025, 97, 114, 59, 26967, 101, 101, 256, 59, 65, 1158, 1159, 25252, 114, 114, 111, 119, 59, 24999, 256, 99, 116, 1170, 1175, 114, 59, 49152, 55349, 56479, 114, 111, 107, 59, 16656, 2048, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1213, 1216, 1220, 1227, 1246, 1250, 1255, 1262, 1269, 1313, 1327, 1334, 1362, 1373, 1376, 1381, 71, 59, 16714, 72, 32827, 208, 16592, 99, 117, 116, 101, 32827, 201, 16585, 384, 97, 105, 121, 1234, 1239, 1244, 114, 111, 110, 59, 16666, 114, 99, 32827, 202, 16586, 59, 17453, 111, 116, 59, 16662, 114, 59, 49152, 55349, 56584, 114, 97, 118, 101, 32827, 200, 16584, 101, 109, 101, 110, 116, 59, 25096, 256, 97, 112, 1274, 1278, 99, 114, 59, 16658, 116, 121, 595, 1286, 0, 0, 1298, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26107, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26027, 256, 103, 112, 1318, 1322, 111, 110, 59, 16664, 102, 59, 49152, 55349, 56636, 115, 105, 108, 111, 110, 59, 17301, 117, 256, 97, 105, 1340, 1353, 108, 256, 59, 84, 1346, 1347, 27253, 105, 108, 100, 101, 59, 25154, 108, 105, 98, 114, 105, 117, 109, 59, 25036, 256, 99, 105, 1367, 1370, 114, 59, 24880, 109, 59, 27251, 97, 59, 17303, 109, 108, 32827, 203, 16587, 256, 105, 112, 1386, 1391, 115, 116, 115, 59, 25091, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 24903, 640, 99, 102, 105, 111, 115, 1413, 1416, 1421, 1458, 1484, 121, 59, 17444, 114, 59, 49152, 55349, 56585, 108, 108, 101, 100, 595, 1431, 0, 0, 1443, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26108, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 26026, 880, 1466, 0, 1471, 0, 0, 1476, 102, 59, 49152, 55349, 56637, 65, 108, 108, 59, 25088, 114, 105, 101, 114, 116, 114, 102, 59, 24881, 99, 242, 1483, 1536, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1512, 1516, 1519, 1530, 1536, 1554, 1558, 1563, 1565, 1571, 1644, 1650, 99, 121, 59, 17411, 32827, 62, 16446, 109, 109, 97, 256, 59, 100, 1527, 1528, 17299, 59, 17372, 114, 101, 118, 101, 59, 16670, 384, 101, 105, 121, 1543, 1548, 1552, 100, 105, 108, 59, 16674, 114, 99, 59, 16668, 59, 17427, 111, 116, 59, 16672, 114, 59, 49152, 55349, 56586, 59, 25305, 112, 102, 59, 49152, 55349, 56638, 101, 97, 116, 101, 114, 768, 69, 70, 71, 76, 83, 84, 1589, 1604, 1614, 1622, 1627, 1638, 113, 117, 97, 108, 256, 59, 76, 1598, 1599, 25189, 101, 115, 115, 59, 25307, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25191, 114, 101, 97, 116, 101, 114, 59, 27298, 101, 115, 115, 59, 25207, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 27262, 105, 108, 100, 101, 59, 25203, 99, 114, 59, 49152, 55349, 56482, 59, 25195, 1024, 65, 97, 99, 102, 105, 111, 115, 117, 1669, 1675, 1686, 1691, 1694, 1706, 1726, 1738, 82, 68, 99, 121, 59, 17450, 256, 99, 116, 1680, 1684, 101, 107, 59, 17095, 59, 16478, 105, 114, 99, 59, 16676, 114, 59, 24844, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 24843, 496, 1711, 0, 1714, 102, 59, 24845, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 25856, 256, 99, 116, 1731, 1733, 242, 1705, 114, 111, 107, 59, 16678, 109, 112, 324, 1744, 1752, 111, 119, 110, 72, 117, 109, 240, 303, 113, 117, 97, 108, 59, 25167, 1792, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 1786, 1790, 1795, 1799, 1806, 1818, 1822, 1825, 1832, 1860, 1912, 1931, 1935, 1941, 99, 121, 59, 17429, 108, 105, 103, 59, 16690, 99, 121, 59, 17409, 99, 117, 116, 101, 32827, 205, 16589, 256, 105, 121, 1811, 1816, 114, 99, 32827, 206, 16590, 59, 17432, 111, 116, 59, 16688, 114, 59, 24849, 114, 97, 118, 101, 32827, 204, 16588, 384, 59, 97, 112, 1824, 1839, 1855, 256, 99, 103, 1844, 1847, 114, 59, 16682, 105, 110, 97, 114, 121, 73, 59, 24904, 108, 105, 101, 243, 989, 500, 1865, 0, 1890, 256, 59, 101, 1869, 1870, 25132, 256, 103, 114, 1875, 1880, 114, 97, 108, 59, 25131, 115, 101, 99, 116, 105, 111, 110, 59, 25282, 105, 115, 105, 98, 108, 101, 256, 67, 84, 1900, 1906, 111, 109, 109, 97, 59, 24675, 105, 109, 101, 115, 59, 24674, 384, 103, 112, 116, 1919, 1923, 1928, 111, 110, 59, 16686, 102, 59, 49152, 55349, 56640, 97, 59, 17305, 99, 114, 59, 24848, 105, 108, 100, 101, 59, 16680, 491, 1946, 0, 1950, 99, 121, 59, 17414, 108, 32827, 207, 16591, 640, 99, 102, 111, 115, 117, 1964, 1975, 1980, 1986, 2e3, 256, 105, 121, 1969, 1973, 114, 99, 59, 16692, 59, 17433, 114, 59, 49152, 55349, 56589, 112, 102, 59, 49152, 55349, 56641, 483, 1991, 0, 1996, 114, 59, 49152, 55349, 56485, 114, 99, 121, 59, 17416, 107, 99, 121, 59, 17412, 896, 72, 74, 97, 99, 102, 111, 115, 2020, 2024, 2028, 2033, 2045, 2050, 2056, 99, 121, 59, 17445, 99, 121, 59, 17420, 112, 112, 97, 59, 17306, 256, 101, 121, 2038, 2043, 100, 105, 108, 59, 16694, 59, 17434, 114, 59, 49152, 55349, 56590, 112, 102, 59, 49152, 55349, 56642, 99, 114, 59, 49152, 55349, 56486, 1408, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2085, 2089, 2092, 2128, 2147, 2483, 2488, 2503, 2509, 2615, 2631, 99, 121, 59, 17417, 32827, 60, 16444, 640, 99, 109, 110, 112, 114, 2103, 2108, 2113, 2116, 2125, 117, 116, 101, 59, 16697, 98, 100, 97, 59, 17307, 103, 59, 26602, 108, 97, 99, 101, 116, 114, 102, 59, 24850, 114, 59, 24990, 384, 97, 101, 121, 2135, 2140, 2145, 114, 111, 110, 59, 16701, 100, 105, 108, 59, 16699, 59, 17435, 256, 102, 115, 2152, 2416, 116, 1280, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2174, 2217, 2225, 2272, 2278, 2300, 2351, 2395, 912, 2410, 256, 110, 114, 2179, 2191, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26600, 114, 111, 119, 384, 59, 66, 82, 2201, 2202, 2206, 24976, 97, 114, 59, 25060, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 25030, 101, 105, 108, 105, 110, 103, 59, 25352, 111, 501, 2231, 0, 2243, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26598, 110, 468, 2248, 0, 2258, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26977, 101, 99, 116, 111, 114, 256, 59, 66, 2267, 2268, 25027, 97, 114, 59, 26969, 108, 111, 111, 114, 59, 25354, 105, 103, 104, 116, 256, 65, 86, 2287, 2293, 114, 114, 111, 119, 59, 24980, 101, 99, 116, 111, 114, 59, 26958, 256, 101, 114, 2305, 2327, 101, 384, 59, 65, 86, 2313, 2314, 2320, 25251, 114, 114, 111, 119, 59, 24996, 101, 99, 116, 111, 114, 59, 26970, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 2340, 2341, 2345, 25266, 97, 114, 59, 27087, 113, 117, 97, 108, 59, 25268, 112, 384, 68, 84, 86, 2359, 2370, 2380, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 26961, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26976, 101, 99, 116, 111, 114, 256, 59, 66, 2390, 2391, 25023, 97, 114, 59, 26968, 101, 99, 116, 111, 114, 256, 59, 66, 2405, 2406, 25020, 97, 114, 59, 26962, 105, 103, 104, 116, 225, 924, 115, 768, 69, 70, 71, 76, 83, 84, 2430, 2443, 2453, 2461, 2466, 2477, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 25306, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25190, 114, 101, 97, 116, 101, 114, 59, 25206, 101, 115, 115, 59, 27297, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 27261, 105, 108, 100, 101, 59, 25202, 114, 59, 49152, 55349, 56591, 256, 59, 101, 2493, 2494, 25304, 102, 116, 97, 114, 114, 111, 119, 59, 25050, 105, 100, 111, 116, 59, 16703, 384, 110, 112, 119, 2516, 2582, 2587, 103, 512, 76, 82, 108, 114, 2526, 2551, 2562, 2576, 101, 102, 116, 256, 65, 82, 2534, 2540, 114, 114, 111, 119, 59, 26613, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26615, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 26614, 101, 102, 116, 256, 97, 114, 947, 2570, 105, 103, 104, 116, 225, 959, 105, 103, 104, 116, 225, 970, 102, 59, 49152, 55349, 56643, 101, 114, 256, 76, 82, 2594, 2604, 101, 102, 116, 65, 114, 114, 111, 119, 59, 24985, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 24984, 384, 99, 104, 116, 2622, 2624, 2626, 242, 2124, 59, 25008, 114, 111, 107, 59, 16705, 59, 25194, 1024, 97, 99, 101, 102, 105, 111, 115, 117, 2650, 2653, 2656, 2679, 2684, 2693, 2699, 2702, 112, 59, 26885, 121, 59, 17436, 256, 100, 108, 2661, 2671, 105, 117, 109, 83, 112, 97, 99, 101, 59, 24671, 108, 105, 110, 116, 114, 102, 59, 24883, 114, 59, 49152, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 25107, 112, 102, 59, 49152, 55349, 56644, 99, 242, 2678, 59, 17308, 1152, 74, 97, 99, 101, 102, 111, 115, 116, 117, 2723, 2727, 2733, 2752, 2836, 2841, 3473, 3479, 3486, 99, 121, 59, 17418, 99, 117, 116, 101, 59, 16707, 384, 97, 101, 121, 2740, 2745, 2750, 114, 111, 110, 59, 16711, 100, 105, 108, 59, 16709, 59, 17437, 384, 103, 115, 119, 2759, 2800, 2830, 97, 116, 105, 118, 101, 384, 77, 84, 86, 2771, 2783, 2792, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 24587, 104, 105, 256, 99, 110, 2790, 2776, 235, 2777, 101, 114, 121, 84, 104, 105, 238, 2777, 116, 101, 100, 256, 71, 76, 2808, 2822, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 242, 1651, 101, 115, 115, 76, 101, 115, 243, 2632, 76, 105, 110, 101, 59, 16394, 114, 59, 49152, 55349, 56593, 512, 66, 110, 112, 116, 2850, 2856, 2871, 2874, 114, 101, 97, 107, 59, 24672, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 16544, 102, 59, 24853, 1664, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 2901, 2902, 2922, 2940, 2977, 3051, 3076, 3166, 3204, 3238, 3288, 3425, 3461, 27372, 256, 111, 117, 2907, 2916, 110, 103, 114, 117, 101, 110, 116, 59, 25186, 112, 67, 97, 112, 59, 25197, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25126, 384, 108, 113, 120, 2947, 2954, 2971, 101, 109, 101, 110, 116, 59, 25097, 117, 97, 108, 256, 59, 84, 2962, 2963, 25184, 105, 108, 100, 101, 59, 49152, 8770, 824, 105, 115, 116, 115, 59, 25092, 114, 101, 97, 116, 101, 114, 896, 59, 69, 70, 71, 76, 83, 84, 2998, 2999, 3005, 3017, 3027, 3032, 3045, 25199, 113, 117, 97, 108, 59, 25201, 117, 108, 108, 69, 113, 117, 97, 108, 59, 49152, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 49152, 8811, 824, 101, 115, 115, 59, 25209, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 49152, 10878, 824, 105, 108, 100, 101, 59, 25205, 117, 109, 112, 324, 3058, 3069, 111, 119, 110, 72, 117, 109, 112, 59, 49152, 8782, 824, 113, 117, 97, 108, 59, 49152, 8783, 824, 101, 256, 102, 115, 3082, 3111, 116, 84, 114, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 3098, 3099, 3105, 25322, 97, 114, 59, 49152, 10703, 824, 113, 117, 97, 108, 59, 25324, 115, 768, 59, 69, 71, 76, 83, 84, 3125, 3126, 3132, 3140, 3147, 3160, 25198, 113, 117, 97, 108, 59, 25200, 114, 101, 97, 116, 101, 114, 59, 25208, 101, 115, 115, 59, 49152, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 49152, 10877, 824, 105, 108, 100, 101, 59, 25204, 101, 115, 116, 101, 100, 256, 71, 76, 3176, 3193, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 49152, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 49152, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 384, 59, 69, 83, 3218, 3219, 3227, 25216, 113, 117, 97, 108, 59, 49152, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25312, 256, 101, 105, 3243, 3257, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 25100, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 3275, 3276, 3282, 25323, 97, 114, 59, 49152, 10704, 824, 113, 117, 97, 108, 59, 25325, 256, 113, 117, 3293, 3340, 117, 97, 114, 101, 83, 117, 256, 98, 112, 3304, 3321, 115, 101, 116, 256, 59, 69, 3312, 3315, 49152, 8847, 824, 113, 117, 97, 108, 59, 25314, 101, 114, 115, 101, 116, 256, 59, 69, 3331, 3334, 49152, 8848, 824, 113, 117, 97, 108, 59, 25315, 384, 98, 99, 112, 3347, 3364, 3406, 115, 101, 116, 256, 59, 69, 3355, 3358, 49152, 8834, 8402, 113, 117, 97, 108, 59, 25224, 99, 101, 101, 100, 115, 512, 59, 69, 83, 84, 3378, 3379, 3387, 3398, 25217, 113, 117, 97, 108, 59, 49152, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25313, 105, 108, 100, 101, 59, 49152, 8831, 824, 101, 114, 115, 101, 116, 256, 59, 69, 3416, 3419, 49152, 8835, 8402, 113, 117, 97, 108, 59, 25225, 105, 108, 100, 101, 512, 59, 69, 70, 84, 3438, 3439, 3445, 3455, 25153, 113, 117, 97, 108, 59, 25156, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25159, 105, 108, 100, 101, 59, 25161, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 25124, 99, 114, 59, 49152, 55349, 56489, 105, 108, 100, 101, 32827, 209, 16593, 59, 17309, 1792, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 3517, 3522, 3529, 3541, 3547, 3552, 3559, 3580, 3586, 3616, 3618, 3634, 3647, 3652, 108, 105, 103, 59, 16722, 99, 117, 116, 101, 32827, 211, 16595, 256, 105, 121, 3534, 3539, 114, 99, 32827, 212, 16596, 59, 17438, 98, 108, 97, 99, 59, 16720, 114, 59, 49152, 55349, 56594, 114, 97, 118, 101, 32827, 210, 16594, 384, 97, 101, 105, 3566, 3570, 3574, 99, 114, 59, 16716, 103, 97, 59, 17321, 99, 114, 111, 110, 59, 17311, 112, 102, 59, 49152, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 256, 68, 81, 3598, 3610, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 24604, 117, 111, 116, 101, 59, 24600, 59, 27220, 256, 99, 108, 3623, 3628, 114, 59, 49152, 55349, 56490, 97, 115, 104, 32827, 216, 16600, 105, 364, 3639, 3644, 100, 101, 32827, 213, 16597, 101, 115, 59, 27191, 109, 108, 32827, 214, 16598, 101, 114, 256, 66, 80, 3659, 3680, 256, 97, 114, 3664, 3667, 114, 59, 24638, 97, 99, 256, 101, 107, 3674, 3676, 59, 25566, 101, 116, 59, 25524, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 25564, 1152, 97, 99, 102, 104, 105, 108, 111, 114, 115, 3711, 3719, 3722, 3727, 3730, 3732, 3741, 3760, 3836, 114, 116, 105, 97, 108, 68, 59, 25090, 121, 59, 17439, 114, 59, 49152, 55349, 56595, 105, 59, 17318, 59, 17312, 117, 115, 77, 105, 110, 117, 115, 59, 16561, 256, 105, 112, 3746, 3757, 110, 99, 97, 114, 101, 112, 108, 97, 110, 229, 1693, 102, 59, 24857, 512, 59, 101, 105, 111, 3769, 3770, 3808, 3812, 27323, 99, 101, 100, 101, 115, 512, 59, 69, 83, 84, 3784, 3785, 3791, 3802, 25210, 113, 117, 97, 108, 59, 27311, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25212, 105, 108, 100, 101, 59, 25214, 109, 101, 59, 24627, 256, 100, 112, 3817, 3822, 117, 99, 116, 59, 25103, 111, 114, 116, 105, 111, 110, 256, 59, 97, 549, 3833, 108, 59, 25117, 256, 99, 105, 3841, 3846, 114, 59, 49152, 55349, 56491, 59, 17320, 512, 85, 102, 111, 115, 3857, 3862, 3867, 3871, 79, 84, 32827, 34, 16418, 114, 59, 49152, 55349, 56596, 112, 102, 59, 24858, 99, 114, 59, 49152, 55349, 56492, 1536, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 3902, 3907, 3911, 3936, 3955, 4007, 4010, 4013, 4246, 4265, 4276, 4286, 97, 114, 114, 59, 26896, 71, 32827, 174, 16558, 384, 99, 110, 114, 3918, 3923, 3926, 117, 116, 101, 59, 16724, 103, 59, 26603, 114, 256, 59, 116, 3932, 3933, 24992, 108, 59, 26902, 384, 97, 101, 121, 3943, 3948, 3953, 114, 111, 110, 59, 16728, 100, 105, 108, 59, 16726, 59, 17440, 256, 59, 118, 3960, 3961, 24860, 101, 114, 115, 101, 256, 69, 85, 3970, 3993, 256, 108, 113, 3975, 3982, 101, 109, 101, 110, 116, 59, 25099, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 25035, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 26991, 114, 187, 3961, 111, 59, 17313, 103, 104, 116, 1024, 65, 67, 68, 70, 84, 85, 86, 97, 4033, 4075, 4083, 4130, 4136, 4187, 4231, 984, 256, 110, 114, 4038, 4050, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26601, 114, 111, 119, 384, 59, 66, 76, 4060, 4061, 4065, 24978, 97, 114, 59, 25061, 101, 102, 116, 65, 114, 114, 111, 119, 59, 25028, 101, 105, 108, 105, 110, 103, 59, 25353, 111, 501, 4089, 0, 4101, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 26599, 110, 468, 4106, 0, 4116, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26973, 101, 99, 116, 111, 114, 256, 59, 66, 4125, 4126, 25026, 97, 114, 59, 26965, 108, 111, 111, 114, 59, 25355, 256, 101, 114, 4141, 4163, 101, 384, 59, 65, 86, 4149, 4150, 4156, 25250, 114, 114, 111, 119, 59, 24998, 101, 99, 116, 111, 114, 59, 26971, 105, 97, 110, 103, 108, 101, 384, 59, 66, 69, 4176, 4177, 4181, 25267, 97, 114, 59, 27088, 113, 117, 97, 108, 59, 25269, 112, 384, 68, 84, 86, 4195, 4206, 4216, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 26959, 101, 101, 86, 101, 99, 116, 111, 114, 59, 26972, 101, 99, 116, 111, 114, 256, 59, 66, 4226, 4227, 25022, 97, 114, 59, 26964, 101, 99, 116, 111, 114, 256, 59, 66, 4241, 4242, 25024, 97, 114, 59, 26963, 256, 112, 117, 4251, 4254, 102, 59, 24861, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 26992, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25051, 256, 99, 104, 4281, 4284, 114, 59, 24859, 59, 25009, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 27124, 1664, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 4324, 4337, 4343, 4349, 4377, 4382, 4433, 4438, 4449, 4455, 4533, 4539, 4543, 256, 67, 99, 4329, 4334, 72, 99, 121, 59, 17449, 121, 59, 17448, 70, 84, 99, 121, 59, 17452, 99, 117, 116, 101, 59, 16730, 640, 59, 97, 101, 105, 121, 4360, 4361, 4366, 4371, 4375, 27324, 114, 111, 110, 59, 16736, 100, 105, 108, 59, 16734, 114, 99, 59, 16732, 59, 17441, 114, 59, 49152, 55349, 56598, 111, 114, 116, 512, 68, 76, 82, 85, 4394, 4404, 4414, 4425, 111, 119, 110, 65, 114, 114, 111, 119, 187, 1054, 101, 102, 116, 65, 114, 114, 111, 119, 187, 2202, 105, 103, 104, 116, 65, 114, 114, 111, 119, 187, 4061, 112, 65, 114, 114, 111, 119, 59, 24977, 103, 109, 97, 59, 17315, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 25112, 112, 102, 59, 49152, 55349, 56650, 626, 4461, 0, 0, 4464, 116, 59, 25114, 97, 114, 101, 512, 59, 73, 83, 85, 4475, 4476, 4489, 4527, 26017, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 25235, 117, 256, 98, 112, 4495, 4510, 115, 101, 116, 256, 59, 69, 4503, 4504, 25231, 113, 117, 97, 108, 59, 25233, 101, 114, 115, 101, 116, 256, 59, 69, 4520, 4521, 25232, 113, 117, 97, 108, 59, 25234, 110, 105, 111, 110, 59, 25236, 99, 114, 59, 49152, 55349, 56494, 97, 114, 59, 25286, 512, 98, 99, 109, 112, 4552, 4571, 4617, 4619, 256, 59, 115, 4557, 4558, 25296, 101, 116, 256, 59, 69, 4557, 4565, 113, 117, 97, 108, 59, 25222, 256, 99, 104, 4576, 4613, 101, 101, 100, 115, 512, 59, 69, 83, 84, 4589, 4590, 4596, 4607, 25211, 113, 117, 97, 108, 59, 27312, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 25213, 105, 108, 100, 101, 59, 25215, 84, 104, 225, 3980, 59, 25105, 384, 59, 101, 115, 4626, 4627, 4643, 25297, 114, 115, 101, 116, 256, 59, 69, 4636, 4637, 25219, 113, 117, 97, 108, 59, 25223, 101, 116, 187, 4627, 1408, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 4670, 4676, 4681, 4693, 4702, 4721, 4726, 4767, 4802, 4808, 4817, 79, 82, 78, 32827, 222, 16606, 65, 68, 69, 59, 24866, 256, 72, 99, 4686, 4690, 99, 121, 59, 17419, 121, 59, 17446, 256, 98, 117, 4698, 4700, 59, 16393, 59, 17316, 384, 97, 101, 121, 4709, 4714, 4719, 114, 111, 110, 59, 16740, 100, 105, 108, 59, 16738, 59, 17442, 114, 59, 49152, 55349, 56599, 256, 101, 105, 4731, 4745, 498, 4736, 0, 4743, 101, 102, 111, 114, 101, 59, 25140, 97, 59, 17304, 256, 99, 110, 4750, 4760, 107, 83, 112, 97, 99, 101, 59, 49152, 8287, 8202, 83, 112, 97, 99, 101, 59, 24585, 108, 100, 101, 512, 59, 69, 70, 84, 4779, 4780, 4786, 4796, 25148, 113, 117, 97, 108, 59, 25155, 117, 108, 108, 69, 113, 117, 97, 108, 59, 25157, 105, 108, 100, 101, 59, 25160, 112, 102, 59, 49152, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 24795, 256, 99, 116, 4822, 4827, 114, 59, 49152, 55349, 56495, 114, 111, 107, 59, 16742, 2785, 4855, 4878, 4890, 4902, 0, 4908, 4913, 0, 0, 0, 0, 0, 4920, 4925, 4983, 4997, 0, 5119, 5124, 5130, 5136, 256, 99, 114, 4859, 4865, 117, 116, 101, 32827, 218, 16602, 114, 256, 59, 111, 4871, 4872, 24991, 99, 105, 114, 59, 26953, 114, 483, 4883, 0, 4886, 121, 59, 17422, 118, 101, 59, 16748, 256, 105, 121, 4894, 4899, 114, 99, 32827, 219, 16603, 59, 17443, 98, 108, 97, 99, 59, 16752, 114, 59, 49152, 55349, 56600, 114, 97, 118, 101, 32827, 217, 16601, 97, 99, 114, 59, 16746, 256, 100, 105, 4929, 4969, 101, 114, 256, 66, 80, 4936, 4957, 256, 97, 114, 4941, 4944, 114, 59, 16479, 97, 99, 256, 101, 107, 4951, 4953, 59, 25567, 101, 116, 59, 25525, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 25565, 111, 110, 256, 59, 80, 4976, 4977, 25283, 108, 117, 115, 59, 25230, 256, 103, 112, 4987, 4991, 111, 110, 59, 16754, 102, 59, 49152, 55349, 56652, 1024, 65, 68, 69, 84, 97, 100, 112, 115, 5013, 5038, 5048, 5060, 1e3, 5074, 5079, 5107, 114, 114, 111, 119, 384, 59, 66, 68, 4432, 5024, 5028, 97, 114, 59, 26898, 111, 119, 110, 65, 114, 114, 111, 119, 59, 25029, 111, 119, 110, 65, 114, 114, 111, 119, 59, 24981, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 26990, 101, 101, 256, 59, 65, 5067, 5068, 25253, 114, 114, 111, 119, 59, 24997, 111, 119, 110, 225, 1011, 101, 114, 256, 76, 82, 5086, 5096, 101, 102, 116, 65, 114, 114, 111, 119, 59, 24982, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 24983, 105, 256, 59, 108, 5113, 5114, 17362, 111, 110, 59, 17317, 105, 110, 103, 59, 16750, 99, 114, 59, 49152, 55349, 56496, 105, 108, 100, 101, 59, 16744, 109, 108, 32827, 220, 16604, 1152, 68, 98, 99, 100, 101, 102, 111, 115, 118, 5159, 5164, 5168, 5171, 5182, 5253, 5258, 5264, 5270, 97, 115, 104, 59, 25259, 97, 114, 59, 27371, 121, 59, 17426, 97, 115, 104, 256, 59, 108, 5179, 5180, 25257, 59, 27366, 256, 101, 114, 5187, 5189, 59, 25281, 384, 98, 116, 121, 5196, 5200, 5242, 97, 114, 59, 24598, 256, 59, 105, 5199, 5205, 99, 97, 108, 512, 66, 76, 83, 84, 5217, 5221, 5226, 5236, 97, 114, 59, 25123, 105, 110, 101, 59, 16508, 101, 112, 97, 114, 97, 116, 111, 114, 59, 26456, 105, 108, 100, 101, 59, 25152, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 24586, 114, 59, 49152, 55349, 56601, 112, 102, 59, 49152, 55349, 56653, 99, 114, 59, 49152, 55349, 56497, 100, 97, 115, 104, 59, 25258, 640, 99, 101, 102, 111, 115, 5287, 5292, 5297, 5302, 5308, 105, 114, 99, 59, 16756, 100, 103, 101, 59, 25280, 114, 59, 49152, 55349, 56602, 112, 102, 59, 49152, 55349, 56654, 99, 114, 59, 49152, 55349, 56498, 512, 102, 105, 111, 115, 5323, 5328, 5330, 5336, 114, 59, 49152, 55349, 56603, 59, 17310, 112, 102, 59, 49152, 55349, 56655, 99, 114, 59, 49152, 55349, 56499, 1152, 65, 73, 85, 97, 99, 102, 111, 115, 117, 5361, 5365, 5369, 5373, 5380, 5391, 5396, 5402, 5408, 99, 121, 59, 17455, 99, 121, 59, 17415, 99, 121, 59, 17454, 99, 117, 116, 101, 32827, 221, 16605, 256, 105, 121, 5385, 5389, 114, 99, 59, 16758, 59, 17451, 114, 59, 49152, 55349, 56604, 112, 102, 59, 49152, 55349, 56656, 99, 114, 59, 49152, 55349, 56500, 109, 108, 59, 16760, 1024, 72, 97, 99, 100, 101, 102, 111, 115, 5429, 5433, 5439, 5451, 5455, 5469, 5472, 5476, 99, 121, 59, 17430, 99, 117, 116, 101, 59, 16761, 256, 97, 121, 5444, 5449, 114, 111, 110, 59, 16765, 59, 17431, 111, 116, 59, 16763, 498, 5460, 0, 5467, 111, 87, 105, 100, 116, 232, 2777, 97, 59, 17302, 114, 59, 24872, 112, 102, 59, 24868, 99, 114, 59, 49152, 55349, 56501, 3041, 5507, 5514, 5520, 0, 5552, 5558, 5567, 0, 0, 0, 0, 5574, 5595, 5611, 5727, 5741, 0, 5781, 5787, 5810, 5817, 0, 5822, 99, 117, 116, 101, 32827, 225, 16609, 114, 101, 118, 101, 59, 16643, 768, 59, 69, 100, 105, 117, 121, 5532, 5533, 5537, 5539, 5544, 5549, 25150, 59, 49152, 8766, 819, 59, 25151, 114, 99, 32827, 226, 16610, 116, 101, 32955, 180, 774, 59, 17456, 108, 105, 103, 32827, 230, 16614, 256, 59, 114, 178, 5562, 59, 49152, 55349, 56606, 114, 97, 118, 101, 32827, 224, 16608, 256, 101, 112, 5578, 5590, 256, 102, 112, 5583, 5588, 115, 121, 109, 59, 24885, 232, 5587, 104, 97, 59, 17329, 256, 97, 112, 5599, 99, 256, 99, 108, 5604, 5607, 114, 59, 16641, 103, 59, 27199, 612, 5616, 0, 0, 5642, 640, 59, 97, 100, 115, 118, 5626, 5627, 5631, 5633, 5639, 25127, 110, 100, 59, 27221, 59, 27228, 108, 111, 112, 101, 59, 27224, 59, 27226, 896, 59, 101, 108, 109, 114, 115, 122, 5656, 5657, 5659, 5662, 5695, 5711, 5721, 25120, 59, 27044, 101, 187, 5657, 115, 100, 256, 59, 97, 5669, 5670, 25121, 1121, 5680, 5682, 5684, 5686, 5688, 5690, 5692, 5694, 59, 27048, 59, 27049, 59, 27050, 59, 27051, 59, 27052, 59, 27053, 59, 27054, 59, 27055, 116, 256, 59, 118, 5701, 5702, 25119, 98, 256, 59, 100, 5708, 5709, 25278, 59, 27037, 256, 112, 116, 5716, 5719, 104, 59, 25122, 187, 185, 97, 114, 114, 59, 25468, 256, 103, 112, 5731, 5735, 111, 110, 59, 16645, 102, 59, 49152, 55349, 56658, 896, 59, 69, 97, 101, 105, 111, 112, 4801, 5755, 5757, 5762, 5764, 5767, 5770, 59, 27248, 99, 105, 114, 59, 27247, 59, 25162, 100, 59, 25163, 115, 59, 16423, 114, 111, 120, 256, 59, 101, 4801, 5778, 241, 5763, 105, 110, 103, 32827, 229, 16613, 384, 99, 116, 121, 5793, 5798, 5800, 114, 59, 49152, 55349, 56502, 59, 16426, 109, 112, 256, 59, 101, 4801, 5807, 241, 648, 105, 108, 100, 101, 32827, 227, 16611, 109, 108, 32827, 228, 16612, 256, 99, 105, 5826, 5832, 111, 110, 105, 110, 244, 626, 110, 116, 59, 27153, 2048, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 5869, 5873, 5936, 5948, 5955, 5960, 6008, 6013, 6112, 6118, 6201, 6224, 5901, 6461, 6472, 6512, 111, 116, 59, 27373, 256, 99, 114, 5878, 5918, 107, 512, 99, 101, 112, 115, 5888, 5893, 5901, 5907, 111, 110, 103, 59, 25164, 112, 115, 105, 108, 111, 110, 59, 17398, 114, 105, 109, 101, 59, 24629, 105, 109, 256, 59, 101, 5914, 5915, 25149, 113, 59, 25293, 374, 5922, 5926, 101, 101, 59, 25277, 101, 100, 256, 59, 103, 5932, 5933, 25349, 101, 187, 5933, 114, 107, 256, 59, 116, 4956, 5943, 98, 114, 107, 59, 25526, 256, 111, 121, 5889, 5953, 59, 17457, 113, 117, 111, 59, 24606, 640, 99, 109, 112, 114, 116, 5971, 5979, 5985, 5988, 5992, 97, 117, 115, 256, 59, 101, 266, 265, 112, 116, 121, 118, 59, 27056, 115, 233, 5900, 110, 111, 245, 275, 384, 97, 104, 119, 5999, 6001, 6003, 59, 17330, 59, 24886, 101, 101, 110, 59, 25196, 114, 59, 49152, 55349, 56607, 103, 896, 99, 111, 115, 116, 117, 118, 119, 6029, 6045, 6067, 6081, 6101, 6107, 6110, 384, 97, 105, 117, 6036, 6038, 6042, 240, 1888, 114, 99, 59, 26095, 112, 187, 4977, 384, 100, 112, 116, 6052, 6056, 6061, 111, 116, 59, 27136, 108, 117, 115, 59, 27137, 105, 109, 101, 115, 59, 27138, 625, 6073, 0, 0, 6078, 99, 117, 112, 59, 27142, 97, 114, 59, 26117, 114, 105, 97, 110, 103, 108, 101, 256, 100, 117, 6093, 6098, 111, 119, 110, 59, 26045, 112, 59, 26035, 112, 108, 117, 115, 59, 27140, 101, 229, 5188, 229, 5293, 97, 114, 111, 119, 59, 26893, 384, 97, 107, 111, 6125, 6182, 6197, 256, 99, 110, 6130, 6179, 107, 384, 108, 115, 116, 6138, 1451, 6146, 111, 122, 101, 110, 103, 101, 59, 27115, 114, 105, 97, 110, 103, 108, 101, 512, 59, 100, 108, 114, 6162, 6163, 6168, 6173, 26036, 111, 119, 110, 59, 26046, 101, 102, 116, 59, 26050, 105, 103, 104, 116, 59, 26040, 107, 59, 25635, 433, 6187, 0, 6195, 434, 6191, 0, 6193, 59, 26002, 59, 26001, 52, 59, 26003, 99, 107, 59, 25992, 256, 101, 111, 6206, 6221, 256, 59, 113, 6211, 6214, 49152, 61, 8421, 117, 105, 118, 59, 49152, 8801, 8421, 116, 59, 25360, 512, 112, 116, 119, 120, 6233, 6238, 6247, 6252, 102, 59, 49152, 55349, 56659, 256, 59, 116, 5067, 6243, 111, 109, 187, 5068, 116, 105, 101, 59, 25288, 1536, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 6277, 6294, 6314, 6331, 6359, 6363, 6380, 6399, 6405, 6410, 6416, 6433, 512, 76, 82, 108, 114, 6286, 6288, 6290, 6292, 59, 25943, 59, 25940, 59, 25942, 59, 25939, 640, 59, 68, 85, 100, 117, 6305, 6306, 6308, 6310, 6312, 25936, 59, 25958, 59, 25961, 59, 25956, 59, 25959, 512, 76, 82, 108, 114, 6323, 6325, 6327, 6329, 59, 25949, 59, 25946, 59, 25948, 59, 25945, 896, 59, 72, 76, 82, 104, 108, 114, 6346, 6347, 6349, 6351, 6353, 6355, 6357, 25937, 59, 25964, 59, 25955, 59, 25952, 59, 25963, 59, 25954, 59, 25951, 111, 120, 59, 27081, 512, 76, 82, 108, 114, 6372, 6374, 6376, 6378, 59, 25941, 59, 25938, 59, 25872, 59, 25868, 640, 59, 68, 85, 100, 117, 1725, 6391, 6393, 6395, 6397, 59, 25957, 59, 25960, 59, 25900, 59, 25908, 105, 110, 117, 115, 59, 25247, 108, 117, 115, 59, 25246, 105, 109, 101, 115, 59, 25248, 512, 76, 82, 108, 114, 6425, 6427, 6429, 6431, 59, 25947, 59, 25944, 59, 25880, 59, 25876, 896, 59, 72, 76, 82, 104, 108, 114, 6448, 6449, 6451, 6453, 6455, 6457, 6459, 25858, 59, 25962, 59, 25953, 59, 25950, 59, 25916, 59, 25892, 59, 25884, 256, 101, 118, 291, 6466, 98, 97, 114, 32827, 166, 16550, 512, 99, 101, 105, 111, 6481, 6486, 6490, 6496, 114, 59, 49152, 55349, 56503, 109, 105, 59, 24655, 109, 256, 59, 101, 5914, 5916, 108, 384, 59, 98, 104, 6504, 6505, 6507, 16476, 59, 27077, 115, 117, 98, 59, 26568, 364, 6516, 6526, 108, 256, 59, 101, 6521, 6522, 24610, 116, 187, 6522, 112, 384, 59, 69, 101, 303, 6533, 6535, 59, 27310, 256, 59, 113, 1756, 1755, 3297, 6567, 0, 6632, 6673, 6677, 6706, 0, 6711, 6736, 0, 0, 6836, 0, 0, 6849, 0, 0, 6945, 6958, 6989, 6994, 0, 7165, 0, 7180, 384, 99, 112, 114, 6573, 6578, 6621, 117, 116, 101, 59, 16647, 768, 59, 97, 98, 99, 100, 115, 6591, 6592, 6596, 6602, 6613, 6617, 25129, 110, 100, 59, 27204, 114, 99, 117, 112, 59, 27209, 256, 97, 117, 6607, 6610, 112, 59, 27211, 112, 59, 27207, 111, 116, 59, 27200, 59, 49152, 8745, 65024, 256, 101, 111, 6626, 6629, 116, 59, 24641, 238, 1683, 512, 97, 101, 105, 117, 6640, 6651, 6657, 6661, 496, 6645, 0, 6648, 115, 59, 27213, 111, 110, 59, 16653, 100, 105, 108, 32827, 231, 16615, 114, 99, 59, 16649, 112, 115, 256, 59, 115, 6668, 6669, 27212, 109, 59, 27216, 111, 116, 59, 16651, 384, 100, 109, 110, 6683, 6688, 6694, 105, 108, 32955, 184, 429, 112, 116, 121, 118, 59, 27058, 116, 33024, 162, 59, 101, 6701, 6702, 16546, 114, 228, 434, 114, 59, 49152, 55349, 56608, 384, 99, 101, 105, 6717, 6720, 6733, 121, 59, 17479, 99, 107, 256, 59, 109, 6727, 6728, 26387, 97, 114, 107, 187, 6728, 59, 17351, 114, 896, 59, 69, 99, 101, 102, 109, 115, 6751, 6752, 6754, 6763, 6820, 6826, 6830, 26059, 59, 27075, 384, 59, 101, 108, 6761, 6762, 6765, 17094, 113, 59, 25175, 101, 609, 6772, 0, 0, 6792, 114, 114, 111, 119, 256, 108, 114, 6780, 6785, 101, 102, 116, 59, 25018, 105, 103, 104, 116, 59, 25019, 640, 82, 83, 97, 99, 100, 6802, 6804, 6806, 6810, 6815, 187, 3911, 59, 25800, 115, 116, 59, 25243, 105, 114, 99, 59, 25242, 97, 115, 104, 59, 25245, 110, 105, 110, 116, 59, 27152, 105, 100, 59, 27375, 99, 105, 114, 59, 27074, 117, 98, 115, 256, 59, 117, 6843, 6844, 26211, 105, 116, 187, 6844, 748, 6855, 6868, 6906, 0, 6922, 111, 110, 256, 59, 101, 6861, 6862, 16442, 256, 59, 113, 199, 198, 621, 6873, 0, 0, 6882, 97, 256, 59, 116, 6878, 6879, 16428, 59, 16448, 384, 59, 102, 108, 6888, 6889, 6891, 25089, 238, 4448, 101, 256, 109, 120, 6897, 6902, 101, 110, 116, 187, 6889, 101, 243, 589, 487, 6910, 0, 6919, 256, 59, 100, 4795, 6914, 111, 116, 59, 27245, 110, 244, 582, 384, 102, 114, 121, 6928, 6932, 6935, 59, 49152, 55349, 56660, 111, 228, 596, 33024, 169, 59, 115, 341, 6941, 114, 59, 24855, 256, 97, 111, 6949, 6953, 114, 114, 59, 25013, 115, 115, 59, 26391, 256, 99, 117, 6962, 6967, 114, 59, 49152, 55349, 56504, 256, 98, 112, 6972, 6980, 256, 59, 101, 6977, 6978, 27343, 59, 27345, 256, 59, 101, 6985, 6986, 27344, 59, 27346, 100, 111, 116, 59, 25327, 896, 100, 101, 108, 112, 114, 118, 119, 7008, 7020, 7031, 7042, 7084, 7124, 7161, 97, 114, 114, 256, 108, 114, 7016, 7018, 59, 26936, 59, 26933, 624, 7026, 0, 0, 7029, 114, 59, 25310, 99, 59, 25311, 97, 114, 114, 256, 59, 112, 7039, 7040, 25014, 59, 26941, 768, 59, 98, 99, 100, 111, 115, 7055, 7056, 7062, 7073, 7077, 7080, 25130, 114, 99, 97, 112, 59, 27208, 256, 97, 117, 7067, 7070, 112, 59, 27206, 112, 59, 27210, 111, 116, 59, 25229, 114, 59, 27205, 59, 49152, 8746, 65024, 512, 97, 108, 114, 118, 7093, 7103, 7134, 7139, 114, 114, 256, 59, 109, 7100, 7101, 25015, 59, 26940, 121, 384, 101, 118, 119, 7111, 7124, 7128, 113, 624, 7118, 0, 0, 7122, 114, 101, 227, 7027, 117, 227, 7029, 101, 101, 59, 25294, 101, 100, 103, 101, 59, 25295, 101, 110, 32827, 164, 16548, 101, 97, 114, 114, 111, 119, 256, 108, 114, 7150, 7155, 101, 102, 116, 187, 7040, 105, 103, 104, 116, 187, 7101, 101, 228, 7133, 256, 99, 105, 7169, 7175, 111, 110, 105, 110, 244, 503, 110, 116, 59, 25137, 108, 99, 116, 121, 59, 25389, 2432, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 7224, 7227, 7231, 7261, 7273, 7285, 7306, 7326, 7340, 7351, 7419, 7423, 7437, 7547, 7569, 7595, 7611, 7622, 7629, 114, 242, 897, 97, 114, 59, 26981, 512, 103, 108, 114, 115, 7240, 7245, 7250, 7252, 103, 101, 114, 59, 24608, 101, 116, 104, 59, 24888, 242, 4403, 104, 256, 59, 118, 7258, 7259, 24592, 187, 2314, 363, 7265, 7271, 97, 114, 111, 119, 59, 26895, 97, 227, 789, 256, 97, 121, 7278, 7283, 114, 111, 110, 59, 16655, 59, 17460, 384, 59, 97, 111, 818, 7292, 7300, 256, 103, 114, 703, 7297, 114, 59, 25034, 116, 115, 101, 113, 59, 27255, 384, 103, 108, 109, 7313, 7316, 7320, 32827, 176, 16560, 116, 97, 59, 17332, 112, 116, 121, 118, 59, 27057, 256, 105, 114, 7331, 7336, 115, 104, 116, 59, 27007, 59, 49152, 55349, 56609, 97, 114, 256, 108, 114, 7347, 7349, 187, 2268, 187, 4126, 640, 97, 101, 103, 115, 118, 7362, 888, 7382, 7388, 7392, 109, 384, 59, 111, 115, 806, 7370, 7380, 110, 100, 256, 59, 115, 806, 7377, 117, 105, 116, 59, 26214, 97, 109, 109, 97, 59, 17373, 105, 110, 59, 25330, 384, 59, 105, 111, 7399, 7400, 7416, 16631, 100, 101, 33024, 247, 59, 111, 7399, 7408, 110, 116, 105, 109, 101, 115, 59, 25287, 110, 248, 7415, 99, 121, 59, 17490, 99, 623, 7430, 0, 0, 7434, 114, 110, 59, 25374, 111, 112, 59, 25357, 640, 108, 112, 116, 117, 119, 7448, 7453, 7458, 7497, 7509, 108, 97, 114, 59, 16420, 102, 59, 49152, 55349, 56661, 640, 59, 101, 109, 112, 115, 779, 7469, 7479, 7485, 7490, 113, 256, 59, 100, 850, 7475, 111, 116, 59, 25169, 105, 110, 117, 115, 59, 25144, 108, 117, 115, 59, 25108, 113, 117, 97, 114, 101, 59, 25249, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 229, 250, 110, 384, 97, 100, 104, 4398, 7517, 7527, 111, 119, 110, 97, 114, 114, 111, 119, 243, 7299, 97, 114, 112, 111, 111, 110, 256, 108, 114, 7538, 7542, 101, 102, 244, 7348, 105, 103, 104, 244, 7350, 354, 7551, 7557, 107, 97, 114, 111, 247, 3906, 623, 7562, 0, 0, 7566, 114, 110, 59, 25375, 111, 112, 59, 25356, 384, 99, 111, 116, 7576, 7587, 7590, 256, 114, 121, 7581, 7585, 59, 49152, 55349, 56505, 59, 17493, 108, 59, 27126, 114, 111, 107, 59, 16657, 256, 100, 114, 7600, 7604, 111, 116, 59, 25329, 105, 256, 59, 102, 7610, 6166, 26047, 256, 97, 104, 7616, 7619, 114, 242, 1065, 97, 242, 4006, 97, 110, 103, 108, 101, 59, 27046, 256, 99, 105, 7634, 7637, 121, 59, 17503, 103, 114, 97, 114, 114, 59, 26623, 2304, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 7681, 7689, 7705, 7736, 1400, 7740, 7753, 7777, 7806, 7845, 7855, 7869, 7905, 7978, 7991, 8004, 8014, 8026, 256, 68, 111, 7686, 7476, 111, 244, 7305, 256, 99, 115, 7694, 7700, 117, 116, 101, 32827, 233, 16617, 116, 101, 114, 59, 27246, 512, 97, 105, 111, 121, 7714, 7719, 7729, 7734, 114, 111, 110, 59, 16667, 114, 256, 59, 99, 7725, 7726, 25174, 32827, 234, 16618, 108, 111, 110, 59, 25173, 59, 17485, 111, 116, 59, 16663, 256, 68, 114, 7745, 7749, 111, 116, 59, 25170, 59, 49152, 55349, 56610, 384, 59, 114, 115, 7760, 7761, 7767, 27290, 97, 118, 101, 32827, 232, 16616, 256, 59, 100, 7772, 7773, 27286, 111, 116, 59, 27288, 512, 59, 105, 108, 115, 7786, 7787, 7794, 7796, 27289, 110, 116, 101, 114, 115, 59, 25575, 59, 24851, 256, 59, 100, 7801, 7802, 27285, 111, 116, 59, 27287, 384, 97, 112, 115, 7813, 7817, 7831, 99, 114, 59, 16659, 116, 121, 384, 59, 115, 118, 7826, 7827, 7829, 25093, 101, 116, 187, 7827, 112, 256, 49, 59, 7837, 7844, 307, 7841, 7843, 59, 24580, 59, 24581, 24579, 256, 103, 115, 7850, 7852, 59, 16715, 112, 59, 24578, 256, 103, 112, 7860, 7864, 111, 110, 59, 16665, 102, 59, 49152, 55349, 56662, 384, 97, 108, 115, 7876, 7886, 7890, 114, 256, 59, 115, 7882, 7883, 25301, 108, 59, 27107, 117, 115, 59, 27249, 105, 384, 59, 108, 118, 7898, 7899, 7903, 17333, 111, 110, 187, 7899, 59, 17397, 512, 99, 115, 117, 118, 7914, 7923, 7947, 7971, 256, 105, 111, 7919, 7729, 114, 99, 187, 7726, 617, 7929, 0, 0, 7931, 237, 1352, 97, 110, 116, 256, 103, 108, 7938, 7942, 116, 114, 187, 7773, 101, 115, 115, 187, 7802, 384, 97, 101, 105, 7954, 7958, 7962, 108, 115, 59, 16445, 115, 116, 59, 25183, 118, 256, 59, 68, 565, 7968, 68, 59, 27256, 112, 97, 114, 115, 108, 59, 27109, 256, 68, 97, 7983, 7987, 111, 116, 59, 25171, 114, 114, 59, 26993, 384, 99, 100, 105, 7998, 8001, 7928, 114, 59, 24879, 111, 244, 850, 256, 97, 104, 8009, 8011, 59, 17335, 32827, 240, 16624, 256, 109, 114, 8019, 8023, 108, 32827, 235, 16619, 111, 59, 24748, 384, 99, 105, 112, 8033, 8036, 8039, 108, 59, 16417, 115, 244, 1390, 256, 101, 111, 8044, 8052, 99, 116, 97, 116, 105, 111, 238, 1369, 110, 101, 110, 116, 105, 97, 108, 229, 1401, 2529, 8082, 0, 8094, 0, 8097, 8103, 0, 0, 8134, 8140, 0, 8147, 0, 8166, 8170, 8192, 0, 8200, 8282, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 241, 7748, 121, 59, 17476, 109, 97, 108, 101, 59, 26176, 384, 105, 108, 114, 8109, 8115, 8129, 108, 105, 103, 59, 32768, 64259, 617, 8121, 0, 0, 8125, 103, 59, 32768, 64256, 105, 103, 59, 32768, 64260, 59, 49152, 55349, 56611, 108, 105, 103, 59, 32768, 64257, 108, 105, 103, 59, 49152, 102, 106, 384, 97, 108, 116, 8153, 8156, 8161, 116, 59, 26221, 105, 103, 59, 32768, 64258, 110, 115, 59, 26033, 111, 102, 59, 16786, 496, 8174, 0, 8179, 102, 59, 49152, 55349, 56663, 256, 97, 107, 1471, 8183, 256, 59, 118, 8188, 8189, 25300, 59, 27353, 97, 114, 116, 105, 110, 116, 59, 27149, 256, 97, 111, 8204, 8277, 256, 99, 115, 8209, 8274, 945, 8218, 8240, 8248, 8261, 8264, 0, 8272, 946, 8226, 8229, 8231, 8234, 8236, 0, 8238, 32827, 189, 16573, 59, 24915, 32827, 188, 16572, 59, 24917, 59, 24921, 59, 24923, 435, 8244, 0, 8246, 59, 24916, 59, 24918, 692, 8254, 8257, 0, 0, 8259, 32827, 190, 16574, 59, 24919, 59, 24924, 53, 59, 24920, 438, 8268, 0, 8270, 59, 24922, 59, 24925, 56, 59, 24926, 108, 59, 24644, 119, 110, 59, 25378, 99, 114, 59, 49152, 55349, 56507, 2176, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 8322, 8329, 8351, 8357, 8368, 8372, 8432, 8437, 8442, 8447, 8451, 8466, 8504, 791, 8510, 8530, 8606, 256, 59, 108, 1613, 8327, 59, 27276, 384, 99, 109, 112, 8336, 8341, 8349, 117, 116, 101, 59, 16885, 109, 97, 256, 59, 100, 8348, 7386, 17331, 59, 27270, 114, 101, 118, 101, 59, 16671, 256, 105, 121, 8362, 8366, 114, 99, 59, 16669, 59, 17459, 111, 116, 59, 16673, 512, 59, 108, 113, 115, 1598, 1602, 8381, 8393, 384, 59, 113, 115, 1598, 1612, 8388, 108, 97, 110, 244, 1637, 512, 59, 99, 100, 108, 1637, 8402, 8405, 8421, 99, 59, 27305, 111, 116, 256, 59, 111, 8412, 8413, 27264, 256, 59, 108, 8418, 8419, 27266, 59, 27268, 256, 59, 101, 8426, 8429, 49152, 8923, 65024, 115, 59, 27284, 114, 59, 49152, 55349, 56612, 256, 59, 103, 1651, 1563, 109, 101, 108, 59, 24887, 99, 121, 59, 17491, 512, 59, 69, 97, 106, 1626, 8460, 8462, 8464, 59, 27282, 59, 27301, 59, 27300, 512, 69, 97, 101, 115, 8475, 8477, 8489, 8500, 59, 25193, 112, 256, 59, 112, 8483, 8484, 27274, 114, 111, 120, 187, 8484, 256, 59, 113, 8494, 8495, 27272, 256, 59, 113, 8494, 8475, 105, 109, 59, 25319, 112, 102, 59, 49152, 55349, 56664, 256, 99, 105, 8515, 8518, 114, 59, 24842, 109, 384, 59, 101, 108, 1643, 8526, 8528, 59, 27278, 59, 27280, 33536, 62, 59, 99, 100, 108, 113, 114, 1518, 8544, 8554, 8558, 8563, 8569, 256, 99, 105, 8549, 8551, 59, 27303, 114, 59, 27258, 111, 116, 59, 25303, 80, 97, 114, 59, 27029, 117, 101, 115, 116, 59, 27260, 640, 97, 100, 101, 108, 115, 8580, 8554, 8592, 1622, 8603, 496, 8585, 0, 8590, 112, 114, 111, 248, 8350, 114, 59, 27e3, 113, 256, 108, 113, 1599, 8598, 108, 101, 115, 243, 8328, 105, 237, 1643, 256, 101, 110, 8611, 8621, 114, 116, 110, 101, 113, 113, 59, 49152, 8809, 65024, 197, 8618, 1280, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 8644, 8647, 8689, 8693, 8698, 8728, 8733, 8751, 8808, 8829, 114, 242, 928, 512, 105, 108, 109, 114, 8656, 8660, 8663, 8667, 114, 115, 240, 5252, 102, 187, 8228, 105, 108, 244, 1705, 256, 100, 114, 8672, 8676, 99, 121, 59, 17482, 384, 59, 99, 119, 2292, 8683, 8687, 105, 114, 59, 26952, 59, 25005, 97, 114, 59, 24847, 105, 114, 99, 59, 16677, 384, 97, 108, 114, 8705, 8718, 8723, 114, 116, 115, 256, 59, 117, 8713, 8714, 26213, 105, 116, 187, 8714, 108, 105, 112, 59, 24614, 99, 111, 110, 59, 25273, 114, 59, 49152, 55349, 56613, 115, 256, 101, 119, 8739, 8745, 97, 114, 111, 119, 59, 26917, 97, 114, 111, 119, 59, 26918, 640, 97, 109, 111, 112, 114, 8762, 8766, 8771, 8798, 8803, 114, 114, 59, 25087, 116, 104, 116, 59, 25147, 107, 256, 108, 114, 8777, 8787, 101, 102, 116, 97, 114, 114, 111, 119, 59, 25001, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25002, 102, 59, 49152, 55349, 56665, 98, 97, 114, 59, 24597, 384, 99, 108, 116, 8815, 8820, 8824, 114, 59, 49152, 55349, 56509, 97, 115, 232, 8692, 114, 111, 107, 59, 16679, 256, 98, 112, 8834, 8839, 117, 108, 108, 59, 24643, 104, 101, 110, 187, 7259, 2785, 8867, 0, 8874, 0, 8888, 8901, 8910, 0, 8917, 8947, 0, 0, 8952, 8994, 9063, 9058, 9087, 0, 9094, 9130, 9140, 99, 117, 116, 101, 32827, 237, 16621, 384, 59, 105, 121, 1905, 8880, 8885, 114, 99, 32827, 238, 16622, 59, 17464, 256, 99, 120, 8892, 8895, 121, 59, 17461, 99, 108, 32827, 161, 16545, 256, 102, 114, 927, 8905, 59, 49152, 55349, 56614, 114, 97, 118, 101, 32827, 236, 16620, 512, 59, 105, 110, 111, 1854, 8925, 8937, 8942, 256, 105, 110, 8930, 8934, 110, 116, 59, 27148, 116, 59, 25133, 102, 105, 110, 59, 27100, 116, 97, 59, 24873, 108, 105, 103, 59, 16691, 384, 97, 111, 112, 8958, 8986, 8989, 384, 99, 103, 116, 8965, 8968, 8983, 114, 59, 16683, 384, 101, 108, 112, 1823, 8975, 8979, 105, 110, 229, 1934, 97, 114, 244, 1824, 104, 59, 16689, 102, 59, 25271, 101, 100, 59, 16821, 640, 59, 99, 102, 111, 116, 1268, 9004, 9009, 9021, 9025, 97, 114, 101, 59, 24837, 105, 110, 256, 59, 116, 9016, 9017, 25118, 105, 101, 59, 27101, 100, 111, 244, 8985, 640, 59, 99, 101, 108, 112, 1879, 9036, 9040, 9051, 9057, 97, 108, 59, 25274, 256, 103, 114, 9045, 9049, 101, 114, 243, 5475, 227, 9037, 97, 114, 104, 107, 59, 27159, 114, 111, 100, 59, 27196, 512, 99, 103, 112, 116, 9071, 9074, 9078, 9083, 121, 59, 17489, 111, 110, 59, 16687, 102, 59, 49152, 55349, 56666, 97, 59, 17337, 117, 101, 115, 116, 32827, 191, 16575, 256, 99, 105, 9098, 9103, 114, 59, 49152, 55349, 56510, 110, 640, 59, 69, 100, 115, 118, 1268, 9115, 9117, 9121, 1267, 59, 25337, 111, 116, 59, 25333, 256, 59, 118, 9126, 9127, 25332, 59, 25331, 256, 59, 105, 1911, 9134, 108, 100, 101, 59, 16681, 491, 9144, 0, 9148, 99, 121, 59, 17494, 108, 32827, 239, 16623, 768, 99, 102, 109, 111, 115, 117, 9164, 9175, 9180, 9185, 9191, 9205, 256, 105, 121, 9169, 9173, 114, 99, 59, 16693, 59, 17465, 114, 59, 49152, 55349, 56615, 97, 116, 104, 59, 16951, 112, 102, 59, 49152, 55349, 56667, 483, 9196, 0, 9201, 114, 59, 49152, 55349, 56511, 114, 99, 121, 59, 17496, 107, 99, 121, 59, 17492, 1024, 97, 99, 102, 103, 104, 106, 111, 115, 9227, 9238, 9250, 9255, 9261, 9265, 9269, 9275, 112, 112, 97, 256, 59, 118, 9235, 9236, 17338, 59, 17392, 256, 101, 121, 9243, 9248, 100, 105, 108, 59, 16695, 59, 17466, 114, 59, 49152, 55349, 56616, 114, 101, 101, 110, 59, 16696, 99, 121, 59, 17477, 99, 121, 59, 17500, 112, 102, 59, 49152, 55349, 56668, 99, 114, 59, 49152, 55349, 56512, 2944, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 9328, 9345, 9350, 9357, 9361, 9486, 9533, 9562, 9600, 9806, 9822, 9829, 9849, 9853, 9882, 9906, 9944, 10077, 10088, 10123, 10176, 10241, 10258, 384, 97, 114, 116, 9335, 9338, 9340, 114, 242, 2502, 242, 917, 97, 105, 108, 59, 26907, 97, 114, 114, 59, 26894, 256, 59, 103, 2452, 9355, 59, 27275, 97, 114, 59, 26978, 2403, 9381, 0, 9386, 0, 9393, 0, 0, 0, 0, 0, 9397, 9402, 0, 9414, 9416, 9421, 0, 9465, 117, 116, 101, 59, 16698, 109, 112, 116, 121, 118, 59, 27060, 114, 97, 238, 2124, 98, 100, 97, 59, 17339, 103, 384, 59, 100, 108, 2190, 9409, 9411, 59, 27025, 229, 2190, 59, 27269, 117, 111, 32827, 171, 16555, 114, 1024, 59, 98, 102, 104, 108, 112, 115, 116, 2201, 9438, 9446, 9449, 9451, 9454, 9457, 9461, 256, 59, 102, 2205, 9443, 115, 59, 26911, 115, 59, 26909, 235, 8786, 112, 59, 25003, 108, 59, 26937, 105, 109, 59, 26995, 108, 59, 24994, 384, 59, 97, 101, 9471, 9472, 9476, 27307, 105, 108, 59, 26905, 256, 59, 115, 9481, 9482, 27309, 59, 49152, 10925, 65024, 384, 97, 98, 114, 9493, 9497, 9501, 114, 114, 59, 26892, 114, 107, 59, 26482, 256, 97, 107, 9506, 9516, 99, 256, 101, 107, 9512, 9514, 59, 16507, 59, 16475, 256, 101, 115, 9521, 9523, 59, 27019, 108, 256, 100, 117, 9529, 9531, 59, 27023, 59, 27021, 512, 97, 101, 117, 121, 9542, 9547, 9558, 9560, 114, 111, 110, 59, 16702, 256, 100, 105, 9552, 9556, 105, 108, 59, 16700, 236, 2224, 226, 9513, 59, 17467, 512, 99, 113, 114, 115, 9571, 9574, 9581, 9597, 97, 59, 26934, 117, 111, 256, 59, 114, 3609, 5958, 256, 100, 117, 9586, 9591, 104, 97, 114, 59, 26983, 115, 104, 97, 114, 59, 26955, 104, 59, 25010, 640, 59, 102, 103, 113, 115, 9611, 9612, 2441, 9715, 9727, 25188, 116, 640, 97, 104, 108, 114, 116, 9624, 9636, 9655, 9666, 9704, 114, 114, 111, 119, 256, 59, 116, 2201, 9633, 97, 233, 9462, 97, 114, 112, 111, 111, 110, 256, 100, 117, 9647, 9652, 111, 119, 110, 187, 1114, 112, 187, 2406, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 25031, 105, 103, 104, 116, 384, 97, 104, 115, 9677, 9686, 9694, 114, 114, 111, 119, 256, 59, 115, 2292, 2215, 97, 114, 112, 111, 111, 110, 243, 3992, 113, 117, 105, 103, 97, 114, 114, 111, 247, 8688, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 25291, 384, 59, 113, 115, 9611, 2451, 9722, 108, 97, 110, 244, 2476, 640, 59, 99, 100, 103, 115, 2476, 9738, 9741, 9757, 9768, 99, 59, 27304, 111, 116, 256, 59, 111, 9748, 9749, 27263, 256, 59, 114, 9754, 9755, 27265, 59, 27267, 256, 59, 101, 9762, 9765, 49152, 8922, 65024, 115, 59, 27283, 640, 97, 100, 101, 103, 115, 9779, 9785, 9789, 9801, 9803, 112, 112, 114, 111, 248, 9414, 111, 116, 59, 25302, 113, 256, 103, 113, 9795, 9797, 244, 2441, 103, 116, 242, 9356, 244, 2459, 105, 237, 2482, 384, 105, 108, 114, 9813, 2273, 9818, 115, 104, 116, 59, 27004, 59, 49152, 55349, 56617, 256, 59, 69, 2460, 9827, 59, 27281, 353, 9833, 9846, 114, 256, 100, 117, 9650, 9838, 256, 59, 108, 2405, 9843, 59, 26986, 108, 107, 59, 25988, 99, 121, 59, 17497, 640, 59, 97, 99, 104, 116, 2632, 9864, 9867, 9873, 9878, 114, 242, 9665, 111, 114, 110, 101, 242, 7432, 97, 114, 100, 59, 26987, 114, 105, 59, 26106, 256, 105, 111, 9887, 9892, 100, 111, 116, 59, 16704, 117, 115, 116, 256, 59, 97, 9900, 9901, 25520, 99, 104, 101, 187, 9901, 512, 69, 97, 101, 115, 9915, 9917, 9929, 9940, 59, 25192, 112, 256, 59, 112, 9923, 9924, 27273, 114, 111, 120, 187, 9924, 256, 59, 113, 9934, 9935, 27271, 256, 59, 113, 9934, 9915, 105, 109, 59, 25318, 1024, 97, 98, 110, 111, 112, 116, 119, 122, 9961, 9972, 9975, 10010, 10031, 10049, 10055, 10064, 256, 110, 114, 9966, 9969, 103, 59, 26604, 114, 59, 25085, 114, 235, 2241, 103, 384, 108, 109, 114, 9983, 9997, 10004, 101, 102, 116, 256, 97, 114, 2534, 9991, 105, 103, 104, 116, 225, 2546, 97, 112, 115, 116, 111, 59, 26620, 105, 103, 104, 116, 225, 2557, 112, 97, 114, 114, 111, 119, 256, 108, 114, 10021, 10025, 101, 102, 244, 9453, 105, 103, 104, 116, 59, 25004, 384, 97, 102, 108, 10038, 10041, 10045, 114, 59, 27013, 59, 49152, 55349, 56669, 117, 115, 59, 27181, 105, 109, 101, 115, 59, 27188, 353, 10059, 10063, 115, 116, 59, 25111, 225, 4942, 384, 59, 101, 102, 10071, 10072, 6144, 26058, 110, 103, 101, 187, 10072, 97, 114, 256, 59, 108, 10084, 10085, 16424, 116, 59, 27027, 640, 97, 99, 104, 109, 116, 10099, 10102, 10108, 10117, 10119, 114, 242, 2216, 111, 114, 110, 101, 242, 7564, 97, 114, 256, 59, 100, 3992, 10115, 59, 26989, 59, 24590, 114, 105, 59, 25279, 768, 97, 99, 104, 105, 113, 116, 10136, 10141, 2624, 10146, 10158, 10171, 113, 117, 111, 59, 24633, 114, 59, 49152, 55349, 56513, 109, 384, 59, 101, 103, 2482, 10154, 10156, 59, 27277, 59, 27279, 256, 98, 117, 9514, 10163, 111, 256, 59, 114, 3615, 10169, 59, 24602, 114, 111, 107, 59, 16706, 33792, 60, 59, 99, 100, 104, 105, 108, 113, 114, 2091, 10194, 9785, 10204, 10208, 10213, 10218, 10224, 256, 99, 105, 10199, 10201, 59, 27302, 114, 59, 27257, 114, 101, 229, 9714, 109, 101, 115, 59, 25289, 97, 114, 114, 59, 26998, 117, 101, 115, 116, 59, 27259, 256, 80, 105, 10229, 10233, 97, 114, 59, 27030, 384, 59, 101, 102, 10240, 2349, 6171, 26051, 114, 256, 100, 117, 10247, 10253, 115, 104, 97, 114, 59, 26954, 104, 97, 114, 59, 26982, 256, 101, 110, 10263, 10273, 114, 116, 110, 101, 113, 113, 59, 49152, 8808, 65024, 197, 10270, 1792, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 10304, 10309, 10370, 10382, 10387, 10400, 10405, 10408, 10458, 10466, 10468, 2691, 10483, 10498, 68, 111, 116, 59, 25146, 512, 99, 108, 112, 114, 10318, 10322, 10339, 10365, 114, 32827, 175, 16559, 256, 101, 116, 10327, 10329, 59, 26178, 256, 59, 101, 10334, 10335, 26400, 115, 101, 187, 10335, 256, 59, 115, 4155, 10344, 116, 111, 512, 59, 100, 108, 117, 4155, 10355, 10359, 10363, 111, 119, 238, 1164, 101, 102, 244, 2319, 240, 5073, 107, 101, 114, 59, 26030, 256, 111, 121, 10375, 10380, 109, 109, 97, 59, 27177, 59, 17468, 97, 115, 104, 59, 24596, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 187, 5670, 114, 59, 49152, 55349, 56618, 111, 59, 24871, 384, 99, 100, 110, 10415, 10420, 10441, 114, 111, 32827, 181, 16565, 512, 59, 97, 99, 100, 5220, 10429, 10432, 10436, 115, 244, 5799, 105, 114, 59, 27376, 111, 116, 32955, 183, 437, 117, 115, 384, 59, 98, 100, 10450, 6403, 10451, 25106, 256, 59, 117, 7484, 10456, 59, 27178, 355, 10462, 10465, 112, 59, 27355, 242, 8722, 240, 2689, 256, 100, 112, 10473, 10478, 101, 108, 115, 59, 25255, 102, 59, 49152, 55349, 56670, 256, 99, 116, 10488, 10493, 114, 59, 49152, 55349, 56514, 112, 111, 115, 187, 5533, 384, 59, 108, 109, 10505, 10506, 10509, 17340, 116, 105, 109, 97, 112, 59, 25272, 3072, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 10562, 10579, 10622, 10633, 10648, 10714, 10729, 10773, 10778, 10840, 10845, 10883, 10901, 10916, 10920, 11012, 11015, 11076, 11135, 11182, 11316, 11367, 11388, 11497, 256, 103, 116, 10567, 10571, 59, 49152, 8921, 824, 256, 59, 118, 10576, 3023, 49152, 8811, 8402, 384, 101, 108, 116, 10586, 10610, 10614, 102, 116, 256, 97, 114, 10593, 10599, 114, 114, 111, 119, 59, 25037, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25038, 59, 49152, 8920, 824, 256, 59, 118, 10619, 3143, 49152, 8810, 8402, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 25039, 256, 68, 100, 10638, 10643, 97, 115, 104, 59, 25263, 97, 115, 104, 59, 25262, 640, 98, 99, 110, 112, 116, 10659, 10663, 10668, 10673, 10700, 108, 97, 187, 734, 117, 116, 101, 59, 16708, 103, 59, 49152, 8736, 8402, 640, 59, 69, 105, 111, 112, 3460, 10684, 10688, 10693, 10696, 59, 49152, 10864, 824, 100, 59, 49152, 8779, 824, 115, 59, 16713, 114, 111, 248, 3460, 117, 114, 256, 59, 97, 10707, 10708, 26222, 108, 256, 59, 115, 10707, 2872, 499, 10719, 0, 10723, 112, 32955, 160, 2871, 109, 112, 256, 59, 101, 3065, 3072, 640, 97, 101, 111, 117, 121, 10740, 10750, 10755, 10768, 10771, 496, 10745, 0, 10747, 59, 27203, 111, 110, 59, 16712, 100, 105, 108, 59, 16710, 110, 103, 256, 59, 100, 3454, 10762, 111, 116, 59, 49152, 10861, 824, 112, 59, 27202, 59, 17469, 97, 115, 104, 59, 24595, 896, 59, 65, 97, 100, 113, 115, 120, 2962, 10793, 10797, 10811, 10817, 10821, 10832, 114, 114, 59, 25047, 114, 256, 104, 114, 10803, 10806, 107, 59, 26916, 256, 59, 111, 5106, 5104, 111, 116, 59, 49152, 8784, 824, 117, 105, 246, 2915, 256, 101, 105, 10826, 10830, 97, 114, 59, 26920, 237, 2968, 105, 115, 116, 256, 59, 115, 2976, 2975, 114, 59, 49152, 55349, 56619, 512, 69, 101, 115, 116, 3013, 10854, 10873, 10876, 384, 59, 113, 115, 3004, 10861, 3041, 384, 59, 113, 115, 3004, 3013, 10868, 108, 97, 110, 244, 3042, 105, 237, 3050, 256, 59, 114, 2998, 10881, 187, 2999, 384, 65, 97, 112, 10890, 10893, 10897, 114, 242, 10609, 114, 114, 59, 25006, 97, 114, 59, 27378, 384, 59, 115, 118, 3981, 10908, 3980, 256, 59, 100, 10913, 10914, 25340, 59, 25338, 99, 121, 59, 17498, 896, 65, 69, 97, 100, 101, 115, 116, 10935, 10938, 10942, 10946, 10949, 10998, 11001, 114, 242, 10598, 59, 49152, 8806, 824, 114, 114, 59, 24986, 114, 59, 24613, 512, 59, 102, 113, 115, 3131, 10958, 10979, 10991, 116, 256, 97, 114, 10964, 10969, 114, 114, 111, 247, 10945, 105, 103, 104, 116, 97, 114, 114, 111, 247, 10896, 384, 59, 113, 115, 3131, 10938, 10986, 108, 97, 110, 244, 3157, 256, 59, 115, 3157, 10996, 187, 3126, 105, 237, 3165, 256, 59, 114, 3125, 11006, 105, 256, 59, 101, 3098, 3109, 105, 228, 3472, 256, 112, 116, 11020, 11025, 102, 59, 49152, 55349, 56671, 33152, 172, 59, 105, 110, 11033, 11034, 11062, 16556, 110, 512, 59, 69, 100, 118, 2953, 11044, 11048, 11054, 59, 49152, 8953, 824, 111, 116, 59, 49152, 8949, 824, 481, 2953, 11059, 11061, 59, 25335, 59, 25334, 105, 256, 59, 118, 3256, 11068, 481, 3256, 11073, 11075, 59, 25342, 59, 25341, 384, 97, 111, 114, 11083, 11107, 11113, 114, 512, 59, 97, 115, 116, 2939, 11093, 11098, 11103, 108, 108, 101, 236, 2939, 108, 59, 49152, 11005, 8421, 59, 49152, 8706, 824, 108, 105, 110, 116, 59, 27156, 384, 59, 99, 101, 3218, 11120, 11123, 117, 229, 3237, 256, 59, 99, 3224, 11128, 256, 59, 101, 3218, 11133, 241, 3224, 512, 65, 97, 105, 116, 11144, 11147, 11165, 11175, 114, 242, 10632, 114, 114, 384, 59, 99, 119, 11156, 11157, 11161, 24987, 59, 49152, 10547, 824, 59, 49152, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 187, 11157, 114, 105, 256, 59, 101, 3275, 3286, 896, 99, 104, 105, 109, 112, 113, 117, 11197, 11213, 11225, 11012, 2936, 11236, 11247, 512, 59, 99, 101, 114, 3378, 11206, 3383, 11209, 117, 229, 3397, 59, 49152, 55349, 56515, 111, 114, 116, 621, 11013, 0, 0, 11222, 97, 114, 225, 11094, 109, 256, 59, 101, 3438, 11231, 256, 59, 113, 3444, 3443, 115, 117, 256, 98, 112, 11243, 11245, 229, 3320, 229, 3339, 384, 98, 99, 112, 11254, 11281, 11289, 512, 59, 69, 101, 115, 11263, 11264, 3362, 11268, 25220, 59, 49152, 10949, 824, 101, 116, 256, 59, 101, 3355, 11275, 113, 256, 59, 113, 3363, 11264, 99, 256, 59, 101, 3378, 11287, 241, 3384, 512, 59, 69, 101, 115, 11298, 11299, 3423, 11303, 25221, 59, 49152, 10950, 824, 101, 116, 256, 59, 101, 3416, 11310, 113, 256, 59, 113, 3424, 11299, 512, 103, 105, 108, 114, 11325, 11327, 11333, 11335, 236, 3031, 108, 100, 101, 32827, 241, 16625, 231, 3139, 105, 97, 110, 103, 108, 101, 256, 108, 114, 11346, 11356, 101, 102, 116, 256, 59, 101, 3098, 11354, 241, 3110, 105, 103, 104, 116, 256, 59, 101, 3275, 11365, 241, 3287, 256, 59, 109, 11372, 11373, 17341, 384, 59, 101, 115, 11380, 11381, 11385, 16419, 114, 111, 59, 24854, 112, 59, 24583, 1152, 68, 72, 97, 100, 103, 105, 108, 114, 115, 11407, 11412, 11417, 11422, 11427, 11440, 11446, 11475, 11491, 97, 115, 104, 59, 25261, 97, 114, 114, 59, 26884, 112, 59, 49152, 8781, 8402, 97, 115, 104, 59, 25260, 256, 101, 116, 11432, 11436, 59, 49152, 8805, 8402, 59, 49152, 62, 8402, 110, 102, 105, 110, 59, 27102, 384, 65, 101, 116, 11453, 11457, 11461, 114, 114, 59, 26882, 59, 49152, 8804, 8402, 256, 59, 114, 11466, 11469, 49152, 60, 8402, 105, 101, 59, 49152, 8884, 8402, 256, 65, 116, 11480, 11484, 114, 114, 59, 26883, 114, 105, 101, 59, 49152, 8885, 8402, 105, 109, 59, 49152, 8764, 8402, 384, 65, 97, 110, 11504, 11508, 11522, 114, 114, 59, 25046, 114, 256, 104, 114, 11514, 11517, 107, 59, 26915, 256, 59, 111, 5095, 5093, 101, 97, 114, 59, 26919, 4691, 6805, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11565, 0, 11576, 11592, 11616, 11621, 11634, 11652, 6919, 0, 0, 11661, 11691, 0, 11720, 11726, 0, 11740, 11801, 11819, 11838, 11843, 256, 99, 115, 11569, 6807, 117, 116, 101, 32827, 243, 16627, 256, 105, 121, 11580, 11589, 114, 256, 59, 99, 6814, 11586, 32827, 244, 16628, 59, 17470, 640, 97, 98, 105, 111, 115, 6816, 11602, 11607, 456, 11610, 108, 97, 99, 59, 16721, 118, 59, 27192, 111, 108, 100, 59, 27068, 108, 105, 103, 59, 16723, 256, 99, 114, 11625, 11629, 105, 114, 59, 27071, 59, 49152, 55349, 56620, 879, 11641, 0, 0, 11644, 0, 11650, 110, 59, 17115, 97, 118, 101, 32827, 242, 16626, 59, 27073, 256, 98, 109, 11656, 3572, 97, 114, 59, 27061, 512, 97, 99, 105, 116, 11669, 11672, 11685, 11688, 114, 242, 6784, 256, 105, 114, 11677, 11680, 114, 59, 27070, 111, 115, 115, 59, 27067, 110, 229, 3666, 59, 27072, 384, 97, 101, 105, 11697, 11701, 11705, 99, 114, 59, 16717, 103, 97, 59, 17353, 384, 99, 100, 110, 11712, 11717, 461, 114, 111, 110, 59, 17343, 59, 27062, 112, 102, 59, 49152, 55349, 56672, 384, 97, 101, 108, 11732, 11735, 466, 114, 59, 27063, 114, 112, 59, 27065, 896, 59, 97, 100, 105, 111, 115, 118, 11754, 11755, 11758, 11784, 11789, 11792, 11798, 25128, 114, 242, 6790, 512, 59, 101, 102, 109, 11767, 11768, 11778, 11781, 27229, 114, 256, 59, 111, 11774, 11775, 24884, 102, 187, 11775, 32827, 170, 16554, 32827, 186, 16570, 103, 111, 102, 59, 25270, 114, 59, 27222, 108, 111, 112, 101, 59, 27223, 59, 27227, 384, 99, 108, 111, 11807, 11809, 11815, 242, 11777, 97, 115, 104, 32827, 248, 16632, 108, 59, 25240, 105, 364, 11823, 11828, 100, 101, 32827, 245, 16629, 101, 115, 256, 59, 97, 475, 11834, 115, 59, 27190, 109, 108, 32827, 246, 16630, 98, 97, 114, 59, 25405, 2785, 11870, 0, 11901, 0, 11904, 11933, 0, 11938, 11961, 0, 0, 11979, 3740, 0, 12051, 0, 0, 12075, 12220, 0, 12232, 114, 512, 59, 97, 115, 116, 1027, 11879, 11890, 3717, 33024, 182, 59, 108, 11885, 11886, 16566, 108, 101, 236, 1027, 617, 11896, 0, 0, 11899, 109, 59, 27379, 59, 27389, 121, 59, 17471, 114, 640, 99, 105, 109, 112, 116, 11915, 11919, 11923, 6245, 11927, 110, 116, 59, 16421, 111, 100, 59, 16430, 105, 108, 59, 24624, 101, 110, 107, 59, 24625, 114, 59, 49152, 55349, 56621, 384, 105, 109, 111, 11944, 11952, 11956, 256, 59, 118, 11949, 11950, 17350, 59, 17365, 109, 97, 244, 2678, 110, 101, 59, 26126, 384, 59, 116, 118, 11967, 11968, 11976, 17344, 99, 104, 102, 111, 114, 107, 187, 8189, 59, 17366, 256, 97, 117, 11983, 11999, 110, 256, 99, 107, 11989, 11997, 107, 256, 59, 104, 8692, 11995, 59, 24846, 246, 8692, 115, 1152, 59, 97, 98, 99, 100, 101, 109, 115, 116, 12019, 12020, 6408, 12025, 12029, 12036, 12038, 12042, 12046, 16427, 99, 105, 114, 59, 27171, 105, 114, 59, 27170, 256, 111, 117, 7488, 12034, 59, 27173, 59, 27250, 110, 32955, 177, 3741, 105, 109, 59, 27174, 119, 111, 59, 27175, 384, 105, 112, 117, 12057, 12064, 12069, 110, 116, 105, 110, 116, 59, 27157, 102, 59, 49152, 55349, 56673, 110, 100, 32827, 163, 16547, 1280, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 3784, 12095, 12097, 12100, 12103, 12161, 12169, 12178, 12158, 12214, 59, 27315, 112, 59, 27319, 117, 229, 3801, 256, 59, 99, 3790, 12108, 768, 59, 97, 99, 101, 110, 115, 3784, 12121, 12127, 12134, 12136, 12158, 112, 112, 114, 111, 248, 12099, 117, 114, 108, 121, 101, 241, 3801, 241, 3790, 384, 97, 101, 115, 12143, 12150, 12154, 112, 112, 114, 111, 120, 59, 27321, 113, 113, 59, 27317, 105, 109, 59, 25320, 105, 237, 3807, 109, 101, 256, 59, 115, 12168, 3758, 24626, 384, 69, 97, 115, 12152, 12176, 12154, 240, 12149, 384, 100, 102, 112, 3820, 12185, 12207, 384, 97, 108, 115, 12192, 12197, 12202, 108, 97, 114, 59, 25390, 105, 110, 101, 59, 25362, 117, 114, 102, 59, 25363, 256, 59, 116, 3835, 12212, 239, 3835, 114, 101, 108, 59, 25264, 256, 99, 105, 12224, 12229, 114, 59, 49152, 55349, 56517, 59, 17352, 110, 99, 115, 112, 59, 24584, 768, 102, 105, 111, 112, 115, 117, 12250, 8930, 12255, 12261, 12267, 12273, 114, 59, 49152, 55349, 56622, 112, 102, 59, 49152, 55349, 56674, 114, 105, 109, 101, 59, 24663, 99, 114, 59, 49152, 55349, 56518, 384, 97, 101, 111, 12280, 12297, 12307, 116, 256, 101, 105, 12286, 12293, 114, 110, 105, 111, 110, 243, 1712, 110, 116, 59, 27158, 115, 116, 256, 59, 101, 12304, 12305, 16447, 241, 7961, 244, 3860, 2688, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 12352, 12369, 12373, 12377, 12512, 12558, 12587, 12615, 12642, 12658, 12686, 12806, 12821, 12836, 12841, 12888, 12910, 12914, 12944, 12976, 12983, 384, 97, 114, 116, 12359, 12362, 12364, 114, 242, 4275, 242, 989, 97, 105, 108, 59, 26908, 97, 114, 242, 7269, 97, 114, 59, 26980, 896, 99, 100, 101, 110, 113, 114, 116, 12392, 12405, 12408, 12415, 12431, 12436, 12492, 256, 101, 117, 12397, 12401, 59, 49152, 8765, 817, 116, 101, 59, 16725, 105, 227, 4462, 109, 112, 116, 121, 118, 59, 27059, 103, 512, 59, 100, 101, 108, 4049, 12425, 12427, 12429, 59, 27026, 59, 27045, 229, 4049, 117, 111, 32827, 187, 16571, 114, 1408, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 4060, 12460, 12463, 12471, 12473, 12476, 12478, 12480, 12483, 12487, 12490, 112, 59, 26997, 256, 59, 102, 4064, 12468, 115, 59, 26912, 59, 26931, 115, 59, 26910, 235, 8797, 240, 10030, 108, 59, 26949, 105, 109, 59, 26996, 108, 59, 24995, 59, 24989, 256, 97, 105, 12497, 12501, 105, 108, 59, 26906, 111, 256, 59, 110, 12507, 12508, 25142, 97, 108, 243, 3870, 384, 97, 98, 114, 12519, 12522, 12526, 114, 242, 6117, 114, 107, 59, 26483, 256, 97, 107, 12531, 12541, 99, 256, 101, 107, 12537, 12539, 59, 16509, 59, 16477, 256, 101, 115, 12546, 12548, 59, 27020, 108, 256, 100, 117, 12554, 12556, 59, 27022, 59, 27024, 512, 97, 101, 117, 121, 12567, 12572, 12583, 12585, 114, 111, 110, 59, 16729, 256, 100, 105, 12577, 12581, 105, 108, 59, 16727, 236, 4082, 226, 12538, 59, 17472, 512, 99, 108, 113, 115, 12596, 12599, 12605, 12612, 97, 59, 26935, 100, 104, 97, 114, 59, 26985, 117, 111, 256, 59, 114, 526, 525, 104, 59, 25011, 384, 97, 99, 103, 12622, 12639, 3908, 108, 512, 59, 105, 112, 115, 3960, 12632, 12635, 4252, 110, 229, 4283, 97, 114, 244, 4009, 116, 59, 26029, 384, 105, 108, 114, 12649, 4131, 12654, 115, 104, 116, 59, 27005, 59, 49152, 55349, 56623, 256, 97, 111, 12663, 12678, 114, 256, 100, 117, 12669, 12671, 187, 1147, 256, 59, 108, 4241, 12676, 59, 26988, 256, 59, 118, 12683, 12684, 17345, 59, 17393, 384, 103, 110, 115, 12693, 12793, 12796, 104, 116, 768, 97, 104, 108, 114, 115, 116, 12708, 12720, 12738, 12760, 12772, 12782, 114, 114, 111, 119, 256, 59, 116, 4060, 12717, 97, 233, 12488, 97, 114, 112, 111, 111, 110, 256, 100, 117, 12731, 12735, 111, 119, 238, 12670, 112, 187, 4242, 101, 102, 116, 256, 97, 104, 12746, 12752, 114, 114, 111, 119, 243, 4074, 97, 114, 112, 111, 111, 110, 243, 1361, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 25033, 113, 117, 105, 103, 97, 114, 114, 111, 247, 12491, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 25292, 103, 59, 17114, 105, 110, 103, 100, 111, 116, 115, 101, 241, 7986, 384, 97, 104, 109, 12813, 12816, 12819, 114, 242, 4074, 97, 242, 1361, 59, 24591, 111, 117, 115, 116, 256, 59, 97, 12830, 12831, 25521, 99, 104, 101, 187, 12831, 109, 105, 100, 59, 27374, 512, 97, 98, 112, 116, 12850, 12861, 12864, 12882, 256, 110, 114, 12855, 12858, 103, 59, 26605, 114, 59, 25086, 114, 235, 4099, 384, 97, 102, 108, 12871, 12874, 12878, 114, 59, 27014, 59, 49152, 55349, 56675, 117, 115, 59, 27182, 105, 109, 101, 115, 59, 27189, 256, 97, 112, 12893, 12903, 114, 256, 59, 103, 12899, 12900, 16425, 116, 59, 27028, 111, 108, 105, 110, 116, 59, 27154, 97, 114, 242, 12771, 512, 97, 99, 104, 113, 12923, 12928, 4284, 12933, 113, 117, 111, 59, 24634, 114, 59, 49152, 55349, 56519, 256, 98, 117, 12539, 12938, 111, 256, 59, 114, 532, 531, 384, 104, 105, 114, 12951, 12955, 12960, 114, 101, 229, 12792, 109, 101, 115, 59, 25290, 105, 512, 59, 101, 102, 108, 12970, 4185, 6177, 12971, 26041, 116, 114, 105, 59, 27086, 108, 117, 104, 97, 114, 59, 26984, 59, 24862, 3425, 13013, 13019, 13023, 13100, 13112, 13169, 0, 13178, 13220, 0, 0, 13292, 13296, 0, 13352, 13384, 13402, 13485, 13489, 13514, 13553, 0, 13846, 0, 0, 13875, 99, 117, 116, 101, 59, 16731, 113, 117, 239, 10170, 1280, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 4589, 13043, 13045, 13055, 13058, 13067, 13071, 13087, 13094, 13097, 59, 27316, 496, 13050, 0, 13052, 59, 27320, 111, 110, 59, 16737, 117, 229, 4606, 256, 59, 100, 4595, 13063, 105, 108, 59, 16735, 114, 99, 59, 16733, 384, 69, 97, 115, 13078, 13080, 13083, 59, 27318, 112, 59, 27322, 105, 109, 59, 25321, 111, 108, 105, 110, 116, 59, 27155, 105, 237, 4612, 59, 17473, 111, 116, 384, 59, 98, 101, 13108, 7495, 13109, 25285, 59, 27238, 896, 65, 97, 99, 109, 115, 116, 120, 13126, 13130, 13143, 13147, 13150, 13155, 13165, 114, 114, 59, 25048, 114, 256, 104, 114, 13136, 13138, 235, 8744, 256, 59, 111, 2614, 2612, 116, 32827, 167, 16551, 105, 59, 16443, 119, 97, 114, 59, 26921, 109, 256, 105, 110, 13161, 240, 110, 117, 243, 241, 116, 59, 26422, 114, 256, 59, 111, 13174, 8277, 49152, 55349, 56624, 512, 97, 99, 111, 121, 13186, 13190, 13201, 13216, 114, 112, 59, 26223, 256, 104, 121, 13195, 13199, 99, 121, 59, 17481, 59, 17480, 114, 116, 621, 13209, 0, 0, 13212, 105, 228, 5220, 97, 114, 97, 236, 11887, 32827, 173, 16557, 256, 103, 109, 13224, 13236, 109, 97, 384, 59, 102, 118, 13233, 13234, 13234, 17347, 59, 17346, 1024, 59, 100, 101, 103, 108, 110, 112, 114, 4779, 13253, 13257, 13262, 13270, 13278, 13281, 13286, 111, 116, 59, 27242, 256, 59, 113, 4785, 4784, 256, 59, 69, 13267, 13268, 27294, 59, 27296, 256, 59, 69, 13275, 13276, 27293, 59, 27295, 101, 59, 25158, 108, 117, 115, 59, 27172, 97, 114, 114, 59, 26994, 97, 114, 242, 4413, 512, 97, 101, 105, 116, 13304, 13320, 13327, 13335, 256, 108, 115, 13309, 13316, 108, 115, 101, 116, 109, 233, 13162, 104, 112, 59, 27187, 112, 97, 114, 115, 108, 59, 27108, 256, 100, 108, 5219, 13332, 101, 59, 25379, 256, 59, 101, 13340, 13341, 27306, 256, 59, 115, 13346, 13347, 27308, 59, 49152, 10924, 65024, 384, 102, 108, 112, 13358, 13363, 13378, 116, 99, 121, 59, 17484, 256, 59, 98, 13368, 13369, 16431, 256, 59, 97, 13374, 13375, 27076, 114, 59, 25407, 102, 59, 49152, 55349, 56676, 97, 256, 100, 114, 13389, 1026, 101, 115, 256, 59, 117, 13396, 13397, 26208, 105, 116, 187, 13397, 384, 99, 115, 117, 13408, 13433, 13471, 256, 97, 117, 13413, 13423, 112, 256, 59, 115, 4488, 13419, 59, 49152, 8851, 65024, 112, 256, 59, 115, 4532, 13429, 59, 49152, 8852, 65024, 117, 256, 98, 112, 13439, 13455, 384, 59, 101, 115, 4503, 4508, 13446, 101, 116, 256, 59, 101, 4503, 13453, 241, 4509, 384, 59, 101, 115, 4520, 4525, 13462, 101, 116, 256, 59, 101, 4520, 13469, 241, 4526, 384, 59, 97, 102, 4475, 13478, 1456, 114, 357, 13483, 1457, 187, 4476, 97, 114, 242, 4424, 512, 99, 101, 109, 116, 13497, 13502, 13506, 13509, 114, 59, 49152, 55349, 56520, 116, 109, 238, 241, 105, 236, 13333, 97, 114, 230, 4542, 256, 97, 114, 13518, 13525, 114, 256, 59, 102, 13524, 6079, 26118, 256, 97, 110, 13530, 13549, 105, 103, 104, 116, 256, 101, 112, 13539, 13546, 112, 115, 105, 108, 111, 238, 7904, 104, 233, 11951, 115, 187, 10322, 640, 98, 99, 109, 110, 112, 13563, 13662, 4617, 13707, 13710, 1152, 59, 69, 100, 101, 109, 110, 112, 114, 115, 13582, 13583, 13585, 13589, 13598, 13603, 13612, 13617, 13622, 25218, 59, 27333, 111, 116, 59, 27325, 256, 59, 100, 4570, 13594, 111, 116, 59, 27331, 117, 108, 116, 59, 27329, 256, 69, 101, 13608, 13610, 59, 27339, 59, 25226, 108, 117, 115, 59, 27327, 97, 114, 114, 59, 27001, 384, 101, 105, 117, 13629, 13650, 13653, 116, 384, 59, 101, 110, 13582, 13637, 13643, 113, 256, 59, 113, 4570, 13583, 101, 113, 256, 59, 113, 13611, 13608, 109, 59, 27335, 256, 98, 112, 13658, 13660, 59, 27349, 59, 27347, 99, 768, 59, 97, 99, 101, 110, 115, 4589, 13676, 13682, 13689, 13691, 13094, 112, 112, 114, 111, 248, 13050, 117, 114, 108, 121, 101, 241, 4606, 241, 4595, 384, 97, 101, 115, 13698, 13704, 13083, 112, 112, 114, 111, 248, 13082, 113, 241, 13079, 103, 59, 26218, 1664, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 13737, 13740, 13743, 4636, 13746, 13748, 13760, 13769, 13781, 13786, 13791, 13800, 13805, 32827, 185, 16569, 32827, 178, 16562, 32827, 179, 16563, 59, 27334, 256, 111, 115, 13753, 13756, 116, 59, 27326, 117, 98, 59, 27352, 256, 59, 100, 4642, 13765, 111, 116, 59, 27332, 115, 256, 111, 117, 13775, 13778, 108, 59, 26569, 98, 59, 27351, 97, 114, 114, 59, 27003, 117, 108, 116, 59, 27330, 256, 69, 101, 13796, 13798, 59, 27340, 59, 25227, 108, 117, 115, 59, 27328, 384, 101, 105, 117, 13812, 13833, 13836, 116, 384, 59, 101, 110, 4636, 13820, 13826, 113, 256, 59, 113, 4642, 13746, 101, 113, 256, 59, 113, 13799, 13796, 109, 59, 27336, 256, 98, 112, 13841, 13843, 59, 27348, 59, 27350, 384, 65, 97, 110, 13852, 13856, 13869, 114, 114, 59, 25049, 114, 256, 104, 114, 13862, 13864, 235, 8750, 256, 59, 111, 2603, 2601, 119, 97, 114, 59, 26922, 108, 105, 103, 32827, 223, 16607, 3041, 13905, 13917, 13920, 4814, 13939, 13945, 0, 13950, 14018, 0, 0, 0, 0, 0, 14043, 14083, 0, 14089, 14188, 0, 0, 0, 14215, 626, 13910, 0, 0, 13915, 103, 101, 116, 59, 25366, 59, 17348, 114, 235, 3679, 384, 97, 101, 121, 13926, 13931, 13936, 114, 111, 110, 59, 16741, 100, 105, 108, 59, 16739, 59, 17474, 108, 114, 101, 99, 59, 25365, 114, 59, 49152, 55349, 56625, 512, 101, 105, 107, 111, 13958, 13981, 14005, 14012, 498, 13963, 0, 13969, 101, 256, 52, 102, 4740, 4737, 97, 384, 59, 115, 118, 13976, 13977, 13979, 17336, 121, 109, 59, 17361, 256, 99, 110, 13986, 14002, 107, 256, 97, 115, 13992, 13998, 112, 112, 114, 111, 248, 4801, 105, 109, 187, 4780, 115, 240, 4766, 256, 97, 115, 14010, 13998, 240, 4801, 114, 110, 32827, 254, 16638, 492, 799, 14022, 8935, 101, 115, 33152, 215, 59, 98, 100, 14031, 14032, 14040, 16599, 256, 59, 97, 6415, 14037, 114, 59, 27185, 59, 27184, 384, 101, 112, 115, 14049, 14051, 14080, 225, 10829, 512, 59, 98, 99, 102, 1158, 14060, 14064, 14068, 111, 116, 59, 25398, 105, 114, 59, 27377, 256, 59, 111, 14073, 14076, 49152, 55349, 56677, 114, 107, 59, 27354, 225, 13154, 114, 105, 109, 101, 59, 24628, 384, 97, 105, 112, 14095, 14098, 14180, 100, 229, 4680, 896, 97, 100, 101, 109, 112, 115, 116, 14113, 14157, 14144, 14161, 14167, 14172, 14175, 110, 103, 108, 101, 640, 59, 100, 108, 113, 114, 14128, 14129, 14134, 14144, 14146, 26037, 111, 119, 110, 187, 7611, 101, 102, 116, 256, 59, 101, 10240, 14142, 241, 2350, 59, 25180, 105, 103, 104, 116, 256, 59, 101, 12970, 14155, 241, 4186, 111, 116, 59, 26092, 105, 110, 117, 115, 59, 27194, 108, 117, 115, 59, 27193, 98, 59, 27085, 105, 109, 101, 59, 27195, 101, 122, 105, 117, 109, 59, 25570, 384, 99, 104, 116, 14194, 14205, 14209, 256, 114, 121, 14199, 14203, 59, 49152, 55349, 56521, 59, 17478, 99, 121, 59, 17499, 114, 111, 107, 59, 16743, 256, 105, 111, 14219, 14222, 120, 244, 6007, 104, 101, 97, 100, 256, 108, 114, 14231, 14240, 101, 102, 116, 97, 114, 114, 111, 247, 2127, 105, 103, 104, 116, 97, 114, 114, 111, 119, 187, 3933, 2304, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 14288, 14291, 14295, 14308, 14320, 14332, 14350, 14364, 14371, 14388, 14417, 14429, 14443, 14505, 14540, 14546, 14570, 14582, 114, 242, 1005, 97, 114, 59, 26979, 256, 99, 114, 14300, 14306, 117, 116, 101, 32827, 250, 16634, 242, 4432, 114, 483, 14314, 0, 14317, 121, 59, 17502, 118, 101, 59, 16749, 256, 105, 121, 14325, 14330, 114, 99, 32827, 251, 16635, 59, 17475, 384, 97, 98, 104, 14339, 14342, 14347, 114, 242, 5037, 108, 97, 99, 59, 16753, 97, 242, 5059, 256, 105, 114, 14355, 14360, 115, 104, 116, 59, 27006, 59, 49152, 55349, 56626, 114, 97, 118, 101, 32827, 249, 16633, 353, 14375, 14385, 114, 256, 108, 114, 14380, 14382, 187, 2391, 187, 4227, 108, 107, 59, 25984, 256, 99, 116, 14393, 14413, 623, 14399, 0, 0, 14410, 114, 110, 256, 59, 101, 14405, 14406, 25372, 114, 187, 14406, 111, 112, 59, 25359, 114, 105, 59, 26104, 256, 97, 108, 14422, 14426, 99, 114, 59, 16747, 32955, 168, 841, 256, 103, 112, 14434, 14438, 111, 110, 59, 16755, 102, 59, 49152, 55349, 56678, 768, 97, 100, 104, 108, 115, 117, 4427, 14456, 14461, 4978, 14481, 14496, 111, 119, 110, 225, 5043, 97, 114, 112, 111, 111, 110, 256, 108, 114, 14472, 14476, 101, 102, 244, 14381, 105, 103, 104, 244, 14383, 105, 384, 59, 104, 108, 14489, 14490, 14492, 17349, 187, 5114, 111, 110, 187, 14490, 112, 97, 114, 114, 111, 119, 115, 59, 25032, 384, 99, 105, 116, 14512, 14532, 14536, 623, 14518, 0, 0, 14529, 114, 110, 256, 59, 101, 14524, 14525, 25373, 114, 187, 14525, 111, 112, 59, 25358, 110, 103, 59, 16751, 114, 105, 59, 26105, 99, 114, 59, 49152, 55349, 56522, 384, 100, 105, 114, 14553, 14557, 14562, 111, 116, 59, 25328, 108, 100, 101, 59, 16745, 105, 256, 59, 102, 14128, 14568, 187, 6163, 256, 97, 109, 14575, 14578, 114, 242, 14504, 108, 32827, 252, 16636, 97, 110, 103, 108, 101, 59, 27047, 1920, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 14620, 14623, 14633, 14637, 14773, 14776, 14781, 14815, 14820, 14824, 14835, 14841, 14845, 14849, 14880, 114, 242, 1015, 97, 114, 256, 59, 118, 14630, 14631, 27368, 59, 27369, 97, 115, 232, 993, 256, 110, 114, 14642, 14647, 103, 114, 116, 59, 27036, 896, 101, 107, 110, 112, 114, 115, 116, 13539, 14662, 14667, 14674, 14685, 14692, 14742, 97, 112, 112, 225, 9237, 111, 116, 104, 105, 110, 231, 7830, 384, 104, 105, 114, 13547, 11976, 14681, 111, 112, 244, 12213, 256, 59, 104, 5047, 14690, 239, 12685, 256, 105, 117, 14697, 14701, 103, 109, 225, 13235, 256, 98, 112, 14706, 14724, 115, 101, 116, 110, 101, 113, 256, 59, 113, 14717, 14720, 49152, 8842, 65024, 59, 49152, 10955, 65024, 115, 101, 116, 110, 101, 113, 256, 59, 113, 14735, 14738, 49152, 8843, 65024, 59, 49152, 10956, 65024, 256, 104, 114, 14747, 14751, 101, 116, 225, 13980, 105, 97, 110, 103, 108, 101, 256, 108, 114, 14762, 14767, 101, 102, 116, 187, 2341, 105, 103, 104, 116, 187, 4177, 121, 59, 17458, 97, 115, 104, 187, 4150, 384, 101, 108, 114, 14788, 14802, 14807, 384, 59, 98, 101, 11754, 14795, 14799, 97, 114, 59, 25275, 113, 59, 25178, 108, 105, 112, 59, 25326, 256, 98, 116, 14812, 5224, 97, 242, 5225, 114, 59, 49152, 55349, 56627, 116, 114, 233, 14766, 115, 117, 256, 98, 112, 14831, 14833, 187, 3356, 187, 3417, 112, 102, 59, 49152, 55349, 56679, 114, 111, 240, 3835, 116, 114, 233, 14772, 256, 99, 117, 14854, 14859, 114, 59, 49152, 55349, 56523, 256, 98, 112, 14864, 14872, 110, 256, 69, 101, 14720, 14870, 187, 14718, 110, 256, 69, 101, 14738, 14878, 187, 14736, 105, 103, 122, 97, 103, 59, 27034, 896, 99, 101, 102, 111, 112, 114, 115, 14902, 14907, 14934, 14939, 14932, 14945, 14954, 105, 114, 99, 59, 16757, 256, 100, 105, 14912, 14929, 256, 98, 103, 14917, 14921, 97, 114, 59, 27231, 101, 256, 59, 113, 5626, 14927, 59, 25177, 101, 114, 112, 59, 24856, 114, 59, 49152, 55349, 56628, 112, 102, 59, 49152, 55349, 56680, 256, 59, 101, 5241, 14950, 97, 116, 232, 5241, 99, 114, 59, 49152, 55349, 56524, 2787, 6030, 14983, 0, 14987, 0, 14992, 15003, 0, 0, 15005, 15016, 15019, 15023, 0, 0, 15043, 15054, 0, 15064, 6108, 6111, 116, 114, 233, 6097, 114, 59, 49152, 55349, 56629, 256, 65, 97, 14996, 14999, 114, 242, 963, 114, 242, 2550, 59, 17342, 256, 65, 97, 15009, 15012, 114, 242, 952, 114, 242, 2539, 97, 240, 10003, 105, 115, 59, 25339, 384, 100, 112, 116, 6052, 15029, 15038, 256, 102, 108, 15034, 6057, 59, 49152, 55349, 56681, 105, 109, 229, 6066, 256, 65, 97, 15047, 15050, 114, 242, 974, 114, 242, 2561, 256, 99, 113, 15058, 6072, 114, 59, 49152, 55349, 56525, 256, 112, 116, 6102, 15068, 114, 233, 6100, 1024, 97, 99, 101, 102, 105, 111, 115, 117, 15088, 15101, 15112, 15116, 15121, 15125, 15131, 15137, 99, 256, 117, 121, 15094, 15099, 116, 101, 32827, 253, 16637, 59, 17487, 256, 105, 121, 15106, 15110, 114, 99, 59, 16759, 59, 17483, 110, 32827, 165, 16549, 114, 59, 49152, 55349, 56630, 99, 121, 59, 17495, 112, 102, 59, 49152, 55349, 56682, 99, 114, 59, 49152, 55349, 56526, 256, 99, 109, 15142, 15145, 121, 59, 17486, 108, 32827, 255, 16639, 1280, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 15170, 15176, 15188, 15192, 15204, 15209, 15213, 15220, 15226, 15232, 99, 117, 116, 101, 59, 16762, 256, 97, 121, 15181, 15186, 114, 111, 110, 59, 16766, 59, 17463, 111, 116, 59, 16764, 256, 101, 116, 15197, 15201, 116, 114, 230, 5471, 97, 59, 17334, 114, 59, 49152, 55349, 56631, 99, 121, 59, 17462, 103, 114, 97, 114, 114, 59, 25053, 112, 102, 59, 49152, 55349, 56683, 99, 114, 59, 49152, 55349, 56527, 256, 106, 110, 15237, 15239, 59, 24589, 106, 59, 24588]);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array([512, 97, 103, 108, 113, 9, 21, 24, 27, 621, 15, 0, 0, 18, 112, 59, 16422, 111, 115, 59, 16423, 116, 59, 16446, 116, 59, 16444, 117, 111, 116, 59, 16418]);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
  let output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
__name(replaceCodePoint, "replaceCodePoint");
function decodeCodePoint(codePoint) {
  return fromCodePoint(replaceCodePoint(codePoint));
}
__name(decodeCodePoint, "decodeCodePoint");

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
})(CharCodes || (CharCodes = {}));
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function getDecoder(decodeTree) {
  return /* @__PURE__ */ __name(function decodeHTMLBinary(str, strict) {
    let ret = "";
    let lastIdx = 0;
    let strIdx = 0;
    while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
      ret += str.slice(lastIdx, strIdx);
      lastIdx = strIdx;
      strIdx += 1;
      if (str.charCodeAt(strIdx) === CharCodes.NUM) {
        let start = strIdx + 1;
        let base = 10;
        let cp = str.charCodeAt(start);
        if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {
          base = 16;
          strIdx += 1;
          start += 1;
        }
        do
          cp = str.charCodeAt(++strIdx);
        while (cp >= CharCodes.ZERO && cp <= CharCodes.NINE || base === 16 && (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A && (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F);
        if (start !== strIdx) {
          const entity = str.substring(start, strIdx);
          const parsed = parseInt(entity, base);
          if (str.charCodeAt(strIdx) === CharCodes.SEMI) {
            strIdx += 1;
          } else if (strict) {
            continue;
          }
          ret += decodeCodePoint(parsed);
          lastIdx = strIdx;
        }
        continue;
      }
      let resultIdx = 0;
      let excess = 1;
      let treeIdx = 0;
      let current = decodeTree[treeIdx];
      for (; strIdx < str.length; strIdx++, excess++) {
        treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
        if (treeIdx < 0)
          break;
        current = decodeTree[treeIdx];
        const masked = current & BinTrieFlags.VALUE_LENGTH;
        if (masked) {
          if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {
            resultIdx = treeIdx;
            excess = 0;
          }
          const valueLength = (masked >> 14) - 1;
          if (valueLength === 0)
            break;
          treeIdx += valueLength;
        }
      }
      if (resultIdx !== 0) {
        const valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;
        ret += valueLength === 1 ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH) : valueLength === 2 ? String.fromCharCode(decodeTree[resultIdx + 1]) : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);
        lastIdx = strIdx - excess + 1;
      }
    }
    return ret + str.slice(lastIdx);
  }, "decodeHTMLBinary");
}
__name(getDecoder, "getDecoder");
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value > branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
__name(determineBranch, "determineBranch");
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str) {
  return htmlDecoder(str, false);
}
__name(decodeHTML, "decodeHTML");

// node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
function getEscaper(regex, map) {
  return /* @__PURE__ */ __name(function escape2(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  }, "escape");
}
__name(getEscaper, "getEscaper");
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
})(DecodingMode || (DecodingMode = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// src/melody-parser/src/Parser.js
var UNARY = Symbol();
var BINARY = Symbol();
var TAG = Symbol();
var TEST = Symbol();
var Parser = class {
  constructor(tokenStream, options2) {
    this.tokens = tokenStream;
    this[UNARY] = {};
    this[BINARY] = {};
    this[TAG] = {};
    this[TEST] = {};
    this.options = Object.assign({}, {
      ignoreComments: true,
      ignoreHtmlComments: true,
      ignoreDeclarations: true,
      decodeEntities: true,
      preserveSourceLiterally: false,
      allowUnknownTags: false,
      multiTags: {}
    }, options2);
    if (Object.keys(this.options.multiTags).length > 0) {
      this.options.allowUnknownTags = true;
    }
  }
  applyExtension(ext) {
    if (ext.tags) {
      for (const tag of ext.tags) {
        this.addTag(tag);
      }
    }
    if (ext.unaryOperators) {
      for (const op of ext.unaryOperators) {
        this.addUnaryOperator(op);
      }
    }
    if (ext.binaryOperators) {
      for (const op of ext.binaryOperators) {
        this.addBinaryOperator(op);
      }
    }
    if (ext.tests) {
      for (const test of ext.tests) {
        this.addTest(test);
      }
    }
  }
  addUnaryOperator(op) {
    this[UNARY][op.text] = op;
    return this;
  }
  addBinaryOperator(op) {
    this[BINARY][op.text] = op;
    return this;
  }
  addTag(tag) {
    this[TAG][tag.name] = tag;
    return this;
  }
  addTest(test) {
    this[TEST][test.text] = test;
  }
  hasTest(test) {
    return !!this[TEST][test];
  }
  getTest(test) {
    return this[TEST][test];
  }
  isUnary(token) {
    return token.type === OPERATOR && !!this[UNARY][token.text];
  }
  getBinaryOperator(token) {
    return token.type === OPERATOR && this[BINARY][token.text];
  }
  parse(test = null) {
    let tokens = this.tokens, p = setStartFromToken(new n2.SequenceExpression(), tokens.la(0));
    while (!tokens.test(EOF)) {
      const token = tokens.next();
      if (!p) {
        p = setStartFromToken(new n2.SequenceExpression(), token);
      }
      if (test && test(tokens.la(0).text, token, tokens)) {
        setEndFromToken(p, token);
        return p;
      }
      switch (token.type) {
        case EXPRESSION_START: {
          const expression = this.matchExpression();
          const statement = new n2.PrintExpressionStatement(expression);
          const endToken = tokens.expect(EXPRESSION_END);
          setStartFromToken(statement, token);
          setEndFromToken(statement, endToken);
          setEndFromToken(p, endToken);
          statement.trimLeft = !!expression.trimLeft;
          statement.trimRight = !!expression.trimRight;
          p.add(statement);
          break;
        }
        case TAG_START:
          p.add(this.matchTag());
          break;
        case TEXT: {
          const textStringLiteral = createNode(n2.StringLiteral, token, token.text);
          const textTextStatement = createNode(n2.PrintTextStatement, token, textStringLiteral);
          p.add(textTextStatement);
          break;
        }
        case ENTITY: {
          const entityStringLiteral = createNode(n2.StringLiteral, token, !this.options.decodeEntities || this.options.preserveSourceLiterally ? token.text : decodeHTML(token.text));
          const entityTextStatement = createNode(n2.PrintTextStatement, token, entityStringLiteral);
          p.add(entityTextStatement);
          break;
        }
        case ELEMENT_START:
          p.add(this.matchElement());
          break;
        case DECLARATION_START: {
          const declarationNode = this.matchDeclaration();
          if (!this.options.ignoreDeclarations) {
            p.add(declarationNode);
          }
          break;
        }
        case COMMENT:
          if (!this.options.ignoreComments) {
            const stringLiteral3 = createNode(n2.StringLiteral, token, token.text);
            const twigComment = createNode(n2.TwigComment, token, stringLiteral3);
            p.add(twigComment);
          }
          break;
        case HTML_COMMENT:
          if (!this.options.ignoreHtmlComments) {
            const stringLiteral3 = createNode(n2.StringLiteral, token, token.text);
            const htmlComment = createNode(n2.HtmlComment, token, stringLiteral3);
            p.add(htmlComment);
          }
          break;
      }
    }
    return p;
  }
  matchDeclaration() {
    const tokens = this.tokens, declarationStartToken = tokens.la(-1);
    let declarationType = null, currentToken = null;
    if (!(declarationType = tokens.nextIf(SYMBOL))) {
      this.error({
        title: "Expected declaration start",
        pos: declarationStartToken.pos,
        advice: "After '<!', an unquoted symbol like DOCTYPE is expected"
      });
    }
    const declaration = new n2.Declaration(declarationType.text);
    while (currentToken = tokens.next()) {
      if (currentToken.type === SYMBOL) {
        const symbol = createNode(n2.Identifier, currentToken, currentToken.text);
        declaration.parts.push(symbol);
      } else if (currentToken.type === STRING_START) {
        const stringToken = tokens.expect(STRING);
        declaration.parts.push(createNode(n2.StringLiteral, stringToken, stringToken.text));
        tokens.expect(STRING_END);
      } else if (currentToken.type === EXPRESSION_START) {
        const expression = this.matchExpression();
        declaration.parts.push(copyLoc(new n2.PrintExpressionStatement(expression), expression));
        tokens.expect(EXPRESSION_END);
      } else if (currentToken.type === ELEMENT_END) {
        break;
      } else {
        this.error({
          title: "Expected string, symbol, or expression",
          pos: currentToken.pos,
          advice: "Only strings or symbols can be part of a declaration"
        });
      }
    }
    setStartFromToken(declaration, declarationStartToken);
    setEndFromToken(declaration, currentToken);
    return declaration;
  }
  matchElement() {
    const tokens = this.tokens, elementNameToken = tokens.la(0), tagStartToken = tokens.la(-1);
    let elementName;
    if (!(elementName = tokens.nextIf(SYMBOL))) {
      this.error({
        title: "Expected element start",
        pos: elementNameToken.pos,
        advice: tokens.lat(0) === SLASH ? `Unexpected closing "${tokens.la(1).text}" tag. Seems like your DOM is out of control.` : "Expected an element to start"
      });
    }
    const element = new n2.Element(elementName.text);
    this.matchAttributes(element, tokens);
    if (tokens.nextIf(SLASH)) {
      tokens.expect(ELEMENT_END);
      element.selfClosing = true;
    } else {
      tokens.expect(ELEMENT_END);
      if (voidElements[elementName.text]) {
        element.selfClosing = true;
      } else {
        element.children = this.parse(function(_, token, tokens2) {
          if (token.type === ELEMENT_START && tokens2.lat(0) === SLASH) {
            const name = tokens2.la(1);
            if (name.type === SYMBOL && name.text === elementName.text) {
              tokens2.next();
              tokens2.next();
              tokens2.expect(ELEMENT_END);
              return true;
            }
          }
          return false;
        }).expressions;
      }
    }
    setStartFromToken(element, tagStartToken);
    setEndFromToken(element, tokens.la(-1));
    setMarkFromToken(element, "elementNameLoc", elementNameToken);
    return element;
  }
  matchAttributes(element, tokens) {
    while (tokens.lat(0) !== SLASH && tokens.lat(0) !== ELEMENT_END) {
      const key = tokens.nextIf(SYMBOL);
      if (key) {
        const keyNode = new n2.Identifier(key.text);
        setStartFromToken(keyNode, key);
        setEndFromToken(keyNode, key);
        if (tokens.nextIf(ASSIGNMENT)) {
          const start = tokens.expect(STRING_START);
          let canBeString = true, nodes = [], token;
          while (!tokens.test(STRING_END)) {
            if (canBeString && (token = tokens.nextIf(STRING))) {
              nodes[nodes.length] = createNode(n2.StringLiteral, token, token.text);
              canBeString = false;
            } else if (token = tokens.nextIf(EXPRESSION_START)) {
              nodes[nodes.length] = this.matchExpression();
              tokens.expect(EXPRESSION_END);
              canBeString = true;
            } else {
              break;
            }
          }
          tokens.expect(STRING_END);
          if (!nodes.length) {
            const node = createNode(n2.StringLiteral, start, "");
            nodes.push(node);
          }
          let expr = nodes[0];
          for (let i = 1, len = nodes.length; i < len; i++) {
            const { line: line2, column } = expr.loc.start;
            expr = new n2.BinaryConcatExpression(expr, nodes[i]);
            expr.loc.start.line = line2;
            expr.loc.start.column = column;
            copyEnd(expr, expr.right);
          }
          if (nodes.length > 1) {
            expr.wasImplicitConcatenation = true;
          }
          const attr = new n2.Attribute(keyNode, expr);
          copyStart(attr, keyNode);
          copyEnd(attr, expr);
          element.attributes.push(attr);
        } else {
          element.attributes.push(copyLoc(new n2.Attribute(keyNode), keyNode));
        }
      } else if (tokens.nextIf(EXPRESSION_START)) {
        element.attributes.push(this.matchExpression());
        tokens.expect(EXPRESSION_END);
      } else {
        this.error({
          title: "Invalid token",
          pos: tokens.la(0).pos,
          advice: "A tag must consist of attributes or expressions. Twig Tags are not allowed."
        });
      }
    }
  }
  error(options2, metadata = {}) {
    this.tokens.error(options2.title, options2.pos, options2.advice, 1, metadata);
  }
  getGenericParserFor(tagName) {
    if (this.options.multiTags[tagName]) {
      return createMultiTagParser(tagName, this.options.multiTags[tagName]);
    } else {
      return GenericTagParser;
    }
  }
  matchTag() {
    const tokens = this.tokens;
    const tagStartToken = tokens.la(-1);
    const tag = tokens.expect(SYMBOL);
    let parser = this[TAG][tag.text];
    let isUsingGenericParser = false;
    if (!parser) {
      if (this.options.allowUnknownTags) {
        parser = this.getGenericParserFor(tag.text);
        isUsingGenericParser = true;
      } else {
        tokens.error(`Unknown tag "${tag.text}"`, tag.pos, `Expected a known tag such as
- ${Object.getOwnPropertyNames(this[TAG]).join("\n- ")}`, tag.length);
      }
    }
    const result = parser.parse(this, tag);
    const tagEndToken = tokens.la(-1);
    if (!isUsingGenericParser) {
      result.trimLeft = tagStartToken.text.endsWith("-");
      result.trimRight = tagEndToken.text.startsWith("-");
    }
    setStartFromToken(result, tagStartToken);
    setEndFromToken(result, tagEndToken);
    setMarkFromToken(result, "tagNameLoc", tag);
    return result;
  }
  matchExpression(precedence = 0) {
    const tokens = this.tokens, exprStartToken = tokens.la(0);
    let token, op, trimLeft = false;
    if (tokens.la(-1).type === EXPRESSION_START && tokens.la(-1).text.endsWith("-")) {
      trimLeft = true;
    }
    let expr = this.getPrimary();
    while ((token = tokens.la(0)) && token.type !== EOF && (op = this.getBinaryOperator(token)) && op.precedence >= precedence) {
      const opToken = tokens.next();
      if (op.parse) {
        expr = op.parse(this, opToken, expr);
      } else {
        const expr1 = this.matchExpression(op.associativity === LEFT ? op.precedence + 1 : op.precedence);
        expr = op.createNode(token, expr, expr1);
      }
      token = tokens.la(0);
    }
    var result = expr;
    if (precedence === 0) {
      setEndFromToken(expr, tokens.la(-1));
      result = this.matchConditionalExpression(expr);
      token = tokens.la(0);
    }
    if (token.type === EXPRESSION_END && token.text.startsWith("-")) {
      result.trimRight = true;
    }
    if (trimLeft) {
      result.trimLeft = trimLeft;
    }
    const exprEndToken = tokens.la(-1);
    setStartFromToken(result, exprStartToken);
    setEndFromToken(result, exprEndToken);
    return result;
  }
  getPrimary() {
    let tokens = this.tokens, token = tokens.la(0);
    if (this.isUnary(token)) {
      const op = this[UNARY][token.text];
      tokens.next();
      const expr = this.matchExpression(op.precedence);
      return this.matchPostfixExpression(op.createNode(token, expr));
    } else if (tokens.test(LPAREN)) {
      tokens.next();
      const expr = this.matchExpression();
      tokens.expect(RPAREN);
      return this.matchPostfixExpression(expr);
    }
    return this.matchPrimaryExpression();
  }
  matchPrimaryExpression() {
    let tokens = this.tokens, token = tokens.la(0), node;
    switch (token.type) {
      case NULL:
        node = createNode(n2.NullLiteral, tokens.next());
        break;
      case FALSE:
        node = createNode(n2.BooleanLiteral, tokens.next(), false);
        break;
      case TRUE:
        node = createNode(n2.BooleanLiteral, tokens.next(), true);
        break;
      case SYMBOL:
        tokens.next();
        if (tokens.test(LPAREN)) {
          node = new n2.CallExpression(createNode(n2.Identifier, token, token.text), this.matchArguments());
          copyStart(node, node.callee);
          setEndFromToken(node, tokens.la(-1));
        } else {
          node = createNode(n2.Identifier, token, token.text);
        }
        break;
      case NUMBER:
        node = createNode(n2.NumericLiteral, token, Number(tokens.next()));
        break;
      case STRING_START:
        node = this.matchStringExpression();
        break;
      default:
        if (token.type === LBRACE) {
          node = this.matchArray();
        } else if (token.type === LBRACKET) {
          node = this.matchMap();
        } else {
          this.error({
            title: 'Unexpected token "' + token.type + '" of value "' + token.text + '"',
            pos: token.pos
          }, {
            errorType: "UNEXPECTED_TOKEN",
            tokenText: token.text,
            tokenType: token.type
          });
        }
        break;
    }
    return this.matchPostfixExpression(node);
  }
  matchStringExpression() {
    let canBeString = true, token;
    const tokens = this.tokens, nodes = [], stringStart = tokens.expect(STRING_START);
    while (!tokens.test(STRING_END)) {
      if (canBeString && (token = tokens.nextIf(STRING))) {
        nodes[nodes.length] = createNode(n2.StringLiteral, token, token.text);
        canBeString = false;
      } else if (token = tokens.nextIf(INTERPOLATION_START)) {
        nodes[nodes.length] = this.matchExpression();
        tokens.expect(INTERPOLATION_END);
        canBeString = true;
      } else {
        break;
      }
    }
    const stringEnd = tokens.expect(STRING_END);
    if (!nodes.length) {
      return setEndFromToken(createNode(n2.StringLiteral, stringStart, ""), stringEnd);
    }
    let expr = nodes[0];
    for (let i = 1, len = nodes.length; i < len; i++) {
      const { line: line2, column } = expr.loc.start;
      expr = new n2.BinaryConcatExpression(expr, nodes[i]);
      expr.loc.start.line = line2;
      expr.loc.start.column = column;
      copyEnd(expr, expr.right);
    }
    if (nodes.length > 1) {
      expr.wasImplicitConcatenation = true;
    }
    setStartFromToken(expr, stringStart);
    setEndFromToken(expr, stringEnd);
    return expr;
  }
  matchConditionalExpression(test) {
    const tokens = this.tokens;
    let condition = test, consequent, alternate;
    while (tokens.nextIf(QUESTION_MARK)) {
      if (!tokens.nextIf(COLON)) {
        consequent = this.matchExpression();
        if (tokens.nextIf(COLON)) {
          alternate = this.matchExpression();
        } else {
          alternate = null;
        }
      } else {
        consequent = null;
        alternate = this.matchExpression();
      }
      const { line: line2, column } = condition.loc.start;
      condition = new n2.ConditionalExpression(condition, consequent, alternate);
      condition.loc.start = { line: line2, column };
      copyEnd(condition, alternate || consequent);
    }
    return condition;
  }
  matchArray() {
    let tokens = this.tokens, array = new n2.ArrayExpression(), start = tokens.expect(LBRACE);
    setStartFromToken(array, start);
    while (!tokens.test(RBRACE) && !tokens.test(EOF)) {
      array.elements.push(this.matchExpression());
      if (!tokens.test(RBRACE)) {
        tokens.expect(COMMA);
        if (tokens.test(RBRACE)) {
          break;
        }
      }
    }
    setEndFromToken(array, tokens.expect(RBRACE));
    return array;
  }
  matchMap() {
    let tokens = this.tokens, token, obj = new n2.ObjectExpression(), startToken = tokens.expect(LBRACKET);
    setStartFromToken(obj, startToken);
    while (!tokens.test(RBRACKET) && !tokens.test(EOF)) {
      let computed = false, key, value;
      if (tokens.test(STRING_START)) {
        key = this.matchStringExpression();
        if (!n2.is(key, "StringLiteral")) {
          computed = true;
        }
      } else if (token = tokens.nextIf(SYMBOL)) {
        key = createNode(n2.Identifier, token, token.text);
      } else if (token = tokens.nextIf(NUMBER)) {
        key = createNode(n2.NumericLiteral, token, Number(token.text));
      } else if (tokens.test(LPAREN)) {
        key = this.matchExpression();
        computed = true;
      } else {
        this.error({
          title: "Invalid map key",
          pos: tokens.la(0).pos,
          advice: "Key must be a string, symbol or a number but was " + tokens.next()
        });
      }
      tokens.expect(COLON);
      value = this.matchExpression();
      const prop = new n2.ObjectProperty(key, value, computed);
      copyStart(prop, key);
      copyEnd(prop, value);
      obj.properties.push(prop);
      if (!tokens.test(RBRACKET)) {
        tokens.expect(COMMA);
        if (tokens.test(RBRACKET)) {
          break;
        }
      }
    }
    setEndFromToken(obj, tokens.expect(RBRACKET));
    return obj;
  }
  matchPostfixExpression(expr) {
    const tokens = this.tokens;
    let node = expr;
    while (!tokens.test(EOF)) {
      if (tokens.test(DOT) || tokens.test(LBRACE)) {
        node = this.matchSubscriptExpression(node);
      } else if (tokens.test(PIPE)) {
        tokens.next();
        node = this.matchFilterExpression(node);
      } else {
        break;
      }
    }
    return node;
  }
  matchSubscriptExpression(node) {
    let tokens = this.tokens, op = tokens.next();
    if (op.type === DOT) {
      let token = tokens.next(), computed = false, property;
      if (token.type === SYMBOL) {
        property = createNode(n2.Identifier, token, token.text);
      } else if (token.type === NUMBER) {
        property = createNode(n2.NumericLiteral, token, Number(token.text));
        computed = true;
      } else {
        this.error({
          title: "Invalid token",
          pos: token.pos,
          advice: "Expected number or symbol, found " + token + " instead"
        });
      }
      const memberExpr = new n2.MemberExpression(node, property, computed);
      copyStart(memberExpr, node);
      copyEnd(memberExpr, property);
      if (tokens.test(LPAREN)) {
        const callExpr = new n2.CallExpression(memberExpr, this.matchArguments());
        copyStart(callExpr, memberExpr);
        setEndFromToken(callExpr, tokens.la(-1));
        return callExpr;
      }
      return memberExpr;
    } else {
      let arg, start;
      if (tokens.test(COLON)) {
        tokens.next();
        start = null;
      } else {
        arg = this.matchExpression();
        if (tokens.test(COLON)) {
          start = arg;
          arg = null;
          tokens.next();
        }
      }
      if (arg) {
        return setEndFromToken(copyStart(new n2.MemberExpression(node, arg, true), node), tokens.expect(RBRACE));
      } else {
        const result = new n2.SliceExpression(node, start, tokens.test(RBRACE) ? null : this.matchExpression());
        copyStart(result, node);
        setEndFromToken(result, tokens.expect(RBRACE));
        return result;
      }
    }
  }
  matchFilterExpression(node) {
    let tokens = this.tokens, target = node;
    while (!tokens.test(EOF)) {
      let token = tokens.expect(SYMBOL), name = createNode(n2.Identifier, token, token.text), args;
      var isDjango = false;
      if (tokens.test(LPAREN)) {
        args = this.matchArguments();
      } else if (tokens.test(COLON)) {
        args = this.matchDjangoFilterArguments();
        isDjango = true;
      } else {
        args = [];
      }
      const newTarget = new n2.FilterExpression(target, name, args);
      copyStart(newTarget, target);
      if (newTarget.arguments.length) {
        copyEnd(newTarget, newTarget.arguments[newTarget.arguments.length - 1]);
      } else {
        copyEnd(newTarget, target);
      }
      target = newTarget;
      target.isDjango = isDjango;
      if (!tokens.test(PIPE) || tokens.test(EOF)) {
        break;
      }
      tokens.next();
    }
    return target;
  }
  matchArguments() {
    let tokens = this.tokens, args = [];
    tokens.expect(LPAREN);
    while (!tokens.test(RPAREN) && !tokens.test(EOF)) {
      if (tokens.test(SYMBOL) && tokens.lat(1) === ASSIGNMENT) {
        const name = tokens.next();
        tokens.next();
        const value = this.matchExpression();
        const arg = new n2.NamedArgumentExpression(createNode(n2.Identifier, name, name.text), value);
        copyEnd(arg, value);
        args.push(arg);
      } else {
        args.push(this.matchExpression());
      }
      if (!tokens.test(COMMA)) {
        tokens.expect(RPAREN);
        return args;
      }
      tokens.expect(COMMA);
    }
    tokens.expect(RPAREN);
    return args;
  }
  matchDjangoFilterArguments() {
    let tokens = this.tokens, args = [];
    tokens.expect(COLON);
    while (!tokens.test(PIPE) && !tokens.test(EXPRESSION_END) && !tokens.test(TAG_END)) {
      args.push(this.matchExpression());
    }
    tokens.expect([PIPE, EXPRESSION_END, TAG_END]);
    tokens.index--;
    return args;
  }
};
__name(Parser, "Parser");

// src/melody-parser/src/TokenStream.js
var import_trimEnd = __toESM(require_trimEnd());
var import_trimStart = __toESM(require_trimStart());
var TOKENS = Symbol();
var LENGTH = Symbol();
var TokenStream = class {
  constructor(lexer, options2) {
    this.input = lexer;
    this.index = 0;
    const mergedOptions = Object.assign({}, {
      ignoreComments: true,
      ignoreHtmlComments: true,
      ignoreWhitespace: true,
      applyWhitespaceTrimming: true
    }, options2);
    this[TOKENS] = getAllTokens(lexer, mergedOptions);
    this[LENGTH] = this[TOKENS].length;
    if (this[TOKENS].length && this[TOKENS][this[TOKENS].length - 1].type === ERROR) {
      const errorToken = this[TOKENS][this[TOKENS].length - 1];
      this.error(errorToken.message, errorToken.pos, errorToken.advice, errorToken.endPos.index - errorToken.pos.index || 1);
    }
  }
  la(offset) {
    var index = this.index + offset;
    return index < this[LENGTH] ? this[TOKENS][index] : EOF_TOKEN;
  }
  lat(offset) {
    return this.la(offset).type;
  }
  test(type3, text) {
    const token = this.la(0);
    return token.type === type3 && (!text || token.text === text);
  }
  next() {
    if (this.index === this[LENGTH]) {
      return EOF_TOKEN;
    }
    const token = this[TOKENS][this.index];
    this.index++;
    return token;
  }
  nextIf(type3, text) {
    if (this.test(type3, text)) {
      return this.next();
    }
    return false;
  }
  expect(types, text = null, startToken = null) {
    const token = this.la(0);
    if (!Array.isArray(types)) {
      types = [types];
    }
    if (types.includes(token.type) && (!text || token.text === text)) {
      return this.next();
    }
    var type3 = types[0];
    var expectedStr = ERROR_TABLE[type3] || type3 || text;
    if (expectedStr != text) {
      expectedStr + "[" + text + "]";
    }
    var pos = token.pos;
    if (pos.line == -1 && startToken) {
      pos = startToken.pos;
    }
    this.error("Invalid Token", pos, `Expected ${expectedStr} but found ${ERROR_TABLE[token.type] || token.type || token.text} instead.`, token.length);
  }
  error(message, pos, advice, length = 1, metadata = {}) {
    let errorMessage = `ERROR: ${message}. `;
    if (advice) {
      errorMessage += advice;
    }
    const result = new Error(errorMessage + " 	 ");
    Object.assign(result, metadata);
    result.loc = {
      start: { line: Math.max(1, pos.line || 0), column: Math.max(0, pos.column || 0) + 1 },
      end: { line: Math.max(1, pos.line || 0) + 1, column: 1 }
    };
    throw result;
  }
};
__name(TokenStream, "TokenStream");
function getAllTokens(lexer, options2) {
  let token, tokens = [], acceptWhitespaceControl = false, trimNext = false;
  while ((token = lexer.next()) !== EOF_TOKEN) {
    const shouldTrimNext = trimNext;
    trimNext = false;
    if (acceptWhitespaceControl) {
      switch (token.type) {
        case EXPRESSION_START:
        case TAG_START:
          if (token.text[token.text.length - 1] === "-") {
            tokens[tokens.length - 1].text = (0, import_trimEnd.default)(tokens[tokens.length - 1].text);
          }
          break;
        case EXPRESSION_END:
        case TAG_END:
          if (token.text[0] === "-") {
            trimNext = true;
          }
          break;
        case COMMENT:
          if (tokens[tokens.length - 1].type === TEXT) {
            tokens[tokens.length - 1].text = (0, import_trimEnd.default)(tokens.text);
          }
          trimNext = true;
          break;
      }
    }
    if (shouldTrimNext && (token.type === TEXT || token.type === STRING)) {
      token.text = (0, import_trimStart.default)(token.text);
    }
    if ((token.type !== COMMENT || !options2.ignoreComments) && (token.type !== WHITESPACE || !options2.ignoreWhitespace) && (token.type !== HTML_COMMENT || !options2.ignoreHtmlComments)) {
      tokens[tokens.length] = token;
    }
    acceptWhitespaceControl = options2.applyWhitespaceTrimming;
    if (token.type === ERROR) {
      return tokens;
    }
  }
  return tokens;
}
__name(getAllTokens, "getAllTokens");

// src/melody-parser/src/CharStream.js
var EOF2 = Symbol();
var CharStream = class {
  constructor(input) {
    this.input = String(input);
    this.length = this.input.length;
    this.index = 0;
    this.position = { line: 1, column: 0 };
  }
  get source() {
    return this.input;
  }
  reset() {
    this.rewind({ line: 1, column: 0, index: 0 });
  }
  mark() {
    let { line: line2, column } = this.position, index = this.index;
    return { line: line2, column, index };
  }
  rewind(marker) {
    this.position.line = marker.line;
    this.position.column = marker.column;
    this.index = marker.index;
  }
  la(offset) {
    var index = this.index + offset;
    return index < this.length ? this.input.charAt(index) : EOF2;
  }
  lac(offset) {
    var index = this.index + offset;
    return index < this.length ? this.input.charCodeAt(index) : EOF2;
  }
  next() {
    if (this.index === this.length) {
      return EOF2;
    }
    var ch = this.input.charAt(this.index);
    this.index++;
    this.position.column++;
    if (ch === "\n") {
      this.position.line += 1;
      this.position.column = 0;
    }
    return ch;
  }
  match(str) {
    const start = this.mark();
    for (let i = 0, len = str.length; i < len; i++) {
      const ch = this.next();
      if (ch !== str.charAt(i) || ch === EOF2) {
        this.rewind(start);
        return false;
      }
    }
    return true;
  }
};
__name(CharStream, "CharStream");

// src/melody-parser/src/Lexer.js
var State = {
  TEXT: "TEXT",
  EXPRESSION: "EXPRESSION",
  TAG: "TAG",
  INTERPOLATION: "INTERPOLATION",
  STRING_SINGLE: "STRING_SINGLE",
  STRING_DOUBLE: "STRING_DOUBLE",
  ELEMENT: "ELEMENT",
  ATTRIBUTE_VALUE: "ATTRIBUTE_VALUE",
  DECLARATION: "DECLARATION"
};
var STATE = Symbol();
var OPERATORS = Symbol();
var STRING_START2 = Symbol();
var CHAR_TO_TOKEN = {
  "[": LBRACE,
  "]": RBRACE,
  "(": LPAREN,
  ")": RPAREN,
  "{": LBRACKET,
  "}": RBRACKET,
  ":": COLON,
  ".": DOT,
  "|": PIPE,
  ",": COMMA,
  "?": QUESTION_MARK,
  "=": ASSIGNMENT,
  "/": SLASH
};
var Lexer = class {
  constructor(input, { preserveSourceLiterally = false } = {}) {
    this.input = input;
    this[STATE] = [State.TEXT];
    this[OPERATORS] = [];
    this[STRING_START2] = null;
    this.options = {
      preserveSourceLiterally: preserveSourceLiterally === true ? true : false
    };
  }
  applyExtension(ext) {
    if (ext.unaryOperators) {
      this.addOperators(...ext.unaryOperators.map((op) => op.text));
    }
    if (ext.binaryOperators) {
      this.addOperators(...ext.binaryOperators.map((op) => op.text));
    }
  }
  reset() {
    this.input.reset();
    this[STATE] = [State.TEXT];
  }
  get source() {
    return this.input.source;
  }
  addOperators(...ops) {
    this[OPERATORS].push(...ops);
    this[OPERATORS].sort((a, b) => a.length > b.length ? -1 : 1);
  }
  get state() {
    return this[STATE][this[STATE].length - 1];
  }
  pushState(state) {
    this[STATE].push(state);
  }
  popState() {
    this[STATE].length--;
  }
  createToken(type3, pos) {
    let input = this.input, endPos = input.mark(), end = endPos.index;
    return {
      type: type3,
      pos,
      endPos,
      end,
      length: end - pos.index,
      source: input.input,
      text: input.input.substr(pos.index, end - pos.index),
      toString: function() {
        return this.text;
      }
    };
  }
  next() {
    let input = this.input, pos, c;
    while ((c = input.la(0)) !== EOF2) {
      pos = input.mark();
      if (this.state !== State.TEXT && this.state !== State.STRING_DOUBLE && this.state !== State.STRING_SINGLE && this.state !== State.ATTRIBUTE_VALUE && isWhitespace(c)) {
        input.next();
        while ((c = input.la(0)) !== EOF2 && isWhitespace(c)) {
          input.next();
        }
        return this.createToken(WHITESPACE, pos);
      }
      if (c === "{" && input.la(1) === "#") {
        input.next();
        input.next();
        if (input.la(0) === "-") {
          input.next();
        }
        while ((c = input.la(0)) !== EOF2) {
          if (c === "#" && input.la(1) === "}" || c === "-" && input.la(1) === "#" && input.la(2) === "}") {
            if (c === "-") {
              input.next();
            }
            input.next();
            input.next();
            return this.createToken(COMMENT, pos);
          }
          input.next();
        }
      }
      if (this.state === State.TEXT) {
        let entityToken;
        if (c === "<") {
          if (input.la(1) === "{" || isAlpha(input.lac(1)) || input.la(1) === "/") {
            input.next();
            this.pushState(State.ELEMENT);
            return this.createToken(ELEMENT_START, pos);
          } else if (input.la(1) === "!" && input.la(2) === "-" && input.la(3) === "-") {
            input.next();
            input.next();
            input.next();
            input.next();
            while ((c = input.la(0)) !== EOF2) {
              if (c === "-" && input.la(1) === "-") {
                input.next();
                input.next();
                if (!(c = input.next()) === ">") {
                  this.error("Unexpected end for HTML comment", input.mark(), `Expected comment to end with '>' but found '${c}' instead.`);
                }
                break;
              }
              input.next();
            }
            return this.createToken(HTML_COMMENT, pos);
          } else if (input.la(1) === "!" && (isAlpha(input.lac(2)) || isWhitespace(input.la(2)))) {
            input.next();
            input.next();
            this.pushState(State.DECLARATION);
            return this.createToken(DECLARATION_START, pos);
          } else {
            return this.matchText(pos);
          }
        } else if (c === "{") {
          return this.matchExpressionToken(pos);
        } else if (c === "&" && (entityToken = this.matchEntity(pos))) {
          return entityToken;
        } else {
          return this.matchText(pos);
        }
      } else if (this.state === State.EXPRESSION) {
        if (c === "}" && input.la(1) === "}" || c === "-" && input.la(1) === "}" && input.la(2) === "}") {
          if (c === "-") {
            input.next();
          }
          input.next();
          input.next();
          this.popState();
          return this.createToken(EXPRESSION_END, pos);
        }
        return this.matchExpression(pos);
      } else if (this.state === State.TAG) {
        if (c === "%" && input.la(1) === "}" || c === "-" && input.la(1) === "%" && input.la(2) === "}") {
          if (c === "-") {
            input.next();
          }
          input.next();
          input.next();
          this.popState();
          return this.createToken(TAG_END, pos);
        }
        return this.matchExpression(pos);
      } else if (this.state === State.STRING_SINGLE || this.state === State.STRING_DOUBLE) {
        return this.matchString(pos, true);
      } else if (this.state === State.INTERPOLATION) {
        if (c === "}") {
          input.next();
          this.popState();
          return this.createToken(INTERPOLATION_END, pos);
        }
        return this.matchExpression(pos);
      } else if (this.state === State.ELEMENT) {
        switch (c) {
          case "/":
            input.next();
            return this.createToken(SLASH, pos);
          case "{":
            return this.matchExpressionToken(pos);
          case ">":
            input.next();
            this.popState();
            return this.createToken(ELEMENT_END, pos);
          case '"':
            input.next();
            this.pushState(State.ATTRIBUTE_VALUE);
            return this.createToken(STRING_START, pos);
          case "=":
            input.next();
            return this.createToken(ASSIGNMENT, pos);
          default:
            return this.matchSymbol(pos);
        }
      } else if (this.state === State.ATTRIBUTE_VALUE) {
        if (c === '"') {
          input.next();
          this.popState();
          return this.createToken(STRING_END, pos);
        } else {
          return this.matchAttributeValue(pos);
        }
      } else if (this.state === State.DECLARATION) {
        switch (c) {
          case ">":
            input.next();
            this.popState();
            return this.createToken(ELEMENT_END, pos);
          case '"':
            input.next();
            this.pushState(State.STRING_DOUBLE);
            return this.createToken(STRING_START, pos);
          case "{":
            return this.matchExpressionToken(pos);
          default:
            return this.matchSymbol(pos);
        }
      } else {
        return this.error(`Invalid state ${this.state}`, pos);
      }
    }
    return EOF_TOKEN;
  }
  matchExpressionToken(pos) {
    const input = this.input;
    switch (input.la(1)) {
      case "{":
        input.next();
        input.next();
        this.pushState(State.EXPRESSION);
        if (input.la(0) === "-") {
          input.next();
        }
        return this.createToken(EXPRESSION_START, pos);
      case "%":
        input.next();
        input.next();
        this.pushState(State.TAG);
        if (input.la(0) === "-") {
          input.next();
        }
        return this.createToken(TAG_START, pos);
      case "#":
        input.next();
        input.next();
        if (input.la(0) === "-") {
          input.next();
        }
        return this.matchComment(pos);
      default:
        return this.matchText(pos);
    }
  }
  matchExpression(pos) {
    let input = this.input, c = input.la(0);
    switch (c) {
      case "'":
        this.pushState(State.STRING_SINGLE);
        input.next();
        return this.createToken(STRING_START, pos);
      case '"':
        this.pushState(State.STRING_DOUBLE);
        input.next();
        return this.createToken(STRING_START, pos);
      default: {
        if (isDigit(input.lac(0))) {
          input.next();
          return this.matchNumber(pos);
        }
        if (c === "t" && input.match("true") || c === "T" && input.match("TRUE")) {
          return this.createToken(TRUE, pos);
        }
        if (c === "f" && input.match("false") || c === "F" && input.match("FALSE")) {
          return this.createToken(FALSE, pos);
        }
        if (c === "n" && (input.match("null") || input.match("none")) || c === "N" && (input.match("NULL") || input.match("NONE"))) {
          return this.createToken(NULL, pos);
        }
        const {
          longestMatchingOperator,
          longestMatchEndPos
        } = this.findLongestMatchingOperator();
        const cc = input.lac(0);
        if (cc === 95 || isAlpha(cc) || isDigit(cc)) {
          input.next();
          const sym = this.matchSymbol(pos);
          if (sym.text.length <= longestMatchingOperator.length) {
            input.rewind(longestMatchEndPos);
            return this.createToken(OPERATOR, pos);
          }
          return sym;
        } else if (longestMatchingOperator) {
          input.rewind(longestMatchEndPos);
          return this.createToken(OPERATOR, pos);
        } else if (CHAR_TO_TOKEN.hasOwnProperty(c)) {
          input.next();
          return this.createToken(CHAR_TO_TOKEN[c], pos);
        } else if (c === "\xA0") {
          return this.error("Unsupported token: Non-breaking space", pos);
        } else {
          return this.error(`Unknown token ${c}`, pos);
        }
      }
    }
  }
  findLongestMatchingOperator() {
    const input = this.input, start = input.mark();
    let longestMatchingOperator = "", longestMatchEndPos = null;
    for (let i = 0, ops = this[OPERATORS], len = ops.length; i < len; i++) {
      const op = ops[i];
      if (op.length > longestMatchingOperator.length && input.match(op)) {
        const cc = input.lac(0);
        if (op.indexOf(" ") === -1 || !(isAlpha(cc) || isDigit(cc))) {
          longestMatchingOperator = op;
          longestMatchEndPos = input.mark();
        }
        input.rewind(start);
      }
    }
    input.rewind(start);
    return { longestMatchingOperator, longestMatchEndPos };
  }
  error(message, pos, advice = "") {
    const errorToken = this.createToken(ERROR, pos);
    errorToken.message = message;
    errorToken.advice = advice;
    return errorToken;
  }
  matchEntity(pos) {
    const input = this.input;
    input.next();
    if (input.la(0) === "#") {
      input.next();
      if (input.la(0) === "x") {
        input.next();
        let c = input.la(0);
        while ("a" <= c && c <= "f" || "A" <= c && c <= "F" || isDigit(input.lac(0))) {
          input.next();
          c = input.la(0);
        }
        if (input.la(0) === ";") {
          input.next();
        } else {
          input.rewind(pos);
          return null;
        }
      } else if (isDigit(input.lac(0))) {
        do {
          input.next();
        } while (isDigit(input.lac(0)));
        if (input.la(0) === ";") {
          input.next();
        } else {
          input.rewind(pos);
          return null;
        }
      } else {
        input.rewind(pos);
        return null;
      }
    } else {
      while (isAlpha(input.lac(0))) {
        input.next();
      }
      if (input.la(0) === ";") {
        input.next();
      } else {
        input.rewind(pos);
        return null;
      }
    }
    return this.createToken(ENTITY, pos);
  }
  matchSymbol(pos) {
    let input = this.input, inElement = this.state === State.ELEMENT, c;
    while ((c = input.lac(0)) && (c === 95 || isAlpha(c) || isDigit(c) || inElement && (c === 45 || c === 58))) {
      input.next();
    }
    var end = input.mark();
    if (pos.index === end.index) {
      return this.error("Expected an Identifier", pos, inElement ? `Expected a valid attribute name, but instead found "${input.la(0)}", which is not part of a valid attribute name.` : `Expected letter, digit or underscore but found ${input.la(0)} instead.`);
    }
    return this.createToken(SYMBOL, pos);
  }
  matchString(pos, allowInterpolation = true) {
    const input = this.input, start = this.state === State.STRING_SINGLE ? "'" : '"';
    let c;
    if (allowInterpolation && input.la(0) === "#" && input.la(1) === "{") {
      this.pushState(State.INTERPOLATION);
      input.next();
      input.next();
      return this.createToken(INTERPOLATION_START, pos);
    }
    if (input.la(0) === start) {
      input.next();
      this.popState();
      return this.createToken(STRING_END, pos);
    }
    while ((c = input.la(0)) !== start && c !== EOF2) {
      if (c === "\\" && input.la(1) === start) {
        input.next();
        input.next();
      } else if (allowInterpolation && c === "#" && input.la(1) === "{") {
        break;
      } else {
        input.next();
      }
    }
    var result = this.createToken(STRING, pos);
    if (!this.options.preserveSourceLiterally) {
      result.text = result.text.replace(new RegExp("(?:\\\\)(" + start + ")", "g"), "$1");
    }
    return result;
  }
  matchAttributeValue(pos) {
    let input = this.input, start = this.state === State.STRING_SINGLE ? "'" : '"', c;
    if (input.la(0) === "{") {
      return this.matchExpressionToken(pos);
    }
    while ((c = input.la(0)) !== start && c !== EOF2) {
      if (c === "\\" && input.la(1) === start) {
        input.next();
        input.next();
      } else if (c === "{") {
        break;
      } else if (c === start) {
        break;
      } else {
        input.next();
      }
    }
    var result = this.createToken(STRING, pos);
    if (!this.options.preserveSourceLiterally) {
      result.text = result.text.replace(new RegExp("(?:\\\\)(" + start + ")", "g"), "$1");
    }
    return result;
  }
  matchNumber(pos) {
    let input = this.input, c;
    while ((c = input.lac(0)) !== EOF2) {
      if (!isDigit(c)) {
        break;
      }
      input.next();
    }
    if (input.la(0) === "." && isDigit(input.lac(1))) {
      input.next();
      while ((c = input.lac(0)) !== EOF2) {
        if (!isDigit(c)) {
          break;
        }
        input.next();
      }
    }
    return this.createToken(NUMBER, pos);
  }
  matchText(pos) {
    let input = this.input, c;
    while ((c = input.la(0)) && c !== EOF2) {
      if (c === "{") {
        const c2 = input.la(1);
        if (c2 === "{" || c2 === "#" || c2 === "%") {
          break;
        }
      } else if (c === "<") {
        const nextChar = input.la(1);
        if (nextChar === "/" || nextChar === "!" || isAlpha(input.lac(1))) {
          break;
        } else if (input.la(1) === "{") {
          const c2 = input.la(1);
          if (c2 === "{" || c2 === "#" || c2 === "%") {
            break;
          }
        }
      }
      input.next();
    }
    return this.createToken(TEXT, pos);
  }
  matchComment(pos) {
    let input = this.input, c;
    while ((c = input.next()) !== EOF2) {
      if (c === "#" && input.la(0) === "}") {
        input.next();
        break;
      }
    }
    return this.createToken(COMMENT, pos);
  }
};
__name(Lexer, "Lexer");
function isWhitespace(c) {
  return c === "\n" || c === " " || c === "	";
}
__name(isWhitespace, "isWhitespace");
function isAlpha(c) {
  return 65 <= c && c <= 90 || 97 <= c && c <= 122;
}
__name(isAlpha, "isAlpha");
function isDigit(c) {
  return 48 <= c && c <= 57;
}
__name(isDigit, "isDigit");

// src/melody-extension-core/src/operators.js
var unaryOperators = [];
var binaryOperators = [];
var tests = [];
var UnaryNotExpression = createUnaryOperator("not", "UnaryNotExpression", 50);
var UnaryNeqExpression = createUnaryOperator("-", "UnaryNeqExpression", 500);
var UnaryPosExpression = createUnaryOperator("+", "UnaryPosExpression", 500);
var BinaryOrExpression = createBinaryOperatorNode({
  text: "or",
  type: "BinaryOrExpression",
  precedence: 10,
  associativity: LEFT
});
var BinaryAndExpression = createBinaryOperatorNode({
  text: "and",
  type: "BinaryAndExpression",
  precedence: 15,
  associativity: LEFT
});
var BitwiseOrExpression = createBinaryOperatorNode({
  text: "b-or",
  type: "BitwiseOrExpression",
  precedence: 16,
  associativity: LEFT
});
var BitwiseXorExpression = createBinaryOperatorNode({
  text: "b-xor",
  type: "BitwiseXOrExpression",
  precedence: 17,
  associativity: LEFT
});
var BitwiseAndExpression = createBinaryOperatorNode({
  text: "b-and",
  type: "BitwiseAndExpression",
  precedence: 18,
  associativity: LEFT
});
var BinaryEqualsExpression = createBinaryOperatorNode({
  text: "==",
  type: "BinaryEqualsExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryNotEqualsExpression = createBinaryOperatorNode({
  text: "!=",
  type: "BinaryNotEqualsExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryLessThanExpression = createBinaryOperatorNode({
  text: "<",
  type: "BinaryLessThanExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryGreaterThanExpression = createBinaryOperatorNode({
  text: ">",
  type: "BinaryGreaterThanExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryLessThanOrEqualExpression = createBinaryOperatorNode({
  text: "<=",
  type: "BinaryLessThanOrEqualExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryGreaterThanOrEqualExpression = createBinaryOperatorNode({
  text: ">=",
  type: "BinaryGreaterThanOrEqualExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryNotInExpression = createBinaryOperatorNode({
  text: "not in",
  type: "BinaryNotInExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryInExpression = createBinaryOperatorNode({
  text: "in",
  type: "BinaryInExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryMatchesExpression = createBinaryOperatorNode({
  text: "matches",
  type: "BinaryMatchesExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryStartsWithExpression = createBinaryOperatorNode({
  text: "starts with",
  type: "BinaryStartsWithExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryEndsWithExpression = createBinaryOperatorNode({
  text: "ends with",
  type: "BinaryEndsWithExpression",
  precedence: 20,
  associativity: LEFT
});
var BinaryRangeExpression = createBinaryOperatorNode({
  text: "..",
  type: "BinaryRangeExpression",
  precedence: 25,
  associativity: LEFT
});
var BinaryAddExpression = createBinaryOperatorNode({
  text: "+",
  type: "BinaryAddExpression",
  precedence: 30,
  associativity: LEFT
});
var BinarySubExpression = createBinaryOperatorNode({
  text: "-",
  type: "BinarySubExpression",
  precedence: 30,
  associativity: LEFT
});
binaryOperators.push({
  text: "~",
  precedence: 40,
  associativity: LEFT,
  createNode(token, lhs, rhs) {
    const op = new import_melody_types3.BinaryConcatExpression(lhs, rhs);
    copyStart(op, lhs);
    copyEnd(op, rhs);
    return op;
  }
});
var BinaryMulExpression = createBinaryOperatorNode({
  text: "*",
  type: "BinaryMulExpression",
  precedence: 60,
  associativity: LEFT
});
var BinaryDivExpression = createBinaryOperatorNode({
  text: "/",
  type: "BinaryDivExpression",
  precedence: 60,
  associativity: LEFT
});
var BinaryFloorDivExpression = createBinaryOperatorNode({
  text: "//",
  type: "BinaryFloorDivExpression",
  precedence: 60,
  associativity: LEFT
});
var BinaryModExpression = createBinaryOperatorNode({
  text: "%",
  type: "BinaryModExpression",
  precedence: 60,
  associativity: LEFT
});
binaryOperators.push({
  text: "is",
  precedence: 100,
  associativity: LEFT,
  parse(parser, token, expr) {
    const tokens = parser.tokens;
    let not = false;
    if (tokens.nextIf(TokenTypes_exports.OPERATOR, "not")) {
      not = true;
    }
    const test = getTest(parser);
    let args = null;
    if (tokens.test(TokenTypes_exports.LPAREN)) {
      args = parser.matchArguments();
    }
    const testExpression = test.createNode(expr, args);
    setStartFromToken(testExpression, token);
    setEndFromToken(testExpression, tokens.la(-1));
    if (not) {
      return copyLoc(new UnaryNotExpression(testExpression), testExpression);
    }
    return testExpression;
  }
});
function getTest(parser) {
  const tokens = parser.tokens;
  const nameToken = tokens.la(0);
  if (nameToken.type !== TokenTypes_exports.NULL) {
    tokens.expect(TokenTypes_exports.SYMBOL);
  } else {
    tokens.next();
  }
  let testName = nameToken.text;
  if (!parser.hasTest(testName)) {
    const continuedNameToken = tokens.expect(TokenTypes_exports.SYMBOL);
    testName += " " + continuedNameToken.text;
    if (!parser.hasTest(testName)) {
      parser.error({
        title: `Unknown test "${testName}"`,
        pos: nameToken.pos
      });
    }
  }
  return parser.getTest(testName);
}
__name(getTest, "getTest");
var BinaryPowerExpression = createBinaryOperatorNode({
  text: "**",
  type: "BinaryPowerExpression",
  precedence: 200,
  associativity: LEFT
});
var BinaryNullCoalesceExpression = createBinaryOperatorNode({
  text: "??",
  type: "BinaryNullCoalesceExpression",
  precedence: 300,
  associativity: LEFT
});
var TestEvenExpression = createTest("even", "TestEvenExpression");
var TestOddExpression = createTest("odd", "TestOddExpression");
var TestDefinedExpression = createTest("defined", "TestDefinedExpression");
var TestSameAsExpression = createTest("same as", "TestSameAsExpression");
tests.push({
  text: "sameas",
  createNode(expr, args) {
    return new TestSameAsExpression(expr, args);
  }
});
var TestNullExpression = createTest("null", "TestNullExpression");
tests.push({
  text: "none",
  createNode(expr, args) {
    return new TestNullExpression(expr, args);
  }
});
var TestDivisibleByExpression = createTest("divisible by", "TestDivisibleByExpression");
tests.push({
  text: "divisibleby",
  createNode(expr, args) {
    return new TestDivisibleByExpression(expr, args);
  }
});
var TestConstantExpression = createTest("constant", "TestConstantExpression");
var TestEmptyExpression = createTest("empty", "TestEmptyExpression");
var TestIterableExpression = createTest("iterable", "TestIterableExpression");
function createTest(text, typeName) {
  const TestExpression = /* @__PURE__ */ __name(class extends import_melody_types3.Node {
    constructor(expr, args) {
      super();
      this.expression = expr;
      this.arguments = args;
    }
  }, "TestExpression");
  (0, import_melody_types3.type)(TestExpression, typeName);
  (0, import_melody_types3.alias)(TestExpression, "Expression", "TestExpression");
  (0, import_melody_types3.visitor)(TestExpression, "expression", "arguments");
  tests.push({
    text,
    createNode(expr, args) {
      return new TestExpression(expr, args);
    }
  });
  return TestExpression;
}
__name(createTest, "createTest");
function createBinaryOperatorNode(options2) {
  const { text, precedence, associativity } = options2;
  const BinarySubclass = /* @__PURE__ */ __name(class extends import_melody_types3.BinaryExpression {
    constructor(left, right) {
      super(text, left, right);
    }
  }, "BinarySubclass");
  (0, import_melody_types3.type)(BinarySubclass, options2.type);
  (0, import_melody_types3.alias)(BinarySubclass, "BinaryExpression", "Binary", "Expression");
  (0, import_melody_types3.visitor)(BinarySubclass, "left", "right");
  const operator = {
    text,
    precedence,
    associativity
  };
  if (options2.parse) {
    operator.parse = options2.parse;
  } else if (options2.createNode) {
    operator.createNode = options2.createNode;
  } else {
    operator.createNode = (token, lhs, rhs) => new BinarySubclass(lhs, rhs);
  }
  binaryOperators.push(operator);
  return BinarySubclass;
}
__name(createBinaryOperatorNode, "createBinaryOperatorNode");
function createUnaryOperator(operator, typeName, precedence) {
  const UnarySubclass = /* @__PURE__ */ __name(class extends import_melody_types3.UnaryExpression {
    constructor(argument) {
      super(operator, argument);
    }
  }, "UnarySubclass");
  (0, import_melody_types3.type)(UnarySubclass, typeName);
  (0, import_melody_types3.alias)(UnarySubclass, "Expression", "UnaryLike");
  (0, import_melody_types3.visitor)(UnarySubclass, "argument");
  unaryOperators.push({
    text: operator,
    precedence,
    createNode(token, expr) {
      const op = new UnarySubclass(expr);
      setStartFromToken(op, token);
      copyEnd(op, expr);
      return op;
    }
  });
  return UnarySubclass;
}
__name(createUnaryOperator, "createUnaryOperator");

// src/melody-extension-core/src/types.js
var import_melody_types4 = __toESM(require_lib2());
var AutoescapeBlock = class extends import_melody_types4.Node {
  constructor(type3, expressions) {
    super();
    this.escapeType = type3;
    this.expressions = expressions;
  }
};
__name(AutoescapeBlock, "AutoescapeBlock");
(0, import_melody_types4.type)(AutoescapeBlock, "AutoescapeBlock");
(0, import_melody_types4.alias)(AutoescapeBlock, "Block", "Escape");
(0, import_melody_types4.visitor)(AutoescapeBlock, "expressions");
var BlockStatement = class extends import_melody_types4.Node {
  constructor(name, body) {
    super();
    this.name = name;
    this.body = body;
  }
};
__name(BlockStatement, "BlockStatement");
(0, import_melody_types4.type)(BlockStatement, "BlockStatement");
(0, import_melody_types4.alias)(BlockStatement, "Statement", "Scope", "RootScope");
(0, import_melody_types4.visitor)(BlockStatement, "body");
var BlockCallExpression = class extends import_melody_types4.Node {
  constructor(callee, args = []) {
    super();
    this.callee = callee;
    this.arguments = args;
  }
};
__name(BlockCallExpression, "BlockCallExpression");
(0, import_melody_types4.type)(BlockCallExpression, "BlockCallExpression");
(0, import_melody_types4.alias)(BlockCallExpression, "Expression", "FunctionInvocation");
(0, import_melody_types4.visitor)(BlockCallExpression, "arguments");
var MountStatement = class extends import_melody_types4.Node {
  constructor(name, source, key, argument, async, delayBy) {
    super();
    this.name = name;
    this.source = source;
    this.key = key;
    this.argument = argument;
    this.async = async;
    this.delayBy = delayBy;
    this.errorVariableName = null;
    this.body = null;
    this.otherwise = null;
  }
};
__name(MountStatement, "MountStatement");
(0, import_melody_types4.type)(MountStatement, "MountStatement");
(0, import_melody_types4.alias)(MountStatement, "Statement", "Scope");
(0, import_melody_types4.visitor)(MountStatement, "name", "source", "key", "argument", "body", "otherwise");
var DoStatement = class extends import_melody_types4.Node {
  constructor(expression) {
    super();
    this.value = expression;
  }
};
__name(DoStatement, "DoStatement");
(0, import_melody_types4.type)(DoStatement, "DoStatement");
(0, import_melody_types4.alias)(DoStatement, "Statement");
(0, import_melody_types4.visitor)(DoStatement, "value");
var EmbedStatement = class extends import_melody_types4.Node {
  constructor(parent) {
    super();
    this.parent = parent;
    this.argument = null;
    this.contextFree = false;
    this.ignoreMissing = false;
    this.blocks = null;
  }
};
__name(EmbedStatement, "EmbedStatement");
(0, import_melody_types4.type)(EmbedStatement, "EmbedStatement");
(0, import_melody_types4.alias)(EmbedStatement, "Statement", "Include");
(0, import_melody_types4.visitor)(EmbedStatement, "argument", "blocks");
var ExtendsStatement = class extends import_melody_types4.Node {
  constructor(parentName) {
    super();
    this.parentName = parentName;
  }
};
__name(ExtendsStatement, "ExtendsStatement");
(0, import_melody_types4.type)(ExtendsStatement, "ExtendsStatement");
(0, import_melody_types4.alias)(ExtendsStatement, "Statement", "Include");
(0, import_melody_types4.visitor)(ExtendsStatement, "parentName");
var FilterBlockStatement = class extends import_melody_types4.Node {
  constructor(filterExpression, body) {
    super();
    this.filterExpression = filterExpression;
    this.body = body;
  }
};
__name(FilterBlockStatement, "FilterBlockStatement");
(0, import_melody_types4.type)(FilterBlockStatement, "FilterBlockStatement");
(0, import_melody_types4.alias)(FilterBlockStatement, "Statement", "Block");
(0, import_melody_types4.visitor)(FilterBlockStatement, "filterExpression", "body");
var FlushStatement = class extends import_melody_types4.Node {
  constructor() {
    super();
  }
};
__name(FlushStatement, "FlushStatement");
(0, import_melody_types4.type)(FlushStatement, "FlushStatement");
(0, import_melody_types4.alias)(FlushStatement, "Statement");
var ForStatement = class extends import_melody_types4.Node {
  constructor(keyTarget = null, valueTarget = null, sequence = null, condition = null, body = null, otherwise = null) {
    super();
    this.keyTarget = keyTarget;
    this.valueTarget = valueTarget;
    this.sequence = sequence;
    this.condition = condition;
    this.body = body;
    this.otherwise = otherwise;
  }
};
__name(ForStatement, "ForStatement");
(0, import_melody_types4.type)(ForStatement, "ForStatement");
(0, import_melody_types4.alias)(ForStatement, "Statement", "Scope", "Loop");
(0, import_melody_types4.visitor)(ForStatement, "keyTarget", "valueTarget", "sequence", "condition", "body", "otherwise");
var ImportDeclaration = class extends import_melody_types4.Node {
  constructor(key, alias3) {
    super();
    this.key = key;
    this.alias = alias3;
  }
};
__name(ImportDeclaration, "ImportDeclaration");
(0, import_melody_types4.type)(ImportDeclaration, "ImportDeclaration");
(0, import_melody_types4.alias)(ImportDeclaration, "VariableDeclaration");
(0, import_melody_types4.visitor)(ImportDeclaration, "key", "value");
var FromStatement = class extends import_melody_types4.Node {
  constructor(source, imports) {
    super();
    this.source = source;
    this.imports = imports;
  }
};
__name(FromStatement, "FromStatement");
(0, import_melody_types4.type)(FromStatement, "FromStatement");
(0, import_melody_types4.alias)(FromStatement, "Statement");
(0, import_melody_types4.visitor)(FromStatement, "source", "imports");
var IfStatement = class extends import_melody_types4.Node {
  constructor(test, consequent = null, alternate = null) {
    super();
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  }
};
__name(IfStatement, "IfStatement");
(0, import_melody_types4.type)(IfStatement, "IfStatement");
(0, import_melody_types4.alias)(IfStatement, "Statement", "Conditional");
(0, import_melody_types4.visitor)(IfStatement, "test", "consequent", "alternate");
var IncludeStatement = class extends import_melody_types4.Node {
  constructor(source) {
    super();
    this.source = source;
    this.argument = null;
    this.contextFree = false;
    this.ignoreMissing = false;
  }
};
__name(IncludeStatement, "IncludeStatement");
(0, import_melody_types4.type)(IncludeStatement, "IncludeStatement");
(0, import_melody_types4.alias)(IncludeStatement, "Statement", "Include");
(0, import_melody_types4.visitor)(IncludeStatement, "source", "argument");
var MacroDeclarationStatement = class extends import_melody_types4.Node {
  constructor(name, args, body) {
    super();
    this.name = name;
    this.arguments = args;
    this.body = body;
  }
};
__name(MacroDeclarationStatement, "MacroDeclarationStatement");
(0, import_melody_types4.type)(MacroDeclarationStatement, "MacroDeclarationStatement");
(0, import_melody_types4.alias)(MacroDeclarationStatement, "Statement", "Scope", "RootScope");
(0, import_melody_types4.visitor)(MacroDeclarationStatement, "name", "arguments", "body");
var VariableDeclarationStatement = class extends import_melody_types4.Node {
  constructor(name, value) {
    super();
    this.name = name;
    this.value = value;
  }
};
__name(VariableDeclarationStatement, "VariableDeclarationStatement");
(0, import_melody_types4.type)(VariableDeclarationStatement, "VariableDeclarationStatement");
(0, import_melody_types4.alias)(VariableDeclarationStatement, "Statement");
(0, import_melody_types4.visitor)(VariableDeclarationStatement, "name", "value");
var SetStatement = class extends import_melody_types4.Node {
  constructor(assignments) {
    super();
    this.assignments = assignments;
  }
};
__name(SetStatement, "SetStatement");
(0, import_melody_types4.type)(SetStatement, "SetStatement");
(0, import_melody_types4.alias)(SetStatement, "Statement", "ContextMutation");
(0, import_melody_types4.visitor)(SetStatement, "assignments");
var SpacelessBlock = class extends import_melody_types4.Node {
  constructor(body = null) {
    super();
    this.body = body;
  }
};
__name(SpacelessBlock, "SpacelessBlock");
(0, import_melody_types4.type)(SpacelessBlock, "SpacelessBlock");
(0, import_melody_types4.alias)(SpacelessBlock, "Statement", "Block");
(0, import_melody_types4.visitor)(SpacelessBlock, "body");
var AliasExpression = class extends import_melody_types4.Node {
  constructor(name, alias3) {
    super();
    this.name = name;
    this.alias = alias3;
  }
};
__name(AliasExpression, "AliasExpression");
(0, import_melody_types4.type)(AliasExpression, "AliasExpression");
(0, import_melody_types4.alias)(AliasExpression, "Expression");
(0, import_melody_types4.visitor)(AliasExpression, "name", "alias");
var UseStatement = class extends import_melody_types4.Node {
  constructor(source, aliases) {
    super();
    this.source = source;
    this.aliases = aliases;
  }
};
__name(UseStatement, "UseStatement");
(0, import_melody_types4.type)(UseStatement, "UseStatement");
(0, import_melody_types4.alias)(UseStatement, "Statement", "Include");
(0, import_melody_types4.visitor)(UseStatement, "source", "aliases");

// src/melody-extension-core/src/parser/autoescape.js
var AutoescapeParser = {
  name: "autoescape",
  parse(parser, token) {
    const tokens = parser.tokens;
    const tagStartToken = tokens.la(-2);
    let escapeType = null, stringStartToken, openingTagEndToken, closingTagStartToken;
    if (tokens.nextIf(TokenTypes_exports.TAG_END)) {
      openingTagEndToken = tokens.la(-1);
      escapeType = null;
    } else if (stringStartToken = tokens.nextIf(TokenTypes_exports.STRING_START)) {
      escapeType = tokens.expect(TokenTypes_exports.STRING).text;
      if (!tokens.nextIf(TokenTypes_exports.STRING_END)) {
        parser.error({
          title: "autoescape type declaration must be a simple string",
          pos: tokens.la(0).pos,
          advice: `The type declaration for autoescape must be a simple string such as 'html' or 'js'.
I expected the current string to end with a ${stringStartToken.text} but instead found ${TokenTypes_exports.ERROR_TABLE[tokens.lat(0)] || tokens.lat(0)}.`
        });
      }
      openingTagEndToken = tokens.la(0);
    } else if (tokens.nextIf(TokenTypes_exports.FALSE)) {
      escapeType = false;
      openingTagEndToken = tokens.la(0);
    } else if (tokens.nextIf(TokenTypes_exports.TRUE)) {
      escapeType = true;
      openingTagEndToken = tokens.la(0);
    } else {
      parser.error({
        title: "Invalid autoescape type declaration",
        pos: tokens.la(0).pos,
        advice: `Expected type of autoescape to be a string, boolean or not specified. Found ${tokens.la(0).type} instead.`
      });
    }
    const autoescape = new AutoescapeBlock(escapeType);
    setStartFromToken(autoescape, token);
    let tagEndToken;
    autoescape.expressions = parser.parse((_, token2, tokens2) => {
      if (token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endautoescape")) {
        closingTagStartToken = token2;
        tagEndToken = tokens2.expect(TokenTypes_exports.TAG_END, "", tagStartToken);
        return true;
      }
      return false;
    }).expressions;
    setEndFromToken(autoescape, tagEndToken);
    autoescape.trimRightAutoescape = hasTagEndTokenTrimRight(openingTagEndToken);
    autoescape.trimLeftEndautoescape = hasTagStartTokenTrimLeft(closingTagStartToken);
    return autoescape;
  }
};

// src/melody-extension-core/src/parser/block.js
var import_melody_types5 = __toESM(require_lib2());
var BlockParser = {
  name: "block",
  parse(parser, token) {
    const tokens = parser.tokens, tagStartToken = tokens.la(-2), nameToken = tokens.expect(TokenTypes_exports.SYMBOL);
    let blockStatement2, openingTagEndToken, closingTagStartToken;
    if (openingTagEndToken = tokens.nextIf(TokenTypes_exports.TAG_END)) {
      blockStatement2 = new BlockStatement(createNode(import_melody_types5.Identifier, nameToken, nameToken.text), parser.parse((tokenText, token2, tokens2) => {
        const result = !!(token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endblock"));
        if (result) {
          closingTagStartToken = token2;
        }
        return result;
      }).expressions);
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, nameToken.text)) {
        if (tokens.lat(0) !== TokenTypes_exports.TAG_END) {
          const unexpectedToken = tokens.next();
          parser.error({
            title: "Block name mismatch",
            pos: unexpectedToken.pos,
            advice: unexpectedToken.type == TokenTypes_exports.SYMBOL ? `Expected end of block ${nameToken.text} but instead found end of block ${tokens.la(0).text}.` : `endblock must be followed by either '%}' or the name of the open block. Found a token of type ${TokenTypes_exports.ERROR_TABLE[unexpectedToken.type] || unexpectedToken.type} instead.`
          });
        }
      }
    } else {
      blockStatement2 = new BlockStatement(createNode(import_melody_types5.Identifier, nameToken, nameToken.text), new import_melody_types5.PrintExpressionStatement(parser.matchExpression()));
    }
    setStartFromToken(blockStatement2, token);
    setEndFromToken(blockStatement2, tokens.expect(TokenTypes_exports.TAG_END, null, tagStartToken));
    blockStatement2.trimRightBlock = openingTagEndToken && hasTagEndTokenTrimRight(openingTagEndToken);
    blockStatement2.trimLeftEndblock = !!(closingTagStartToken && hasTagStartTokenTrimLeft(closingTagStartToken));
    return blockStatement2;
  }
};

// src/melody-extension-core/src/parser/do.js
var DoParser = {
  name: "do",
  parse(parser, token) {
    const tokens = parser.tokens, tagStartToken = tokens.la(-2), doStatement = new DoStatement(parser.matchExpression());
    setStartFromToken(doStatement, token);
    setEndFromToken(doStatement, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    return doStatement;
  }
};

// src/melody-extension-core/src/parser/embed.js
var import_melody_types6 = __toESM(require_lib2());
var import_filter = __toESM(require_filter());
var EmbedParser = {
  name: "embed",
  parse(parser, token) {
    const tokens = parser.tokens;
    const tagStartToken = tokens.la(-2);
    const embedStatement = new EmbedStatement(parser.matchExpression());
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "ignore")) {
      tokens.expect(TokenTypes_exports.SYMBOL, "missing");
      embedStatement.ignoreMissing = true;
    }
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "with")) {
      embedStatement.argument = parser.matchExpression();
    }
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "only")) {
      embedStatement.contextFree = true;
    }
    tokens.expect(TokenTypes_exports.TAG_END);
    const openingTagEndToken = tokens.la(-1);
    let closingTagStartToken;
    embedStatement.blocks = (0, import_filter.default)(parser.parse((tokenText, token2, tokens2) => {
      const result = !!(token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endembed"));
      if (result) {
        closingTagStartToken = token2;
      }
      return result;
    }).expressions, import_melody_types6.Node.isBlockStatement);
    setStartFromToken(embedStatement, token);
    setEndFromToken(embedStatement, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    embedStatement.trimRightEmbed = hasTagEndTokenTrimRight(openingTagEndToken);
    embedStatement.trimLeftEndembed = closingTagStartToken && hasTagStartTokenTrimLeft(closingTagStartToken);
    return embedStatement;
  }
};

// src/melody-extension-core/src/parser/extends.js
var ExtendsParser = {
  name: "extends",
  parse(parser, token) {
    const tokens = parser.tokens;
    const extendsStatement = new ExtendsStatement(parser.matchExpression());
    setStartFromToken(extendsStatement, token);
    setEndFromToken(extendsStatement, tokens.expect(TokenTypes_exports.TAG_END));
    return extendsStatement;
  }
};

// src/melody-extension-core/src/parser/filter.js
var import_melody_types7 = __toESM(require_lib2());
var FilterParser = {
  name: "filter",
  parse(parser, token) {
    const tokens = parser.tokens, tagStartToken = tokens.la(-2), ref = createNode(import_melody_types7.Identifier, token, "filter"), filterExpression = parser.matchFilterExpression(ref);
    tokens.expect(TokenTypes_exports.TAG_END);
    const openingTagEndToken = tokens.la(-1);
    let closingTagStartToken;
    const body = parser.parse((text, token2, tokens2) => {
      const result = token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endfilter");
      if (result) {
        closingTagStartToken = token2;
      }
      return result;
    }).expressions;
    const filterBlockStatement = new FilterBlockStatement(filterExpression, body);
    setStartFromToken(filterBlockStatement, token);
    setEndFromToken(filterBlockStatement, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    filterBlockStatement.trimRightFilter = hasTagEndTokenTrimRight(openingTagEndToken);
    filterBlockStatement.trimLeftEndfilter = closingTagStartToken && hasTagStartTokenTrimLeft(closingTagStartToken);
    return filterBlockStatement;
  }
};

// src/melody-extension-core/src/parser/flush.js
var FlushParser = {
  name: "flush",
  parse(parser, token) {
    const tokens = parser.tokens, flushStatement = new FlushStatement();
    setStartFromToken(flushStatement, token);
    setEndFromToken(flushStatement, tokens.expect(TokenTypes_exports.TAG_END));
    return flushStatement;
  }
};

// src/melody-extension-core/src/parser/for.js
var import_melody_types8 = __toESM(require_lib2());
var ForParser = {
  name: "for",
  parse(parser, token) {
    const tokens = parser.tokens, forStatement = new ForStatement(), tagStartToken = tokens.la(-2);
    const keyTarget = tokens.expect(TokenTypes_exports.SYMBOL);
    if (tokens.nextIf(TokenTypes_exports.COMMA)) {
      forStatement.keyTarget = createNode(import_melody_types8.Identifier, keyTarget, keyTarget.text);
      const valueTarget = tokens.expect(TokenTypes_exports.SYMBOL);
      forStatement.valueTarget = createNode(import_melody_types8.Identifier, valueTarget, valueTarget.text);
    } else {
      forStatement.keyTarget = null;
      forStatement.valueTarget = createNode(import_melody_types8.Identifier, keyTarget, keyTarget.text);
    }
    tokens.expect(TokenTypes_exports.OPERATOR, "in");
    forStatement.sequence = parser.matchExpression();
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "if")) {
      forStatement.condition = parser.matchExpression();
    }
    tokens.expect(TokenTypes_exports.TAG_END);
    const openingTagEndToken = tokens.la(-1);
    let elseTagStartToken, elseTagEndToken;
    forStatement.body = parser.parse((tokenText, token2, tokens2) => {
      const result = token2.type === TokenTypes_exports.TAG_START && (tokens2.test(TokenTypes_exports.SYMBOL, "else") || tokens2.test(TokenTypes_exports.SYMBOL, "endfor"));
      if (result && tokens2.test(TokenTypes_exports.SYMBOL, "else")) {
        elseTagStartToken = token2;
      }
      return result;
    });
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "else")) {
      tokens.expect(TokenTypes_exports.TAG_END);
      elseTagEndToken = tokens.la(-1);
      forStatement.otherwise = parser.parse((tokenText, token2, tokens2) => {
        return token2.type === TokenTypes_exports.TAG_START && tokens2.test(TokenTypes_exports.SYMBOL, "endfor");
      });
    }
    const endforTagStartToken = tokens.la(-1);
    tokens.expect(TokenTypes_exports.SYMBOL, "endfor", tagStartToken);
    setStartFromToken(forStatement, token);
    setEndFromToken(forStatement, tokens.expect(TokenTypes_exports.TAG_END));
    forStatement.trimRightFor = hasTagEndTokenTrimRight(openingTagEndToken);
    forStatement.trimLeftElse = !!(elseTagStartToken && hasTagStartTokenTrimLeft(elseTagStartToken));
    forStatement.trimRightElse = !!(elseTagEndToken && hasTagEndTokenTrimRight(elseTagEndToken));
    forStatement.trimLeftEndfor = hasTagStartTokenTrimLeft(endforTagStartToken);
    return forStatement;
  }
};

// src/melody-extension-core/src/parser/from.js
var import_melody_types9 = __toESM(require_lib2());
var FromParser = {
  name: "from",
  parse(parser, token) {
    const tokens = parser.tokens, source = parser.matchExpression(), imports = [];
    tokens.expect(TokenTypes_exports.SYMBOL, "import");
    do {
      const name = tokens.expect(TokenTypes_exports.SYMBOL);
      let alias3 = name;
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, "as")) {
        alias3 = tokens.expect(TokenTypes_exports.SYMBOL);
      }
      const importDeclaration2 = new ImportDeclaration(createNode(import_melody_types9.Identifier, name, name.text), createNode(import_melody_types9.Identifier, alias3, alias3.text));
      setStartFromToken(importDeclaration2, name);
      setEndFromToken(importDeclaration2, alias3);
      imports.push(importDeclaration2);
      if (!tokens.nextIf(TokenTypes_exports.COMMA)) {
        break;
      }
    } while (!tokens.test(TokenTypes_exports.EOF));
    const fromStatement = new FromStatement(source, imports);
    setStartFromToken(fromStatement, token);
    setEndFromToken(fromStatement, tokens.expect(TokenTypes_exports.TAG_END));
    return fromStatement;
  }
};

// src/melody-extension-core/src/parser/if.js
var IfParser = {
  name: "if",
  parse(parser, token) {
    const tokens = parser.tokens;
    const tagStartToken = tokens.la(-2);
    let test = parser.matchExpression(), alternate = null;
    tokens.expect(TokenTypes_exports.TAG_END);
    const ifTagEndToken = tokens.la(-1);
    const ifStatement2 = new IfStatement(test, parser.parse(matchConsequent).expressions);
    let elseTagStartToken, elseTagEndToken, elseifTagStartToken, elseifTagEndToken;
    do {
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, "else")) {
        elseTagStartToken = tokens.la(-2);
        tokens.expect(TokenTypes_exports.TAG_END);
        elseTagEndToken = tokens.la(-1);
        (alternate || ifStatement2).alternate = parser.parse(matchAlternate).expressions;
      } else if (tokens.nextIf(TokenTypes_exports.SYMBOL, "elseif")) {
        elseifTagStartToken = tokens.la(-2);
        test = parser.matchExpression();
        tokens.expect(TokenTypes_exports.TAG_END);
        elseifTagEndToken = tokens.la(-1);
        const consequent = parser.parse(matchConsequent).expressions;
        alternate = (alternate || ifStatement2).alternate = new IfStatement(test, consequent);
        alternate.trimLeft = hasTagStartTokenTrimLeft(elseifTagStartToken);
        alternate.trimRightIf = hasTagEndTokenTrimRight(elseifTagEndToken);
      }
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, "endif")) {
        break;
      }
    } while (!tokens.test(TokenTypes_exports.EOF));
    const endifTagStartToken = tokens.la(-2);
    setStartFromToken(ifStatement2, token);
    setEndFromToken(ifStatement2, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    ifStatement2.trimRightIf = hasTagEndTokenTrimRight(ifTagEndToken);
    ifStatement2.trimLeftElse = !!(elseTagStartToken && hasTagStartTokenTrimLeft(elseTagStartToken));
    ifStatement2.trimRightElse = !!(elseTagEndToken && hasTagEndTokenTrimRight(elseTagEndToken));
    ifStatement2.trimLeftEndif = hasTagStartTokenTrimLeft(endifTagStartToken);
    return ifStatement2;
  }
};
function matchConsequent(tokenText, token, tokens) {
  if (token.type === TokenTypes_exports.TAG_START) {
    const next = tokens.la(0).text;
    return next === "else" || next === "endif" || next === "elseif";
  }
  return false;
}
__name(matchConsequent, "matchConsequent");
function matchAlternate(tokenText, token, tokens) {
  return token.type === TokenTypes_exports.TAG_START && tokens.test(TokenTypes_exports.SYMBOL, "endif");
}
__name(matchAlternate, "matchAlternate");

// src/melody-extension-core/src/parser/import.js
var import_melody_types10 = __toESM(require_lib2());
var ImportParser = {
  name: "import",
  parse(parser, token) {
    const tokens = parser.tokens, source = parser.matchExpression();
    tokens.expect(TokenTypes_exports.SYMBOL, "as");
    const alias3 = tokens.expect(TokenTypes_exports.SYMBOL);
    const importStatement = new ImportDeclaration(source, createNode(import_melody_types10.Identifier, alias3, alias3.text));
    setStartFromToken(importStatement, token);
    setEndFromToken(importStatement, tokens.expect(TokenTypes_exports.TAG_END));
    return importStatement;
  }
};

// src/melody-extension-core/src/parser/include.js
var IncludeParser = {
  name: "include",
  parse(parser, token) {
    const tokens = parser.tokens;
    const includeStatement = new IncludeStatement(parser.matchExpression());
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "ignore")) {
      tokens.expect(TokenTypes_exports.SYMBOL, "missing");
      includeStatement.ignoreMissing = true;
    }
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "with")) {
      includeStatement.argument = parser.matchExpression();
    }
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "only")) {
      includeStatement.contextFree = true;
    }
    setStartFromToken(includeStatement, token);
    setEndFromToken(includeStatement, tokens.expect(TokenTypes_exports.TAG_END));
    return includeStatement;
  }
};

// src/melody-extension-core/src/parser/macro.js
var import_melody_types11 = __toESM(require_lib2());
var MacroParser = {
  name: "macro",
  parse(parser, token) {
    const tokens = parser.tokens;
    const tagStartToken = tokens.la(-2);
    const nameToken = tokens.expect(TokenTypes_exports.SYMBOL);
    const args = [];
    tokens.expect(TokenTypes_exports.LPAREN);
    while (!tokens.test(TokenTypes_exports.RPAREN) && !tokens.test(TokenTypes_exports.EOF)) {
      const arg = tokens.expect(TokenTypes_exports.SYMBOL);
      args.push(createNode(import_melody_types11.Identifier, arg, arg.text));
      if (!tokens.nextIf(TokenTypes_exports.COMMA) && !tokens.test(TokenTypes_exports.RPAREN)) {
        parser.error({
          title: 'Expected comma or ")"',
          pos: tokens.la(0).pos,
          advice: "The argument list of a macro can only consist of parameter names separated by commas."
        });
      }
    }
    tokens.expect(TokenTypes_exports.RPAREN);
    const openingTagEndToken = tokens.la(0);
    let closingTagStartToken;
    const body = parser.parse((tokenText, token2, tokens2) => {
      const result = !!(token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endmacro"));
      if (result) {
        closingTagStartToken = token2;
      }
      return result;
    });
    if (tokens.test(TokenTypes_exports.SYMBOL)) {
      var nameEndToken = tokens.next();
      if (nameToken.text !== nameEndToken.text) {
        parser.error({
          title: `Macro name mismatch, expected "${nameToken.text}" but found "${nameEndToken.text}"`,
          pos: nameEndToken.pos
        });
      }
    }
    const macroDeclarationStatement = new MacroDeclarationStatement(createNode(import_melody_types11.Identifier, nameToken, nameToken.text), args, body);
    setStartFromToken(macroDeclarationStatement, token);
    setEndFromToken(macroDeclarationStatement, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    macroDeclarationStatement.trimRightMacro = hasTagEndTokenTrimRight(openingTagEndToken);
    macroDeclarationStatement.trimLeftEndmacro = hasTagStartTokenTrimLeft(closingTagStartToken);
    return macroDeclarationStatement;
  }
};

// src/melody-extension-core/src/parser/set.js
var import_melody_types12 = __toESM(require_lib2());
var SetParser = {
  name: "set",
  parse(parser, token) {
    const tokens = parser.tokens, names = [], values = [];
    let openingTagEndToken, closingTagStartToken;
    do {
      const name = tokens.expect(TokenTypes_exports.SYMBOL);
      names.push(createNode(import_melody_types12.Identifier, name, name.text));
    } while (tokens.nextIf(TokenTypes_exports.COMMA));
    if (tokens.nextIf(TokenTypes_exports.ASSIGNMENT)) {
      do {
        values.push(parser.matchExpression());
      } while (tokens.nextIf(TokenTypes_exports.COMMA));
    } else {
      if (names.length !== 1) {
        parser.error({
          title: "Illegal multi-set",
          pos: tokens.la(0).pos,
          advice: "When using set with a block, you cannot have multiple targets."
        });
      }
      tokens.expect(TokenTypes_exports.TAG_END);
      openingTagEndToken = tokens.la(-1);
      values[0] = parser.parse((tokenText, token2, tokens2) => {
        const result = !!(token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endset"));
        if (result) {
          closingTagStartToken = token2;
        }
        return result;
      }).expressions;
    }
    if (names.length !== values.length) {
      parser.error({
        title: "Mismatch of set names and values",
        pos: token.pos,
        advice: `When using set, you must ensure that the number of
assigned variable names is identical to the supplied values. However, here I've found
${names.length} variable names and ${values.length} values.`
      });
    }
    const assignments = [];
    for (let i = 0, len = names.length; i < len; i++) {
      assignments[i] = new VariableDeclarationStatement(names[i], values[i]);
    }
    const setStatement = new SetStatement(assignments);
    setStartFromToken(setStatement, token);
    setEndFromToken(setStatement, tokens.expect(TokenTypes_exports.TAG_END));
    setStatement.trimRightSet = !!(openingTagEndToken && hasTagEndTokenTrimRight(openingTagEndToken));
    setStatement.trimLeftEndset = !!(closingTagStartToken && hasTagStartTokenTrimLeft(closingTagStartToken));
    return setStatement;
  }
};

// src/melody-extension-core/src/parser/spaceless.js
var SpacelessParser = {
  name: "spaceless",
  parse(parser, token) {
    const tokens = parser.tokens;
    const tagStartToken = tokens.la(-2);
    tokens.expect(TokenTypes_exports.TAG_END);
    const openingTagEndToken = tokens.la(-1);
    let closingTagStartToken;
    const body = parser.parse((tokenText, token2, tokens2) => {
      const result = !!(token2.type === TokenTypes_exports.TAG_START && tokens2.nextIf(TokenTypes_exports.SYMBOL, "endspaceless"));
      closingTagStartToken = token2;
      return result;
    }).expressions;
    const spacelessBlock = new SpacelessBlock(body);
    setStartFromToken(spacelessBlock, token);
    setEndFromToken(spacelessBlock, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    tokens.expect(TokenTypes_exports.SYMBOL, "endfor", tagStartToken);
    spacelessBlock.trimRightSpaceless = hasTagEndTokenTrimRight(openingTagEndToken);
    spacelessBlock.trimLeftEndspaceless = !!(closingTagStartToken && hasTagStartTokenTrimLeft(closingTagStartToken));
    return spacelessBlock;
  }
};

// src/melody-extension-core/src/parser/use.js
var import_melody_types13 = __toESM(require_lib2());
var UseParser = {
  name: "use",
  parse(parser, token) {
    const tokens = parser.tokens;
    const source = parser.matchExpression(), aliases = [];
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "with")) {
      do {
        const nameToken = tokens.expect(TokenTypes_exports.SYMBOL), name = createNode(import_melody_types13.Identifier, nameToken, nameToken.text);
        let alias3 = name;
        if (tokens.nextIf(TokenTypes_exports.SYMBOL, "as")) {
          const aliasToken = tokens.expect(TokenTypes_exports.SYMBOL);
          alias3 = createNode(import_melody_types13.Identifier, aliasToken, aliasToken.text);
        }
        const aliasExpression = new AliasExpression(name, alias3);
        copyStart(aliasExpression, name);
        copyEnd(aliasExpression, alias3);
        aliases.push(aliasExpression);
      } while (tokens.nextIf(TokenTypes_exports.COMMA));
    }
    const useStatement = new UseStatement(source, aliases);
    setStartFromToken(useStatement, token);
    setEndFromToken(useStatement, tokens.expect(TokenTypes_exports.TAG_END));
    return useStatement;
  }
};

// src/melody-extension-core/src/parser/mount.js
var import_melody_types14 = __toESM(require_lib2());
var MountParser = {
  name: "mount",
  parse(parser, token) {
    const tokens = parser.tokens;
    const tagStartToken = tokens.la(-2);
    let name = null, source = null, key = null, async = false, delayBy = 0, argument = null;
    if (tokens.test(TokenTypes_exports.SYMBOL, "async")) {
      const nextToken = tokens.la(1);
      if (nextToken.type === TokenTypes_exports.STRING_START) {
        async = true;
        tokens.next();
      }
    }
    if (tokens.test(TokenTypes_exports.STRING_START)) {
      source = parser.matchStringExpression();
    } else {
      const nameToken = tokens.expect(TokenTypes_exports.SYMBOL);
      name = createNode(import_melody_types14.Identifier, nameToken, nameToken.text);
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, "from")) {
        source = parser.matchStringExpression();
      }
    }
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "as")) {
      key = parser.matchExpression();
    }
    if (tokens.nextIf(TokenTypes_exports.SYMBOL, "with")) {
      argument = parser.matchExpression();
    }
    if (async) {
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, "delay")) {
        tokens.expect(TokenTypes_exports.SYMBOL, "placeholder");
        tokens.expect(TokenTypes_exports.SYMBOL, "by");
        delayBy = Number.parseInt(tokens.expect(TokenTypes_exports.NUMBER).text, 10);
        if (tokens.nextIf(TokenTypes_exports.SYMBOL, "s")) {
          delayBy *= 1e3;
        } else {
          tokens.expect(TokenTypes_exports.SYMBOL, "ms");
        }
      }
    }
    const mountStatement = new MountStatement(name, source, key, argument, async, delayBy);
    let openingTagEndToken, catchTagStartToken, catchTagEndToken, endmountTagStartToken;
    if (async) {
      tokens.expect(TokenTypes_exports.TAG_END);
      openingTagEndToken = tokens.la(-1);
      mountStatement.body = parser.parse((tokenText, token2, tokens2) => {
        return token2.type === TokenTypes_exports.TAG_START && (tokens2.test(TokenTypes_exports.SYMBOL, "catch") || tokens2.test(TokenTypes_exports.SYMBOL, "endmount"));
      });
      if (tokens.nextIf(TokenTypes_exports.SYMBOL, "catch")) {
        catchTagStartToken = tokens.la(-2);
        const errorVariableName = tokens.expect(TokenTypes_exports.SYMBOL);
        mountStatement.errorVariableName = createNode(import_melody_types14.Identifier, errorVariableName, errorVariableName.text);
        tokens.expect(TokenTypes_exports.TAG_END);
        catchTagEndToken = tokens.la(-1);
        mountStatement.otherwise = parser.parse((tokenText, token2, tokens2) => {
          return token2.type === TokenTypes_exports.TAG_START && tokens2.test(TokenTypes_exports.SYMBOL, "endmount");
        });
      }
      tokens.expect(TokenTypes_exports.SYMBOL, "endmount");
      endmountTagStartToken = tokens.la(-2);
    }
    setStartFromToken(mountStatement, token);
    setEndFromToken(mountStatement, tokens.expect(TokenTypes_exports.TAG_END, "", tagStartToken));
    mountStatement.trimRightMount = !!(openingTagEndToken && hasTagEndTokenTrimRight(openingTagEndToken));
    mountStatement.trimLeftCatch = !!(catchTagStartToken && hasTagStartTokenTrimLeft(catchTagStartToken));
    mountStatement.trimRightCatch = !!(catchTagEndToken && hasTagEndTokenTrimRight(catchTagEndToken));
    mountStatement.trimLeftEndmount = !!(endmountTagStartToken && hasTagStartTokenTrimLeft(endmountTagStartToken));
    return mountStatement;
  }
};

// src/melody-extension-core/src/visitors/for.js
var import_melody_traverse = __toESM(require_lib3());
var t = __toESM(require_lib());
var import_babel_template = __toESM(require_lib8());
var template = /* @__PURE__ */ __name((tpl) => {
  return (ctx) => parseExpr((0, import_babel_template.default)(tpl)(ctx));
}, "template");
var forWithContext = template(`
{
let SEQUENCE = SOURCE,
KEY_TARGET = 0,
LENGTH = SEQUENCE.length,
SUB_CONTEXT = CREATE_SUB_CONTEXT(CONTEXT, {
    VALUE_TARGET: SEQUENCE[0],
    loop: {
        index: 1,
        index0: 0,
        length: LENGTH,
        revindex: LENGTH,
        revindex0: LENGTH - 1,
        first: true,
        last: 1 === LENGTH
    }
});
for (;
    KEY_TARGET < LENGTH;
    KEY_TARGET++
) {
    SUB_CONTEXT.loop.index0++;
    SUB_CONTEXT.loop.index++;
    SUB_CONTEXT.loop.revindex--;
    SUB_CONTEXT.loop.revindex0--;
    SUB_CONTEXT.loop.first = false;
    SUB_CONTEXT.loop.last = SUB_CONTEXT.loop.revindex === 0;
    SUB_CONTEXT.VALUE_TARGET = _sequence[KEY_TARGET + 1];
}
}
`);
var basicFor = template(`
{
let SEQUENCE = SOURCE,
KEY_TARGET = 0,
LENGTH = SEQUENCE.length,
VALUE_TARGET = SEQUENCE[0];
for (;
    KEY_TARGET < LENGTH;
    KEY_TARGET++,
    VALUE_TARGET = SEQUENCE[_index]
) {
}
}
`);
var localFor = template(`
{
let SEQUENCE = SOURCE,
KEY_TARGET = 0,
LENGTH = SEQUENCE.length,
VALUE_TARGET = SEQUENCE[0],
INDEX_BY_1 = 1,
REVERSE_INDEX_BY_1 = LENGTH,
REVERSE_INDEX = LENGTH - 1,
FIRST = true,
LAST = 1 === LENGTH;
for (;
    KEY_TARGET < LENGTH;
    KEY_TARGET++,
    VALUE_TARGET = SEQUENCE[_index]
) {
    INDEX_BY_1++;
    REVERSE_INDEX_BY_1--;
    REVERSE_INDEX--;
    FIRST = false;
    LAST = REVERSE_INDEX === 0;
}
}
`);
function parseExpr(exprStmt) {
  return {
    exprStmt,
    initDecl: exprStmt.body[0].declarations,
    forStmt: exprStmt.body[1]
  };
}
__name(parseExpr, "parseExpr");
var for_default = {
  analyse: {
    ForStatement: {
      enter(path2) {
        const forStmt = path2.node, scope = path2.scope;
        if (forStmt.keyTarget) {
          scope.registerBinding(forStmt.keyTarget.name, path2.get("keyTarget"), "var");
        }
        if (forStmt.valueTarget) {
          scope.registerBinding(forStmt.valueTarget.name, path2.get("valueTarget"), "var");
        }
        scope.registerBinding("loop", path2, "var");
      },
      exit(path2) {
        const sequenceName = path2.scope.generateUid("sequence"), lenName = path2.scope.generateUid("length");
        path2.scope.registerBinding(sequenceName, path2, "var");
        path2.scope.registerBinding(lenName, path2, "var");
        let iName;
        if (path2.node.keyTarget) {
          iName = path2.node.keyTarget.name;
        } else {
          iName = path2.scope.generateUid("index0");
          path2.scope.registerBinding(iName, path2, "var");
        }
        path2.setData("forStatement.variableLookup", {
          sequenceName,
          lenName,
          iName
        });
        if (path2.scope.escapesContext) {
          const contextName = path2.scope.generateUid("context");
          path2.scope.registerBinding(contextName, path2, "const");
          path2.scope.contextName = contextName;
          path2.scope.getBinding("loop").kind = "context";
          if (path2.node.valueTarget) {
            path2.scope.getBinding(path2.node.valueTarget.name).kind = "context";
          }
        } else if (path2.scope.getBinding("loop").references) {
          const indexName = path2.scope.generateUid("index");
          path2.scope.registerBinding(indexName, path2, "var");
          const revindexName = path2.scope.generateUid("revindex");
          path2.scope.registerBinding(revindexName, path2, "var");
          const revindex0Name = path2.scope.generateUid("revindex0");
          path2.scope.registerBinding(revindex0Name, path2, "var");
          const firstName = path2.scope.generateUid("first");
          path2.scope.registerBinding(firstName, path2, "var");
          const lastName = path2.scope.generateUid("last");
          path2.scope.registerBinding(lastName, path2, "var");
          const lookupTable = {
            index: indexName,
            index0: iName,
            length: lenName,
            revindex: revindexName,
            revindex0: revindex0Name,
            first: firstName,
            last: lastName
          };
          path2.setData("forStatement.loopLookup", lookupTable);
          const loopBinding = path2.scope.getBinding("loop");
          for (const loopPath of loopBinding.referencePaths) {
            const memExpr = loopPath.parentPath;
            if (memExpr.is("MemberExpression")) {
              const typeName = memExpr.node.property.name;
              if (typeName === "index0") {
                memExpr.replaceWithJS({
                  type: "BinaryExpression",
                  operator: "-",
                  left: {
                    type: "Identifier",
                    name: indexName
                  },
                  right: { type: "NumericLiteral", value: 1 },
                  extra: {
                    parenthesized: true
                  }
                });
              } else {
                memExpr.replaceWithJS({
                  type: "Identifier",
                  name: lookupTable[typeName]
                });
              }
            }
          }
        }
      }
    }
  },
  convert: {
    ForStatement: {
      enter(path2) {
        if (path2.scope.escapesContext) {
          var parentContextName = path2.scope.parent.contextName;
          if (path2.node.otherwise) {
            const alternate = path2.get("otherwise");
            if (alternate.is("Scope")) {
              alternate.scope.contextName = parentContextName;
            }
          }
          const sequence = path2.get("sequence");
          if (sequence.is("Identifier")) {
            sequence.setData("Identifier.contextName", parentContextName);
          } else {
            (0, import_melody_traverse.traverse)(path2.node.sequence, {
              Identifier(id) {
                id.setData("Identifier.contextName", parentContextName);
              }
            });
          }
        }
      },
      exit(path2) {
        const node = path2.node;
        const { sequenceName, lenName, iName } = path2.getData("forStatement.variableLookup");
        let expr;
        if (path2.scope.escapesContext) {
          const contextName = path2.scope.contextName;
          expr = forWithContext({
            CONTEXT: t.identifier(path2.scope.parent.contextName),
            SUB_CONTEXT: t.identifier(contextName),
            CREATE_SUB_CONTEXT: t.identifier(this.addImportFrom("melody-runtime", "createSubContext")),
            KEY_TARGET: t.identifier(iName),
            SOURCE: path2.get("sequence").node,
            SEQUENCE: t.identifier(sequenceName),
            LENGTH: t.identifier(lenName),
            VALUE_TARGET: node.valueTarget
          });
          if (node.keyTarget) {
            expr.forStmt.body.body.push({
              type: "ExpressionStatement",
              expression: {
                type: "AssignmentExpression",
                operator: "=",
                left: {
                  type: "MemberExpression",
                  object: {
                    type: "Identifier",
                    name: contextName
                  },
                  property: {
                    type: "Identifier",
                    name: node.keyTarget.name
                  },
                  computed: false
                },
                right: {
                  type: "Identifier",
                  name: iName
                }
              }
            });
            expr.initDecl[expr.initDecl.length - 1].init.arguments[1].properties.push({
              type: "ObjectProperty",
              method: false,
              shorthand: false,
              computed: false,
              key: {
                type: "Identifier",
                name: node.keyTarget.name
              },
              value: {
                type: "Identifier",
                name: iName
              }
            });
          }
        } else if (path2.scope.getBinding("loop").references) {
          const {
            index: indexName,
            revindex: revindexName,
            revindex0: revindex0Name,
            first: firstName,
            last: lastName
          } = path2.getData("forStatement.loopLookup");
          expr = localFor({
            KEY_TARGET: t.identifier(iName),
            SOURCE: path2.get("sequence").node,
            SEQUENCE: t.identifier(sequenceName),
            LENGTH: t.identifier(lenName),
            VALUE_TARGET: node.valueTarget,
            INDEX_BY_1: t.identifier(indexName),
            REVERSE_INDEX: t.identifier(revindex0Name),
            REVERSE_INDEX_BY_1: t.identifier(revindexName),
            FIRST: t.identifier(firstName),
            LAST: t.identifier(lastName)
          });
        } else {
          expr = basicFor({
            SEQUENCE: t.identifier(sequenceName),
            SOURCE: path2.get("sequence").node,
            KEY_TARGET: t.identifier(iName),
            LENGTH: t.identifier(lenName),
            VALUE_TARGET: node.valueTarget
          });
        }
        expr.forStmt.body.body.unshift(...path2.get("body").node.body);
        let uniteratedName;
        if (node.otherwise) {
          uniteratedName = path2.scope.generateUid("uniterated");
          path2.scope.parent.registerBinding(uniteratedName, path2, "var");
          expr.forStmt.body.body.push(t.expressionStatement(t.assignmentExpression("=", t.identifier(uniteratedName), t.booleanLiteral(false))));
        }
        if (node.condition) {
          expr.forStmt.body = t.blockStatement([
            {
              type: "IfStatement",
              test: node.condition,
              consequent: t.blockStatement(expr.forStmt.body.body)
            }
          ]);
        }
        if (uniteratedName) {
          path2.replaceWithMultipleJS(t.variableDeclaration("let", [
            t.variableDeclarator(t.identifier(uniteratedName), t.booleanLiteral(true))
          ]), expr.exprStmt, t.ifStatement(t.identifier(uniteratedName), node.otherwise));
        } else {
          path2.replaceWithJS(expr.exprStmt);
        }
      }
    }
  }
};

// src/melody-extension-core/src/visitors/tests.js
var t2 = __toESM(require_lib());
var tests_default = {
  convert: {
    TestEvenExpression: {
      exit(path2) {
        const expr = t2.unaryExpression("!", t2.binaryExpression("%", path2.get("expression").node, t2.numericLiteral(2)));
        expr.extra = { parenthesizedArgument: true };
        path2.replaceWithJS(expr);
      }
    },
    TestOddExpression: {
      exit(path2) {
        const expr = t2.unaryExpression("!", t2.unaryExpression("!", t2.binaryExpression("%", path2.get("expression").node, t2.numericLiteral(2))));
        expr.extra = { parenthesizedArgument: true };
        path2.replaceWithJS(expr);
      }
    },
    TestDefinedExpression: {
      exit(path2) {
        path2.replaceWithJS(t2.binaryExpression("!==", t2.unaryExpression("typeof", path2.get("expression").node), t2.stringLiteral("undefined")));
      }
    },
    TestEmptyExpression: {
      exit(path2) {
        path2.replaceWithJS(t2.callExpression(t2.identifier(this.addImportFrom("melody-runtime", "isEmpty")), [path2.get("expression").node]));
      }
    },
    TestSameAsExpression: {
      exit(path2) {
        path2.replaceWithJS(t2.binaryExpression("===", path2.get("expression").node, path2.get("arguments")[0].node));
      }
    },
    TestNullExpression: {
      exit(path2) {
        path2.replaceWithJS(t2.binaryExpression("===", path2.get("expression").node, t2.nullLiteral()));
      }
    },
    TestDivisibleByExpression: {
      exit(path2) {
        path2.replaceWithJS(t2.unaryExpression("!", t2.binaryExpression("%", path2.get("expression").node, path2.node.arguments[0])));
      }
    },
    TestIterableExpression: {
      exit(path2) {
        path2.replaceWithJS(t2.callExpression(t2.memberExpression(t2.identifier("Array"), t2.identifier("isArray")), [path2.node.expression]));
      }
    }
  }
};

// src/melody-extension-core/src/visitors/filters.js
var t3 = __toESM(require_lib());
var import_babel_template2 = __toESM(require_lib8());
var defaultFilter = (0, import_babel_template2.default)("VAR != null && VAR !== '' ? VAR : DEFAULT");
var filters_default = {
  capitalize: "lodash",
  first: "lodash",
  last: "lodash",
  keys: "lodash",
  default(path2) {
    path2.replaceWithJS(defaultFilter({
      VAR: path2.node.target,
      DEFAULT: path2.node.arguments[0] || t3.stringLiteral("")
    }).expression);
  },
  abs(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(t3.identifier("Math"), t3.identifier("abs")), [path2.node.target]));
  },
  join(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(path2.node.target, t3.identifier("join")), path2.node.arguments));
  },
  json_encode(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(t3.identifier("JSON"), t3.identifier("stringify")), [path2.node.target]));
  },
  length(path2) {
    path2.replaceWithJS(t3.memberExpression(path2.node.target, t3.identifier("length")));
  },
  lower(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(path2.node.target, t3.identifier("toLowerCase")), []));
  },
  upper(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(path2.node.target, t3.identifier("toUpperCase")), []));
  },
  slice(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(path2.node.target, t3.identifier("slice")), path2.node.arguments));
  },
  sort(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(path2.node.target, t3.identifier("sort")), path2.node.arguments));
  },
  split(path2) {
    path2.replaceWithJS(t3.callExpression(t3.memberExpression(path2.node.target, t3.identifier("split")), path2.node.arguments));
  },
  convert_encoding(path2) {
    path2.replaceWith(path2.node.target);
  },
  date_modify(path2) {
    path2.replaceWithJS(t3.callExpression(t3.identifier(path2.state.addImportFrom("melody-runtime", "strtotime")), [path2.node.arguments[0], path2.node.target]));
  },
  date(path2) {
    path2.replaceWithJS(t3.callExpression(t3.callExpression(t3.identifier(path2.state.addDefaultImportFrom("moment")), [path2.node.target]), [path2.node.arguments[0]]));
  }
};

// src/melody-extension-core/src/visitors/functions.js
var t4 = __toESM(require_lib());
function addOne(expr) {
  return t4.binaryExpression("+", expr, t4.numericLiteral(1));
}
__name(addOne, "addOne");
var functions_default = {
  range(path2) {
    const args = path2.node.arguments;
    const callArgs = [];
    if (args.length === 1) {
      callArgs.push(addOne(args[0]));
    } else if (args.length === 3) {
      callArgs.push(args[0]);
      callArgs.push(addOne(args[1]));
      callArgs.push(args[2]);
    } else if (args.length === 2) {
      callArgs.push(args[0], addOne(args[1]));
    } else {
      path2.state.error("Invalid range call", path2.node.pos, `The range function accepts 1 to 3 arguments but you have specified ${args.length} arguments instead.`);
    }
    path2.replaceWithJS(t4.callExpression(t4.identifier(path2.state.addImportFrom("lodash", "range")), callArgs));
  },
  dump(path2) {
    if (!path2.parentPath.is("PrintExpressionStatement")) {
      path2.state.error("dump must be used in a lone expression", path2.node.pos, "The dump function does not have a return value. Thus it must be used as the only expression.");
    }
    path2.parentPath.replaceWithJS(t4.expressionStatement(t4.callExpression(t4.memberExpression(t4.identifier("console"), t4.identifier("log")), path2.node.arguments)));
  },
  include(path2) {
    if (!path2.parentPath.is("PrintExpressionStatement")) {
      path2.state.error({
        title: "Include function does not return value",
        pos: path2.node.loc.start,
        advice: `The include function currently does not return a value.
                Thus you must use it like a regular include tag.`
      });
    }
    const includeName = path2.scope.generateUid("include");
    const importDecl = t4.importDeclaration([t4.importDefaultSpecifier(t4.identifier(includeName))], path2.node.arguments[0]);
    path2.state.program.body.splice(0, 0, importDecl);
    path2.scope.registerBinding(includeName);
    const argument = path2.node.arguments[1];
    const includeCall = t4.expressionStatement(t4.callExpression(t4.memberExpression(t4.identifier(includeName), t4.identifier("render")), argument ? [argument] : []));
    path2.replaceWithJS(includeCall);
  }
};

// src/melody-extension-core/src/index.js
var filterMap = [
  "attrs",
  "classes",
  "styles",
  "batch",
  "escape",
  "format",
  "merge",
  "nl2br",
  "number_format",
  "raw",
  "replace",
  "reverse",
  "round",
  "striptags",
  "title",
  "url_encode",
  "trim"
].reduce((map, filterName) => {
  map[filterName] = "melody-runtime";
  return map;
}, /* @__PURE__ */ Object.create(null));
Object.assign(filterMap, filters_default);
var functionMap = [
  "attribute",
  "constant",
  "cycle",
  "date",
  "max",
  "min",
  "random",
  "range",
  "source",
  "template_from_string"
].reduce((map, functionName) => {
  map[functionName] = "melody-runtime";
  return map;
}, /* @__PURE__ */ Object.create(null));
Object.assign(functionMap, functions_default);
var extension = {
  tags: [
    AutoescapeParser,
    BlockParser,
    DoParser,
    EmbedParser,
    ExtendsParser,
    FilterParser,
    FlushParser,
    ForParser,
    FromParser,
    IfParser,
    ImportParser,
    IncludeParser,
    MacroParser,
    SetParser,
    SpacelessParser,
    UseParser,
    MountParser
  ],
  unaryOperators,
  binaryOperators,
  tests,
  visitors: [for_default, tests_default],
  filterMap,
  functionMap
};

// src/print/BinaryExpression.js
var ALREADY_INDENTED = Symbol("ALREADY_INDENTED");
var OPERATOR_PRECEDENCE = Symbol("OPERATOR_PRECEDENCE");
var NO_WHITESPACE_AROUND = [".."];
var operatorPrecedence = extension.binaryOperators.reduce((acc, curr) => {
  acc[curr.text] = curr.precedence;
  return acc;
}, {});
var printInterpolatedString = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  node[STRING_NEEDS_QUOTES] = false;
  node[INSIDE_OF_STRING] = true;
  const printedFragments = ['"'];
  let currentNode = node;
  const currentPath = [];
  while (import_melody_types15.Node.isBinaryConcatExpression(currentNode)) {
    printedFragments.unshift(path2.call(print2, ...currentPath, "right"));
    currentPath.push("left");
    currentNode = currentNode.left;
  }
  printedFragments.unshift(path2.call(print2, ...currentPath));
  printedFragments.unshift('"');
  return concat(printedFragments);
}, "printInterpolatedString");
var operatorNeedsSpaces = /* @__PURE__ */ __name((operator) => {
  return NO_WHITESPACE_AROUND.indexOf(operator) < 0;
}, "operatorNeedsSpaces");
var hasLogicalOperator = /* @__PURE__ */ __name((node) => {
  return node.operator === "or" || node.operator === "and";
}, "hasLogicalOperator");
var otherNeedsParentheses = /* @__PURE__ */ __name((node, otherProp) => {
  const other = node[otherProp];
  const isBinaryOther = import_melody_types15.Node.isBinaryExpression(other);
  const ownPrecedence = operatorPrecedence[node.operator];
  const otherPrecedence = isBinaryOther ? operatorPrecedence[node[otherProp].operator] : Number.MAX_SAFE_INTEGER;
  return otherPrecedence < ownPrecedence || otherPrecedence > ownPrecedence && isBinaryOther && hasLogicalOperator(other) || import_melody_types15.Node.isFilterExpression(other) || import_melody_types15.Node.isBinaryConcatExpression(node) && import_melody_types15.Node.isConditionalExpression(other);
}, "otherNeedsParentheses");
var _printBinaryExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const isBinaryRight = import_melody_types15.Node.isBinaryExpression(node.right);
  const isLogicalOperator2 = ["and", "or"].indexOf(node.operator) > -1;
  const whitespaceAroundOperator = operatorNeedsSpaces(node.operator);
  const alreadyIndented = firstValueInAncestorChain(path2, ALREADY_INDENTED, false);
  if (!alreadyIndented && isBinaryRight) {
    node.right[ALREADY_INDENTED] = true;
  }
  const foundRootAbove = firstValueInAncestorChain(path2, IS_ROOT_LOGICAL_EXPRESSION, false);
  const parentNode = findParentNode(path2);
  const shouldGroupOnTopLevel = parentNode[GROUP_TOP_LEVEL_LOGICAL] !== false;
  if (!foundRootAbove) {
    node[IS_ROOT_LOGICAL_EXPRESSION] = true;
  }
  const parentOperator = foundRootAbove ? firstValueInAncestorChain(path2, "operator") : "";
  node[OPERATOR_PRECEDENCE] = operatorPrecedence[node.operator];
  const printedLeft = path2.call(print2, "left");
  const printedRight = path2.call(print2, "right");
  const parts = [];
  const leftNeedsParens = otherNeedsParentheses(node, "left");
  const rightNeedsParens = otherNeedsParentheses(node, "right");
  if (leftNeedsParens) {
    parts.push("(");
  }
  parts.push(printedLeft);
  if (leftNeedsParens) {
    parts.push(")");
  }
  const potentiallyIndented = [whitespaceAroundOperator ? line : softline, node.operator, whitespaceAroundOperator ? " " : ""];
  if (rightNeedsParens) {
    potentiallyIndented.push("(");
  }
  potentiallyIndented.push(printedRight);
  if (rightNeedsParens) {
    potentiallyIndented.push(")");
  }
  const rightHandSide = alreadyIndented ? concat(potentiallyIndented) : indent(concat(potentiallyIndented));
  const result = concat(wrapExpressionIfNeeded(path2, [...parts, rightHandSide], node));
  const shouldCreateTopLevelGroup = !foundRootAbove && shouldGroupOnTopLevel;
  const isDifferentLogicalOperator = isLogicalOperator2 && node.operator !== parentOperator;
  const shouldGroupResult = shouldCreateTopLevelGroup || !isLogicalOperator2 || foundRootAbove && isDifferentLogicalOperator;
  return shouldGroupResult ? group(result) : result;
}, "_printBinaryExpression");
var printBinaryExpression = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  if (import_melody_types15.Node.isBinaryConcatExpression(node) && node.wasImplicitConcatenation) {
    return printInterpolatedString(node, path2, print2, options2);
  }
  return _printBinaryExpression(node, path2, print2);
}, "printBinaryExpression");

// src/print/ConditionalExpression.js
var printConditionalExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const rest = [line, "?"];
  if (node.consequent) {
    rest.push(concat([" ", path2.call(print2, "consequent")]));
  }
  if (node.alternate) {
    rest.push(line, ": ", path2.call(print2, "alternate"));
  }
  const parts = [path2.call(print2, "test"), indent(concat(rest))];
  wrapExpressionIfNeeded(path2, parts, node);
  return group(concat(parts));
}, "printConditionalExpression");

// src/print/Element.js
var printOpeningTag = /* @__PURE__ */ __name((node, path2, print2) => {
  const opener = "<" + node.name;
  const printedAttributes = printSeparatedList(path2, print2, "", "attributes");
  const openingTagEnd = node.selfClosing ? " />" : ">";
  const hasAttributes = node.attributes && node.attributes.length > 0;
  if (hasAttributes) {
    return concat([opener, indent(concat([" ", printedAttributes])), openingTagEnd]);
  }
  return concat([opener, openingTagEnd]);
}, "printOpeningTag");
var printSeparatedList = /* @__PURE__ */ __name((path2, print2, separator, attrName) => {
  return join(concat([separator, line]), path2.map(print2, attrName));
}, "printSeparatedList");
var printElement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = true;
  const openingGroup = group(printOpeningTag(node, path2, print2));
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = false;
  if (!node.selfClosing) {
    node.children = removeSurroundingWhitespace(node.children);
    const childGroups = printChildGroups(node, path2, print2, "children");
    const closingTag = concat(["</", node.name, ">"]);
    const result = [openingGroup];
    const joinedChildren = concat(childGroups);
    if (isInlineElement(node)) {
      result.push(indent(concat([softline, joinedChildren])), softline);
    } else {
      const childBlock = [];
      var onlyTextChildren = node.children.findIndex((c) => c.type != "PrintExpressionStatement" && c.type != "PrintTextStatement") == -1;
      if (childGroups.length > 0) {
        if (!onlyTextChildren) {
          childBlock.push(hardline);
        }
      }
      childBlock.push(joinedChildren);
      result.push(indent(concat(childBlock)));
      if (childGroups.length > 0) {
        if (!onlyTextChildren) {
          result.push(hardline);
        }
      }
    }
    result.push(closingTag);
    return isInlineElement(node) ? group(concat(result)) : concat(result);
  }
  return openingGroup;
}, "printElement");

// src/print/Attribute.js
var import_melody_types16 = __toESM(require_lib2());
var mayCorrectWhitespace = /* @__PURE__ */ __name((attrName) => ["id", "class", "type"].indexOf(attrName) > -1, "mayCorrectWhitespace");
var sanitizeWhitespace = /* @__PURE__ */ __name((s) => s.replace(/\s+/g, " ").trim(), "sanitizeWhitespace");
var printConcatenatedString = /* @__PURE__ */ __name((valueNode, path2, print2, ...initialPath) => {
  const printedFragments = [];
  let currentNode = valueNode;
  const currentPath = initialPath;
  while (import_melody_types16.Node.isBinaryConcatExpression(currentNode)) {
    printedFragments.unshift(path2.call(print2, ...currentPath, "right"));
    currentPath.push("left");
    currentNode = currentNode.left;
  }
  printedFragments.unshift(path2.call(print2, ...currentPath));
  return concat(printedFragments);
}, "printConcatenatedString");
var printAttribute = /* @__PURE__ */ __name((node, path2, print2 = print2) => {
  node[EXPRESSION_NEEDED] = false;
  const docs = [path2.call(print2, "name")];
  node[EXPRESSION_NEEDED] = true;
  node[STRING_NEEDS_QUOTES] = false;
  if (node.value) {
    docs.push('="');
    if (import_melody_types16.Node.isBinaryConcatExpression(node.value) && node.value.wasImplicitConcatenation) {
      docs.push(printConcatenatedString(node.value, path2, print2, "value"));
    } else {
      const isStringValue = import_melody_types16.Node.isStringLiteral(node.value);
      if (mayCorrectWhitespace(node.name.name) && isStringValue) {
        node.value.value = sanitizeWhitespace(node.value.value);
      }
      docs.push(path2.call(print2, "value"));
    }
    docs.push('"');
  }
  return concat(docs);
}, "printAttribute");

// src/print/Identifier.js
var printIdentifier = /* @__PURE__ */ __name((node, path2) => {
  node[EXPRESSION_NEEDED] = false;
  const parts = [node.name];
  wrapExpressionIfNeeded(path2, parts, node);
  const result = concat(parts);
  return parts.length === 1 ? result : group(result);
}, "printIdentifier");

// src/print/ExpressionStatement.js
var import_melody_types17 = __toESM(require_lib2());
var printExpressionStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const opener = node.trimLeft ? "{{-" : "{{";
  const closing = node.trimRight ? "-}}" : "}}";
  const shouldContractValue = isContractableNodeType(node.value) && !import_melody_types17.Node.isObjectExpression(node.value);
  const padding = shouldContractValue ? " " : line;
  const printedValue = concat([padding, path2.call(print2, "value")]);
  const value = shouldContractValue ? printedValue : indent(printedValue);
  return group(concat([opener, value, padding, closing]));
}, "printExpressionStatement");

// src/print/MemberExpression.js
var printMemberExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const parts = [path2.call(print2, "object")];
  parts.push(node.computed ? "[" : ".");
  parts.push(path2.call(print2, "property"));
  if (node.computed) {
    parts.push("]");
  }
  wrapExpressionIfNeeded(path2, parts, node);
  return group(concat(parts));
}, "printMemberExpression");

// src/print/FilterExpression.js
var import_melody_types18 = __toESM(require_lib2());
var isInFilterBlock = /* @__PURE__ */ __name((path2) => someParentNode(path2, (node) => node[FILTER_BLOCK] === true), "isInFilterBlock");
var printArguments = /* @__PURE__ */ __name((node, path2, print2, nodePath) => {
  const hasArguments = node.arguments && node.arguments.length > 0;
  if (!hasArguments) {
    return "";
  }
  const printedArguments = path2.map(print2, ...nodePath, "arguments");
  if (node.arguments.length === 1 && import_melody_types18.Node.isObjectExpression(node.arguments[0])) {
    if (node.isDjango) {
      return group(concat([":", printedArguments[0]]));
    } else {
      return group(concat(["(", printedArguments[0], ")"]));
    }
  }
  if (node.isDjango) {
    return group(concat([":", indent(concat([softline, join(concat([",", line]), printedArguments)])), softline]));
  } else {
    return group(concat(["(", indent(concat([softline, join(concat([",", line]), printedArguments)])), softline, ")"]));
  }
}, "printArguments");
var printOneFilterExpression = /* @__PURE__ */ __name((node, path2, print2, nodePath) => {
  const args = printArguments(node, path2, print2, nodePath);
  const filterName = path2.call(print2, ...nodePath, "name");
  return concat([filterName, args]);
}, "printOneFilterExpression");
var joinFilters = /* @__PURE__ */ __name((filterExpressions, space = "") => {
  return join(concat([space === "" ? softline : line, "|", space]), filterExpressions);
}, "joinFilters");
var printFilterExpression = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  let currentNode = node;
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const spaceAroundPipe = options2.twigFollowOfficialCodingStandards === false;
  const space = spaceAroundPipe ? " " : "";
  const pathToFinalTarget = ["target"];
  let filterExpressions = [printOneFilterExpression(node, path2, print2, [])];
  while (import_melody_types18.Node.isFilterExpression(currentNode.target)) {
    filterExpressions.unshift(printOneFilterExpression(currentNode.target, path2, print2, pathToFinalTarget));
    pathToFinalTarget.push("target");
    currentNode = currentNode.target;
  }
  const finalTarget = path2.call(print2, ...pathToFinalTarget);
  const isFilterBlock = isInFilterBlock(path2);
  const targetNeedsParentheses = isMultipartExpression(getDeepProperty(node, ...pathToFinalTarget));
  const parts = [];
  if (targetNeedsParentheses) {
    parts.push("(");
  }
  parts.push(finalTarget);
  if (targetNeedsParentheses) {
    parts.push(")");
  }
  if (isFilterBlock) {
    parts.push(concat([" ", filterExpressions[0]]));
    filterExpressions = filterExpressions.slice(1);
  }
  if (filterExpressions.length === 1) {
    parts.push(`${space}|${space}`, filterExpressions[0]);
  } else if (filterExpressions.length > 1) {
    const indentedFilters = concat([spaceAroundPipe ? line : softline, `|${space}`, joinFilters(filterExpressions, space)]);
    parts.push(indent(indentedFilters));
  }
  const kindOfWrap = shouldExpressionsBeWrapped(path2);
  if (kindOfWrap === EXPRESSION_NEEDED) {
    parts.push(" }}");
    parts.unshift("{{ ");
  } else if (kindOfWrap === INSIDE_OF_STRING) {
    wrapInStringInterpolation(parts);
  }
  return group(concat(parts));
}, "printFilterExpression");

// src/print/ObjectExpression.js
var printObjectExpression = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  if (node.properties.length === 0) {
    return "{}";
  }
  node[EXPRESSION_NEEDED] = false;
  const mappedElements = path2.map(print2, "properties");
  const separator = options2.twigAlwaysBreakObjects ? hardline : line;
  const indentedContent = concat([line, join(concat([",", separator]), mappedElements)]);
  const parts = ["{", indent(indentedContent), separator, "}"];
  wrapExpressionIfNeeded(path2, parts, node);
  return group(concat(parts));
}, "printObjectExpression");

// src/print/ObjectProperty.js
var import_melody_types19 = __toESM(require_lib2());
var printObjectProperty = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  node[STRING_NEEDS_QUOTES] = !node.computed && import_melody_types19.Node.isStringLiteral(node.key) && !isValidIdentifierName(node.key.value);
  const shouldPrintKeyAsString = node.key.wasImplicitConcatenation;
  const needsParentheses = node.computed && !shouldPrintKeyAsString;
  const parts = [];
  if (needsParentheses) {
    parts.push("(");
  }
  parts.push(path2.call(print2, "key"));
  if (needsParentheses) {
    parts.push(")");
  }
  parts.push(": ");
  node[STRING_NEEDS_QUOTES] = true;
  parts.push(path2.call(print2, "value"));
  return concat(parts);
}, "printObjectProperty");

// src/print/CallExpression.js
var import_melody_types20 = __toESM(require_lib2());
var printCallExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const mappedArguments = path2.map(print2, "arguments");
  const parts = [path2.call(print2, "callee"), "("];
  if (node.arguments.length === 0) {
    parts.push(")");
  } else if (node.arguments.length === 1 && import_melody_types20.Node.isObjectExpression(node.arguments[0])) {
    parts.push(mappedArguments[0], ")");
  } else {
    parts.push(indent(concat([softline, join(concat([",", line]), mappedArguments)])), softline, ")");
  }
  wrapExpressionIfNeeded(path2, parts, node);
  return group(concat(parts));
}, "printCallExpression");

// src/print/TestExpression.js
var textMap = {
  TestNullExpression: "null",
  TestDivisibleByExpression: "divisible by",
  TestDefinedExpression: "defined",
  TestEmptyExpression: "empty",
  TestEvenExpression: "even",
  TestOddExpression: "odd",
  TestIterableExpression: "iterable",
  TestSameAsExpression: "same as"
};
var isNegator = /* @__PURE__ */ __name((node) => node.constructor.name === "UnarySubclass" && node.operator === "not", "isNegator");
var printTestExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  const expressionType = node.__proto__.type;
  const parts = [path2.call(print2, "expression"), " is "];
  const parent = findParentNode(path2);
  const hasArguments = Array.isArray(node.arguments) && node.arguments.length > 0;
  if (isNegator(parent)) {
    parts.push("not ");
  }
  if (!textMap[expressionType]) {
    console.error("TestExpression: No text for " + expressionType + " defined");
  } else {
    parts.push(textMap[expressionType]);
  }
  if (hasArguments) {
    const printedArguments = path2.map(print2, "arguments");
    const joinedArguments = join(concat([",", line]), printedArguments);
    parts.push(group(concat(["(", indent(concat([softline, joinedArguments])), softline, ")"])));
  }
  return concat(parts);
}, "printTestExpression");

// src/print/UnaryExpression.js
var printUnaryExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const parts = [node.operator, path2.call(print2, "argument")];
  wrapExpressionIfNeeded(path2, parts, node);
  return group(concat(parts));
}, "printUnaryExpression");

// src/print/UnarySubclass.js
var import_melody_types21 = __toESM(require_lib2());
var argumentNeedsParentheses = /* @__PURE__ */ __name((node) => isMultipartExpression(node), "argumentNeedsParentheses");
var isLogicalOperator = /* @__PURE__ */ __name((operator) => operator === "not", "isLogicalOperator");
var printLogicalExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  const foundRootAbove = firstValueInAncestorChain(path2, IS_ROOT_LOGICAL_EXPRESSION, false);
  if (!foundRootAbove) {
    node[IS_ROOT_LOGICAL_EXPRESSION] = true;
  }
  const parentNode = findParentNode(path2);
  const shouldGroupOnTopLevel = parentNode[GROUP_TOP_LEVEL_LOGICAL] !== false;
  const parts = [node.operator, " "];
  const needsParentheses = argumentNeedsParentheses(node.argument);
  const printedArgument = path2.call(print2, "argument");
  if (needsParentheses) {
    parts.push("(", indent(concat([softline, printedArgument])), concat([softline, ")"]));
  } else {
    parts.push(printedArgument);
  }
  const result = concat(parts);
  const shouldCreateTopLevelGroup = !foundRootAbove && shouldGroupOnTopLevel;
  return shouldCreateTopLevelGroup ? group(result) : result;
}, "printLogicalExpression");
var printUnarySubclass = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [];
  const hasTestExpressionArgument = import_melody_types21.Node.isTestExpression(node.argument);
  if (isLogicalOperator(node.operator) && !hasTestExpressionArgument) {
    return printLogicalExpression(node, path2, print2);
  }
  if (!hasTestExpressionArgument) {
    parts.push(node.operator, " ");
  }
  parts.push(path2.call(print2, "argument"));
  return concat(parts);
}, "printUnarySubclass");

// src/print/TextStatement.js
var newlinesOnly = /* @__PURE__ */ __name((s, preserveWhitespace = true) => {
  const numNewlines = countNewlines(s);
  if (numNewlines === 0) {
    return preserveWhitespace ? line : "";
  } else if (numNewlines === 1) {
    return hardline;
  }
  return concat([hardline, hardline]);
}, "newlinesOnly");
var printTextStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  const preserveLeadingWhitespace = node[PRESERVE_LEADING_WHITESPACE] === true;
  const preserveTrailingWhitespace = node[PRESERVE_TRAILING_WHITESPACE] === true;
  const rawString = path2.call(print2, "value");
  if (isWhitespaceOnly(rawString) && node[NEWLINES_ONLY]) {
    return newlinesOnly(rawString);
  }
  const textGroups = createTextGroups(rawString, preserveLeadingWhitespace, preserveTrailingWhitespace);
  return join(concat([hardline, hardline]), textGroups);
}, "printTextStatement");

// src/print/StringLiteral.js
var isUnmaskedOccurrence = /* @__PURE__ */ __name((s, pos) => {
  return pos === 0 || s[pos - 1] !== "\\";
}, "isUnmaskedOccurrence");
var containsUnmasked = /* @__PURE__ */ __name((char) => (s) => {
  let pos = s.indexOf(char);
  while (pos >= 0) {
    if (isUnmaskedOccurrence(s, pos)) {
      return true;
    }
    pos = s.indexOf(char, pos + 1);
  }
  return false;
}, "containsUnmasked");
var containsUnmaskedSingleQuote = containsUnmasked("'");
var containsUnmaskedDoubleQuote = containsUnmasked('"');
var getQuoteChar = /* @__PURE__ */ __name((s, options2) => {
  if (containsUnmaskedSingleQuote(s)) {
    return '"';
  }
  if (containsUnmaskedDoubleQuote(s)) {
    return "'";
  }
  return quoteChar(options2);
}, "getQuoteChar");
var printStringLiteral = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  const needsQuotes = firstValueInAncestorChain(path2, STRING_NEEDS_QUOTES, false);
  const overridingQuoteChar = firstValueInAncestorChain(path2, OVERRIDE_QUOTE_CHAR, null);
  if (needsQuotes) {
    const quote = overridingQuoteChar ? overridingQuoteChar : getQuoteChar(node.value, options2);
    return quote + node.value + quote;
  }
  return node.value;
}, "printStringLiteral");

// src/print/ArrayExpression.js
var printArrayExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  const mappedElements = path2.map(print2, "elements");
  const indentedContent = concat([softline, join(concat([",", line]), mappedElements)]);
  return group(concat(["[", indent(indentedContent), softline, "]"]));
}, "printArrayExpression");

// src/print/SliceExpression.js
var printSliceExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  const printedTarget = path2.call(print2, "target");
  const printedStart = node.start ? path2.call(print2, "start") : "";
  const printedEnd = node.end ? path2.call(print2, "end") : "";
  return concat([printedTarget, "[", printedStart, ":", printedEnd, "]"]);
}, "printSliceExpression");

// src/print/UseStatement.js
var printUseStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  const docs = [node.trimLeft ? "{%-" : "{%", ' use "', path2.call(print2, "source"), '"'];
  const hasAliases = node.aliases && node.aliases.length > 0;
  if (hasAliases) {
    docs.push(" with");
    const mappedAliases = path2.map(print2, "aliases");
    docs.push(indent(concat([line, join(concat([",", line]), mappedAliases)])));
    docs.push(line);
  } else {
    docs.push(" ");
  }
  docs.push(node.trimRight ? "-%}" : "%}");
  return group(concat(docs));
}, "printUseStatement");

// src/print/AliasExpression.js
var printAliasExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  return concat([path2.call(print2, "name"), " as ", path2.call(print2, "alias")]);
}, "printAliasExpression");

// src/print/BlockStatement.js
var import_melody_types22 = __toESM(require_lib2());
var printBlockStatement = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  node[EXPRESSION_NEEDED] = false;
  const hasChildren = Array.isArray(node.body);
  const printEndblockName = options2.twigOutputEndblockName === true;
  if (hasChildren) {
    const blockName = path2.call(print2, "name");
    const opener = concat([node.trimLeft ? "{%-" : "{%", " block ", blockName, node.trimRightBlock ? " -%}" : " %}"]);
    const parts = [opener];
    if (node.body.length > 0) {
      const indentedBody = printChildBlock(node, path2, print2, "body");
      parts.push(indentedBody);
    }
    parts.push(hardline);
    parts.push(node.trimLeftEndblock ? "{%-" : "{%", " endblock", printEndblockName ? concat([" ", blockName]) : "", node.trimRight ? " -%}" : " %}");
    const result = group(concat(parts));
    return result;
  } else if (import_melody_types22.Node.isPrintExpressionStatement(node.body)) {
    const parts = [node.trimLeft ? "{%-" : "{%", " block ", path2.call(print2, "name"), " ", path2.call(print2, "body", "value"), node.trimRight ? " -%}" : " %}"];
    return concat(parts);
  }
}, "printBlockStatement");

// src/print/SpacelessBlock.js
var printSpacelessBlock = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [node.trimLeft ? "{%-" : "{%", " spaceless ", node.trimRightSpaceless ? "-%}" : "%}"];
  parts.push(printChildBlock(node, path2, print2, "body"));
  parts.push(hardline);
  parts.push(node.trimLeftEndspaceless ? "{%-" : "{%", " endspaceless ", node.trimRight ? "-%}" : "%}");
  const result = group(concat(parts));
  return result;
}, "printSpacelessBlock");

// src/print/AutoescapeBlock.js
var createOpener = /* @__PURE__ */ __name((node, options2) => {
  return concat([node.trimLeft ? "{%-" : "{%", " autoescape ", quoteChar(options2), node.escapeType || "html", quoteChar(options2), " ", node.trimRightAutoescape ? "-%}" : "%}"]);
}, "createOpener");
var printAutoescapeBlock = /* @__PURE__ */ __name((node, path2, print2, options2) => {
  const parts = [createOpener(node, options2)];
  parts.push(printChildBlock(node, path2, print2, "expressions"));
  parts.push(hardline, node.trimLeftEndautoescape ? "{%-" : "{%", " endautoescape ", node.trimRight ? "-%}" : "%}");
  return concat(parts);
}, "printAutoescapeBlock");

// src/print/FlushStatement.js
var printFlushStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  const dashLeft = node.trimLeft ? "-" : "";
  const dashRight = node.trimRight ? "-" : "";
  return `{%${dashLeft} flush ${dashRight}%}`;
}, "printFlushStatement");

// src/print/IncludeStatement.js
var printIncludeStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  const parts = [node.trimLeft ? "{%-" : "{%", " include ", path2.call(print2, "source")];
  if (node.argument) {
    const printedArguments = path2.call(print2, "argument");
    parts.push(" with ");
    parts.push(printedArguments);
  }
  if (node.contextFree) {
    parts.push(" only");
  }
  parts.push(node.trimRight ? " -%}" : " %}");
  return group(concat(parts));
}, "printIncludeStatement");

// src/print/IfStatement.js
var import_melody_types23 = __toESM(require_lib2());
var IS_ELSEIF = Symbol("IS_ELSEIF");
var printIfStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  const hasElseBranch = Array.isArray(node.alternate) && node.alternate.length > 0;
  const hasElseIfBranch = import_melody_types23.Node.isIfStatement(node.alternate);
  const isElseIf = node[IS_ELSEIF] === true;
  const isEmptyIf = node.consequent.length === 0;
  const hasOneChild = node.consequent.length === 1;
  const firstChild = node.consequent[0];
  const printInline = !isElseIf && !node.alternate && (isEmptyIf || hasOneChild && !import_melody_types23.Node.isElement(firstChild) && (!import_melody_types23.Node.isPrintTextStatement(firstChild) || hasNoNewlines(firstChild.value.value)));
  if (hasOneChild && import_melody_types23.Node.isPrintTextStatement(firstChild) && hasNoNewlines(firstChild.value.value)) {
    firstChild[PRESERVE_LEADING_WHITESPACE] = true;
    firstChild[PRESERVE_TRAILING_WHITESPACE] = true;
  }
  const ifClause = group(concat([node.trimLeft ? "{%- " : "{% ", isElseIf ? "elseif" : "if", indent(concat([line, path2.call(print2, "test")])), " ", node.trimRightIf ? "-%}" : "%}"]));
  const ifBody = printInline ? isEmptyIf ? "" : path2.call(print2, "consequent", "0") : printChildBlock(node, path2, print2, "consequent");
  const parts = [ifClause, ifBody];
  if (hasElseBranch) {
    parts.push(hardline, node.trimLeftElse ? "{%-" : "{%", " else ", node.trimRightElse ? "-%}" : "%}");
    parts.push(printChildBlock(node, path2, print2, "alternate"));
  } else if (hasElseIfBranch) {
    node.alternate[IS_ELSEIF] = true;
    parts.push(hardline);
    parts.push(path2.call(print2, "alternate"));
  }
  if (!isElseIf) {
    parts.push(printInline ? "" : hardline, node.trimLeftEndif ? "{%-" : "{%", " endif ", node.trimRight ? "-%}" : "%}");
  }
  return concat(parts);
}, "printIfStatement");

// src/print/MountStatement.js
var formatDelay = /* @__PURE__ */ __name((delay) => {
  return "" + delay / 1e3 + "s";
}, "formatDelay");
var buildOpener = /* @__PURE__ */ __name((node, path2, print2) => {
  const result = [];
  const firstGroup = [node.trimLeft ? "{%-" : "{%", " mount"];
  if (node.async === true) {
    firstGroup.push(" async");
  }
  if (node.name) {
    firstGroup.push(" ", path2.call(print2, "name"));
  }
  if (node.name && node.source) {
    firstGroup.push(" from");
  }
  if (node.source) {
    firstGroup.push(" ", path2.call(print2, "source"));
  }
  if (node.key) {
    firstGroup.push(indent(concat([line, "as ", path2.call(print2, "key")])));
  }
  result.push(group(concat(firstGroup)));
  if (node.argument) {
    result.push(indent(concat([" with ", path2.call(print2, "argument")])));
  }
  if (node.delayBy) {
    result.push(indent(concat([line, "delay placeholder by ", formatDelay(node.delayBy)])));
  }
  const trimRightMount = node.body || node.otherwise ? node.trimRightMount : node.trimRight;
  result.push(concat([line, trimRightMount ? "-%}" : "%}"]));
  return group(concat(result));
}, "buildOpener");
var buildBody = /* @__PURE__ */ __name((path2, print2) => {
  return indent(concat([hardline, path2.call(print2, "body")]));
}, "buildBody");
var buildErrorHandling = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [];
  parts.push(concat([hardline, node.trimLeftCatch ? "{%-" : "{%", " catch "]));
  if (node.errorVariableName) {
    parts.push(path2.call(print2, "errorVariableName"), " ");
  }
  parts.push(node.trimRightCatch ? "-%}" : "%}");
  parts.push(indent(concat([hardline, path2.call(print2, "otherwise")])));
  return concat(parts);
}, "buildErrorHandling");
var printMountStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const parts = [buildOpener(node, path2, print2)];
  if (node.body) {
    parts.push(buildBody(path2, print2));
  }
  if (node.otherwise) {
    parts.push(buildErrorHandling(node, path2, print2));
  }
  if (node.body || node.otherwise) {
    parts.push(concat([hardline, node.trimLeftEndmount ? "{%-" : "{%", " endmount ", node.trimRight ? "-%}" : "%}"]));
  }
  return concat(parts);
}, "printMountStatement");

// src/print/ForStatement.js
var printFor = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [node.trimLeft ? "{%-" : "{%", " for "];
  if (node.keyTarget) {
    parts.push(path2.call(print2, "keyTarget"), ", ");
  }
  parts.push(path2.call(print2, "valueTarget"), " in ", path2.call(print2, "sequence"));
  if (node.condition) {
    parts.push(indent(concat([line, "if ", path2.call(print2, "condition")])));
  }
  parts.push(concat([" ", node.trimRightFor ? "-%}" : "%}"]));
  return group(concat(parts));
}, "printFor");
var printForStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  const parts = [printFor(node, path2, print2)];
  const isBodyEmpty = node.body.expressions.length === 0 || node.body.expressions.length === 1 && isWhitespaceNode(node.body.expressions[0]);
  const printedChildren = path2.call(print2, "body");
  if (!isBodyEmpty || node.otherwise) {
    parts.push(indentWithHardline(printedChildren));
  }
  if (node.otherwise) {
    parts.push(hardline, node.trimLeftElse ? "{%-" : "{%", " else ", node.trimRightElse ? "-%}" : "%}");
    const printedOtherwise = path2.call(print2, "otherwise");
    parts.push(indentWithHardline(printedOtherwise));
  }
  parts.push(isBodyEmpty ? "" : hardline, node.trimLeftEndfor ? "{%-" : "{%", " endfor ", node.trimRight ? "-%}" : "%}");
  return concat(parts);
}, "printForStatement");

// src/print/SetStatement.js
var import_melody_types24 = __toESM(require_lib2());
var shouldAvoidBreakBeforeClosing = /* @__PURE__ */ __name((valueNode) => import_melody_types24.Node.isObjectExpression(valueNode) || isNotExpression(valueNode) || import_melody_types24.Node.isArrayExpression(valueNode), "shouldAvoidBreakBeforeClosing");
var buildSetStatement = /* @__PURE__ */ __name((node, path2, print2, assignmentIndex) => {
  const varDeclaration = node.assignments[assignmentIndex];
  varDeclaration[GROUP_TOP_LEVEL_LOGICAL] = false;
  const avoidBreakBeforeClosing = shouldAvoidBreakBeforeClosing(varDeclaration.value);
  return group(concat([node.trimLeft ? "{%-" : "{%", " set ", path2.call(print2, "assignments", assignmentIndex), avoidBreakBeforeClosing ? " " : line, node.trimRight ? "-%}" : "%}"]));
}, "buildSetStatement");
var isEmbracingSet = /* @__PURE__ */ __name((node) => {
  return Array.isArray(node.assignments) && node.assignments.length === 1 && Array.isArray(node.assignments[0].value);
}, "isEmbracingSet");
var printRegularSet = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [];
  const hasAssignments = Array.isArray(node.assignments) && node.assignments.length > 0;
  if (hasAssignments) {
    node.assignments.forEach((_, index) => {
      if (parts.length > 0) {
        parts.push(hardline);
      }
      parts.push(buildSetStatement(node, path2, print2, index));
    });
  }
  return concat(parts);
}, "printRegularSet");
var printEmbracingSet = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [node.trimLeft ? "{%-" : "{%", " set ", path2.call(print2, "assignments", "0", "name"), node.trimRightSet ? " -%}" : " %}"];
  node[STRING_NEEDS_QUOTES] = false;
  const printedContents = printChildBlock(node, path2, print2, "assignments", "0", "value");
  parts.push(printedContents);
  parts.push(hardline, node.trimLeftEndset ? "{%-" : "{%", " endset ", node.trimRight ? "-%}" : "%}");
  return concat(parts);
}, "printEmbracingSet");
var printSetStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  if (isEmbracingSet(node)) {
    return printEmbracingSet(node, path2, print2);
  }
  return printRegularSet(node, path2, print2);
}, "printSetStatement");

// src/print/DoStatement.js
var printDoStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  return concat([node.trimLeft ? "{%-" : "{%", " do ", path2.call(print2, "value"), node.trimRight ? " -%}" : " %}"]);
}, "printDoStatement");

// src/print/ExtendsStatement.js
var printExtendsStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  return concat([node.trimLeft ? "{%-" : "{%", " extends ", path2.call(print2, "parentName"), node.trimRight ? " -%}" : " %}"]);
}, "printExtendsStatement");

// src/print/EmbedStatement.js
var printOpener = /* @__PURE__ */ __name((node, path2, print2) => {
  node[EXPRESSION_NEEDED] = false;
  node[STRING_NEEDS_QUOTES] = true;
  const parts = [node.trimLeft ? "{%-" : "{%", " embed ", path2.call(print2, "parent")];
  if (node.argument) {
    parts.push(indent(concat([line, "with ", path2.call(print2, "argument")])));
  }
  parts.push(concat([line, node.trimRightEmbed ? "-%}" : "%}"]));
  return group(concat(parts));
}, "printOpener");
var printEmbedStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  const children = printChildBlock(node, path2, print2, "blocks");
  const printedOpener = printOpener(node, path2, print2);
  const closing = concat([hardline, node.trimLeftEndembed ? "{%-" : "{%", " endembed ", node.trimRight ? "-%}" : "%}"]);
  return concat([printedOpener, children, closing]);
}, "printEmbedStatement");

// src/print/ImportDeclaration.js
var printImportDeclaration = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  return group(concat([node.trimLeft ? "{%-" : "{%", " import ", path2.call(print2, "key"), indent(concat([line, "as ", path2.call(print2, "alias")])), line, node.trimRight ? "-%}" : "%}"]));
}, "printImportDeclaration");

// src/print/FromStatement.js
var printImportDeclaration2 = /* @__PURE__ */ __name((node) => {
  const parts = [node.key.name];
  if (node.key.name !== node.alias.name) {
    parts.push(" as ", node.alias.name);
  }
  return concat(parts);
}, "printImportDeclaration");
var printFromStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  const mappedImports = node.imports.map(printImportDeclaration2);
  const indentedParts = indent(concat([line, join(concat([",", line]), mappedImports)]));
  return group(concat([node.trimLeft ? "{%-" : "{%", " from ", path2.call(print2, "source"), " import", indentedParts, line, node.trimRight ? "-%}" : "%}"]));
}, "printFromStatement");

// src/print/TwigComment.js
var printTwigComment = /* @__PURE__ */ __name((node) => {
  const originalText = node.value.value || "";
  const commentText = stripTwigCommentChars(originalText);
  const trimLeft = originalText.length >= 3 ? originalText[2] === "-" : false;
  const trimRight = originalText.length >= 3 ? originalText.slice(-3, -2) === "-" : false;
  const numNewlines = countNewlines(commentText);
  if (numNewlines === 0) {
    return normalizeTwigComment(commentText, trimLeft, trimRight);
  }
  return concat([trimLeft ? "{#-" : "{#", commentText, trimRight ? "-#}" : "#}"]);
}, "printTwigComment");

// src/print/HtmlComment.js
var printHtmlComment = /* @__PURE__ */ __name((node, path2, print2) => {
  const commentText = stripHtmlCommentChars(node.value.value || "");
  const numNewlines = countNewlines(commentText);
  if (numNewlines === 0) {
    return normalizeHtmlComment(commentText);
  }
  return concat(["<!-- ", commentText, " -->"]);
}, "printHtmlComment");

// src/print/Declaration.js
var printDeclaration = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  node[OVERRIDE_QUOTE_CHAR] = '"';
  const start = "<!" + (node.declarationType || "").toUpperCase();
  const printedParts = path2.map(print2, "parts");
  return fill([start, " ", join(" ", printedParts), ">"]);
}, "printDeclaration");

// src/print/GenericTwigTag.js
var import_melody_types25 = __toESM(require_lib2());
var printGenericTwigTag = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  const openingTag = printSingleTwigTag(node, path2, print2);
  const parts = [openingTag];
  const printedSections = path2.map(print2, "sections");
  node.sections.forEach((section, i) => {
    if (import_melody_types25.Node.isGenericTwigTag(section)) {
      parts.push(concat([hardline, printedSections[i]]));
    } else {
      if (!isEmptySequence(section)) {
        parts.push(indentWithHardline(printedSections[i]));
      }
    }
  });
  return concat(parts);
}, "printGenericTwigTag");

// src/print/GenericToken.js
var printGenericToken = /* @__PURE__ */ __name((node, path2, print2) => {
  return node.tokenText;
}, "printGenericToken");

// src/print/MacroDeclarationStatement.js
var printOpener2 = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [node.trimLeft ? "{%-" : "{%", " macro ", path2.call(print2, "name"), "("];
  const mappedArguments = path2.map(print2, "arguments");
  const joinedArguments = join(concat([",", line]), mappedArguments);
  parts.push(indent(concat([softline, joinedArguments])));
  parts.push(")", line, node.trimRightMacro ? "-%}" : "%}");
  return group(concat(parts));
}, "printOpener");
var printMacroDeclarationStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [printOpener2(node, path2, print2)];
  parts.push(indent(concat([hardline, path2.call(print2, "body")])));
  parts.push(hardline, node.trimLeftEndmacro ? "{%-" : "{%", " endmacro ", node.trimRight ? "-%}" : "%}");
  return concat(parts);
}, "printMacroDeclarationStatement");

// src/print/FilterBlockStatement.js
var printOpeningGroup = /* @__PURE__ */ __name((node, path2, print2) => {
  const parts = [node.trimLeft ? "{%- " : "{% "];
  const printedExpression = path2.call(print2, "filterExpression");
  parts.push(printedExpression, line, node.trimRightFilter ? "-%}" : "%}");
  return group(concat(parts));
}, "printOpeningGroup");
var printFilterBlockStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  node[FILTER_BLOCK] = true;
  const openingGroup = printOpeningGroup(node, path2, print2);
  const body = printChildBlock(node, path2, print2, "body");
  const closingStatement = concat([hardline, node.trimLeftEndfilter ? "{%-" : "{%", " endfilter ", node.trimRight ? "-%}" : "%}"]);
  return concat([openingGroup, body, closingStatement]);
}, "printFilterBlockStatement");

// src/print/VariableDeclarationStatement.js
var printVariableDeclarationStatement = /* @__PURE__ */ __name((node, path2, print2) => {
  const printedName = path2.call(print2, "name");
  node[STRING_NEEDS_QUOTES] = true;
  const printedValue = path2.call(print2, "value");
  const shouldCondenseLayout = isContractableNodeType(node.value);
  const rightHandSide = shouldCondenseLayout ? concat([" ", printedValue]) : indent(concat([line, printedValue]));
  return concat([printedName, " =", rightHandSide]);
}, "printVariableDeclarationStatement");

// src/print/NamedArgumentExpression.js
var printNamedArgumentExpression = /* @__PURE__ */ __name((node, path2, print2) => {
  node[STRING_NEEDS_QUOTES] = true;
  const printedName = path2.call(print2, "name");
  const printedValue = path2.call(print2, "value");
  return concat([printedName, " = ", printedValue]);
}, "printNamedArgumentExpression");

// src/parser.js
var ORIGINAL_SOURCE = Symbol("ORIGINAL_SOURCE");
var createConfiguredLexer = /* @__PURE__ */ __name((code, ...extensions) => {
  const lexer = new Lexer(new CharStream(code));
  for (const extension2 of extensions) {
    if (extension2.unaryOperators) {
      lexer.addOperators(...extension2.unaryOperators.map((op) => op.text));
    }
    if (extension2.binaryOperators) {
      lexer.addOperators(...extension2.binaryOperators.map((op) => op.text));
    }
  }
  return lexer;
}, "createConfiguredLexer");
var applyParserExtensions = /* @__PURE__ */ __name((parser, ...extensions) => {
  for (const extension2 of extensions) {
    if (extension2.tags) {
      for (const tag of extension2.tags) {
        parser.addTag(tag);
      }
    }
    if (extension2.unaryOperators) {
      for (const op of extension2.unaryOperators) {
        parser.addUnaryOperator(op);
      }
    }
    if (extension2.binaryOperators) {
      for (const op of extension2.binaryOperators) {
        parser.addBinaryOperator(op);
      }
    }
    if (extension2.tests) {
      for (const test of extension2.tests) {
        parser.addTest(test);
      }
    }
  }
}, "applyParserExtensions");
var createConfiguredParser = /* @__PURE__ */ __name((code, multiTagConfig, ...extensions) => {
  const parser = new Parser(new TokenStream(createConfiguredLexer(code, ...extensions), {
    ignoreWhitespace: true,
    ignoreComments: false,
    ignoreHtmlComments: false,
    applyWhitespaceTrimming: false
  }), {
    ignoreComments: false,
    ignoreHtmlComments: false,
    ignoreDeclarations: false,
    decodeEntities: false,
    multiTags: multiTagConfig,
    allowUnknownTags: true
  });
  applyParserExtensions(parser, ...extensions);
  return parser;
}, "createConfiguredParser");
var getMultiTagConfig = /* @__PURE__ */ __name((tagsCsvs = []) => tagsCsvs.reduce((acc, curr) => {
  const tagNames = curr.split(",");
  acc[tagNames[0].trim()] = tagNames.slice(1).map((s) => s.trim());
  return acc;
}, {}), "getMultiTagConfig");
var parse = /* @__PURE__ */ __name((text, parsers2, options2) => {
  const pluginPaths = getPluginPathsFromOptions(options2);
  const multiTagConfig = getMultiTagConfig(options2.twigMultiTags || []);
  const extensions = [extension, ...getAdditionalMelodyExtensions(pluginPaths)];
  const parser = createConfiguredParser(text, multiTagConfig, ...extensions);
  const ast = parser.parse();
  ast[ORIGINAL_SOURCE] = text;
  return ast;
}, "parse");

// src/printer.js
var printFunctions = {};
var applyPlugin = /* @__PURE__ */ __name((loadedPlugin) => {
  if (loadedPlugin && loadedPlugin.printers) {
    for (const printerName of Object.keys(loadedPlugin.printers)) {
      printFunctions[printerName] = loadedPlugin.printers[printerName];
    }
  }
}, "applyPlugin");
var applyPlugins = /* @__PURE__ */ __name((options2) => {
  const pluginPaths = getPluginPathsFromOptions(options2);
  const loadedPlugins = loadPlugins(pluginPaths);
  loadedPlugins.forEach((plugin) => {
    applyPlugin(plugin);
  });
}, "applyPlugins");
var isHtmlIgnoreNextComment = isHtmlCommentEqualTo("prettier-ignore");
var isHtmlIgnoreStartComment = isHtmlCommentEqualTo("prettier-ignore-start");
var isHtmlIgnoreEndComment = isHtmlCommentEqualTo("prettier-ignore-end");
var isTwigIgnoreNextComment = isTwigCommentEqualTo("prettier-ignore");
var isTwigIgnoreStartComment = isTwigCommentEqualTo("prettier-ignore-start");
var isTwigIgnoreEndComment = isTwigCommentEqualTo("prettier-ignore-end");
var isIgnoreNextComment = /* @__PURE__ */ __name((s) => isHtmlIgnoreNextComment(s) || isTwigIgnoreNextComment(s), "isIgnoreNextComment");
var isIgnoreRegionStartComment = /* @__PURE__ */ __name((s) => isHtmlIgnoreStartComment(s) || isTwigIgnoreStartComment(s), "isIgnoreRegionStartComment");
var isIgnoreRegionEndComment = /* @__PURE__ */ __name((s) => isHtmlIgnoreEndComment(s) || isTwigIgnoreEndComment(s), "isIgnoreRegionEndComment");
var originalSource = "";
var ignoreRegion = false;
var ignoreNext = false;
var checkForIgnoreStart = /* @__PURE__ */ __name((node) => {
  ignoreNext = ignoreNext && !shouldApplyIgnoreNext(node) || isIgnoreNextComment(node);
  ignoreRegion = ignoreRegion || isIgnoreRegionStartComment(node);
}, "checkForIgnoreStart");
var checkForIgnoreEnd = /* @__PURE__ */ __name((node) => {
  if (ignoreRegion && isIgnoreRegionEndComment(node)) {
    ignoreRegion = false;
  }
}, "checkForIgnoreEnd");
var shouldApplyIgnoreNext = /* @__PURE__ */ __name((node) => !isWhitespaceNode(node), "shouldApplyIgnoreNext");
var print = /* @__PURE__ */ __name((path2, options2, print2) => {
  applyPlugins(options2);
  const node = path2.getValue();
  const nodeType = node.constructor.name;
  if (node[ORIGINAL_SOURCE]) {
    originalSource = node[ORIGINAL_SOURCE];
  }
  if (options2.twigPrintWidth) {
    options2.printWidth = options2.twigPrintWidth;
  }
  checkForIgnoreEnd(node);
  const useOriginalSource = shouldApplyIgnoreNext(node) && ignoreNext || ignoreRegion;
  const hasPrintFunction = printFunctions[nodeType];
  if (!useOriginalSource && hasPrintFunction) {
    checkForIgnoreStart(node);
    return printFunctions[nodeType](node, path2, print2, options2);
  } else if (!hasPrintFunction) {
    console.warn(`No print function available for node type "${nodeType}"`);
  }
  checkForIgnoreStart(node);
  if (canGetSubstringForNode(node)) {
    return getSubstringForNode(node);
  }
  return "";
}, "print");
var getSubstringForNode = /* @__PURE__ */ __name((node) => originalSource.substring(node.loc.start.index, node.loc.end.index), "getSubstringForNode");
var canGetSubstringForNode = /* @__PURE__ */ __name((node) => originalSource && node.loc && node.loc.start && node.loc.end && node.loc.start.index && node.loc.end.index, "canGetSubstringForNode");
printFunctions["SequenceExpression"] = printSequenceExpression;
printFunctions["ConstantValue"] = (node) => {
  return node.value;
};
printFunctions["StringLiteral"] = printStringLiteral;
printFunctions["Identifier"] = printIdentifier;
printFunctions["UnaryExpression"] = printUnaryExpression;
printFunctions["BinaryExpression"] = printBinaryExpression;
printFunctions["BinarySubclass"] = printBinaryExpression;
printFunctions["UnarySubclass"] = printUnarySubclass;
printFunctions["TestExpression"] = printTestExpression;
printFunctions["ConditionalExpression"] = printConditionalExpression;
printFunctions["Element"] = printElement;
printFunctions["Attribute"] = printAttribute;
printFunctions["PrintTextStatement"] = printTextStatement;
printFunctions["PrintExpressionStatement"] = printExpressionStatement;
printFunctions["MemberExpression"] = printMemberExpression;
printFunctions["FilterExpression"] = printFilterExpression;
printFunctions["ObjectExpression"] = printObjectExpression;
printFunctions["ObjectProperty"] = printObjectProperty;
var returnNodeValue = /* @__PURE__ */ __name((node) => "" + node.value, "returnNodeValue");
printFunctions["Fragment"] = (node, path2, print2) => {
  return path2.call(print2, "value");
};
printFunctions["NumericLiteral"] = returnNodeValue;
printFunctions["BooleanLiteral"] = returnNodeValue;
printFunctions["NullLiteral"] = () => "null";
printFunctions["ArrayExpression"] = printArrayExpression;
printFunctions["CallExpression"] = printCallExpression;
printFunctions["NamedArgumentExpression"] = printNamedArgumentExpression;
printFunctions["SliceExpression"] = printSliceExpression;
printFunctions["UseStatement"] = printUseStatement;
printFunctions["AliasExpression"] = printAliasExpression;
printFunctions["BlockStatement"] = printBlockStatement;
printFunctions["SpacelessBlock"] = printSpacelessBlock;
printFunctions["AutoescapeBlock"] = printAutoescapeBlock;
printFunctions["FlushStatement"] = printFlushStatement;
printFunctions["IncludeStatement"] = printIncludeStatement;
printFunctions["IfStatement"] = printIfStatement;
printFunctions["MountStatement"] = printMountStatement;
printFunctions["ForStatement"] = printForStatement;
printFunctions["BinaryConcatExpression"] = printBinaryExpression;
printFunctions["SetStatement"] = printSetStatement;
printFunctions["VariableDeclarationStatement"] = printVariableDeclarationStatement;
printFunctions["DoStatement"] = printDoStatement;
printFunctions["ExtendsStatement"] = printExtendsStatement;
printFunctions["EmbedStatement"] = printEmbedStatement;
printFunctions["FilterBlockStatement"] = printFilterBlockStatement;
printFunctions["ImportDeclaration"] = printImportDeclaration;
printFunctions["FromStatement"] = printFromStatement;
printFunctions["MacroDeclarationStatement"] = printMacroDeclarationStatement;
printFunctions["TwigComment"] = printTwigComment;
printFunctions["HtmlComment"] = printHtmlComment;
printFunctions["Declaration"] = printDeclaration;
printFunctions["GenericTwigTag"] = (node, path2, print2, options2) => {
  const tagName = node.tagName;
  if (printFunctions[tagName + "Tag"]) {
    return printFunctions[tagName + "Tag"](node, path2, print2, options2);
  }
  return printGenericTwigTag(node, path2, print2, options2);
};
printFunctions["GenericToken"] = printGenericToken;
printFunctions["String"] = (s) => s;

// src/embed.js
var import_melody_types26 = __toESM(require_lib2());
function embed(path2, print2, textToDoc, options2) {
  const node = path2.getValue();
  if (node instanceof import_melody_types26.Element) {
    let tagName = node.name.toLowerCase();
    if (tagName == "script" || tagName == "style") {
      let parser = tagName == "script" ? "babel" : "css";
      let { value } = node.children?.[0].value;
      if (value) {
        let opening = group(printOpeningTag(node, path2, print2));
        let children = indent([softline, textToDoc(value, { ...options2, parser }, { stripTrailingHardline: true })]);
        return [opening, children, hardline, concat(["</", node.name, ">"])];
      }
    }
  }
  return false;
}
__name(embed, "embed");

// src/index.js
var languages = [
  {
    name: "melody",
    parsers: ["melody"],
    group: "Melody",
    tmScope: "melody.twig",
    aceMode: "html",
    codemirrorMode: "clike",
    codemirrorMimeType: "text/melody-twig",
    extensions: [".melody.twig", ".html.twig", ".twig", ".django", ".jinja"],
    linguistLanguageId: 0,
    vscodeLanguageIds: ["twig", "django", "django-html"]
  }
];
function hasPragma() {
  return false;
}
__name(hasPragma, "hasPragma");
function locStart() {
  return -1;
}
__name(locStart, "locStart");
function locEnd() {
  return -1;
}
__name(locEnd, "locEnd");
var parsers = {
  melody: {
    parse,
    astFormat: "melody",
    hasPragma,
    locStart,
    locEnd
  }
};
function canAttachComment(node) {
  return node.ast_type && node.ast_type !== "comment";
}
__name(canAttachComment, "canAttachComment");
function printComment(commentPath) {
  const comment = commentPath.getValue();
  switch (comment.ast_type) {
    case "comment":
      return comment.value;
    default:
      throw new Error("Not a comment: " + JSON.stringify(comment));
  }
}
__name(printComment, "printComment");
function clean(ast, newObj) {
  delete newObj.lineno;
  delete newObj.col_offset;
}
__name(clean, "clean");
var printers = {
  melody: {
    print,
    embed,
    printComment,
    canAttachComment,
    massageAstNode: clean,
    willPrintOwnComments: () => true
  }
};
var options = {
  twigMelodyPlugins: {
    type: "path",
    category: "Global",
    array: true,
    default: [{ value: [] }],
    description: "Provide additional plugins for Melody. Relative file path from the project root."
  },
  twigMultiTags: {
    type: "path",
    category: "Global",
    array: true,
    default: [{ value: [] }],
    description: "Make custom Twig tags known to the parser."
  },
  twigSingleQuote: {
    type: "boolean",
    category: "Global",
    default: true,
    description: "Use single quotes in Twig files?"
  },
  twigAlwaysBreakObjects: {
    type: "boolean",
    category: "Global",
    default: true,
    description: "Should objects always break in Twig files?"
  },
  twigPrintWidth: {
    type: "int",
    category: "Global",
    default: 80,
    description: "Print width for Twig files"
  },
  twigFollowOfficialCodingStandards: {
    type: "boolean",
    category: "Global",
    default: true,
    description: "See https://twig.symfony.com/doc/2.x/coding_standards.html"
  },
  twigOutputEndblockName: {
    type: "boolean",
    category: "Global",
    default: false,
    description: "Output the Twig block name in the 'endblock' tag"
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EXPRESSION_NEEDED,
  FILTER_BLOCK,
  GROUP_TOP_LEVEL_LOGICAL,
  INSIDE_OF_STRING,
  IS_ROOT_LOGICAL_EXPRESSION,
  NEWLINES_ONLY,
  OVERRIDE_QUOTE_CHAR,
  PRESERVE_LEADING_WHITESPACE,
  PRESERVE_TRAILING_WHITESPACE,
  STRING_NEEDS_QUOTES,
  countNewlines,
  createTextGroups,
  findParentNode,
  firstValueInAncestorChain,
  getDeepProperty,
  hasAtLeastTwoNewlines,
  hasNoNewlines,
  indentWithHardline,
  isContractableNodeType,
  isEmptySequence,
  isHtmlCommentEqualTo,
  isInlineElement,
  isMelodyNode,
  isMultipartExpression,
  isNotExpression,
  isRootNode,
  isTwigCommentEqualTo,
  isValidIdentifierName,
  isWhitespaceNode,
  isWhitespaceOnly,
  languages,
  normalizeHtmlComment,
  normalizeTwigComment,
  options,
  parsers,
  printChildBlock,
  printChildGroups,
  printers,
  quoteChar,
  registerContractableNodeType,
  removeSurroundingWhitespace,
  setDeepProperty,
  shouldExpressionsBeWrapped,
  someParentNode,
  stripHtmlCommentChars,
  stripTwigCommentChars,
  testCurrentAndParentNodes,
  testCurrentNode,
  walkParents,
  wrapExpressionIfNeeded,
  wrapInEnvironment,
  wrapInStringInterpolation
});
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
//# sourceMappingURL=index.js.map
